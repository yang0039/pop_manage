// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api_service.proto

package mtproto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

///////////////////////////////////////////////////////////////////////////////
// api.addAuthKey#a378255b auth_key_id:long auth_key:bytes = Null;
type TLApiAddAuthKey struct {
	AuthKeyId int64  `protobuf:"varint,1,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	AuthKey   []byte `protobuf:"bytes,2,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
}

func (m *TLApiAddAuthKey) Reset()         { *m = TLApiAddAuthKey{} }
func (m *TLApiAddAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLApiAddAuthKey) ProtoMessage()    {}
func (*TLApiAddAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_dac1f622be3e5824, []int{0}
}
func (m *TLApiAddAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLApiAddAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLApiAddAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLApiAddAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLApiAddAuthKey.Merge(m, src)
}
func (m *TLApiAddAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLApiAddAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLApiAddAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLApiAddAuthKey proto.InternalMessageInfo

func (m *TLApiAddAuthKey) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLApiAddAuthKey) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// api.initConnectionLite#1933c9ca {X:Type} api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string = Null;
type TLApiInitConnectionLite struct {
	ApiId          int32  `protobuf:"varint,1,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel    string `protobuf:"bytes,2,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion  string `protobuf:"bytes,3,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion     string `protobuf:"bytes,4,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	SystemLangCode string `protobuf:"bytes,5,opt,name=system_lang_code,json=systemLangCode,proto3" json:"system_lang_code,omitempty"`
	LangPack       string `protobuf:"bytes,6,opt,name=lang_pack,json=langPack,proto3" json:"lang_pack,omitempty"`
	LangCode       string `protobuf:"bytes,7,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
}

func (m *TLApiInitConnectionLite) Reset()         { *m = TLApiInitConnectionLite{} }
func (m *TLApiInitConnectionLite) String() string { return proto.CompactTextString(m) }
func (*TLApiInitConnectionLite) ProtoMessage()    {}
func (*TLApiInitConnectionLite) Descriptor() ([]byte, []int) {
	return fileDescriptor_dac1f622be3e5824, []int{1}
}
func (m *TLApiInitConnectionLite) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLApiInitConnectionLite) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLApiInitConnectionLite.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLApiInitConnectionLite) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLApiInitConnectionLite.Merge(m, src)
}
func (m *TLApiInitConnectionLite) XXX_Size() int {
	return m.Size()
}
func (m *TLApiInitConnectionLite) XXX_DiscardUnknown() {
	xxx_messageInfo_TLApiInitConnectionLite.DiscardUnknown(m)
}

var xxx_messageInfo_TLApiInitConnectionLite proto.InternalMessageInfo

func (m *TLApiInitConnectionLite) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *TLApiInitConnectionLite) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *TLApiInitConnectionLite) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *TLApiInitConnectionLite) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *TLApiInitConnectionLite) GetSystemLangCode() string {
	if m != nil {
		return m.SystemLangCode
	}
	return ""
}

func (m *TLApiInitConnectionLite) GetLangPack() string {
	if m != nil {
		return m.LangPack
	}
	return ""
}

func (m *TLApiInitConnectionLite) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

///////////////////////////////////////////////////////////////////////////////
// api.coinRequest#226d066a method:string data:string = coinMessage;
type TLApiCoinRequest struct {
	Method string `protobuf:"bytes,1,opt,name=method,proto3" json:"method,omitempty"`
	Data   string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TLApiCoinRequest) Reset()         { *m = TLApiCoinRequest{} }
func (m *TLApiCoinRequest) String() string { return proto.CompactTextString(m) }
func (*TLApiCoinRequest) ProtoMessage()    {}
func (*TLApiCoinRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_dac1f622be3e5824, []int{2}
}
func (m *TLApiCoinRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLApiCoinRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLApiCoinRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLApiCoinRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLApiCoinRequest.Merge(m, src)
}
func (m *TLApiCoinRequest) XXX_Size() int {
	return m.Size()
}
func (m *TLApiCoinRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_TLApiCoinRequest.DiscardUnknown(m)
}

var xxx_messageInfo_TLApiCoinRequest proto.InternalMessageInfo

func (m *TLApiCoinRequest) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *TLApiCoinRequest) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func init() {
	proto.RegisterType((*TLApiAddAuthKey)(nil), "mtproto.TL_api_addAuthKey")
	proto.RegisterType((*TLApiInitConnectionLite)(nil), "mtproto.TL_api_initConnectionLite")
	proto.RegisterType((*TLApiCoinRequest)(nil), "mtproto.TL_api_coinRequest")
}

func init() { proto.RegisterFile("api_service.proto", fileDescriptor_dac1f622be3e5824) }

var fileDescriptor_dac1f622be3e5824 = []byte{
	// 433 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x74, 0x91, 0xc1, 0x6a, 0xdb, 0x40,
	0x10, 0x86, 0x25, 0x27, 0x96, 0xa3, 0x71, 0x92, 0x36, 0x4b, 0x1b, 0x14, 0x05, 0xd4, 0x54, 0x50,
	0xf0, 0x49, 0x87, 0xf6, 0x5c, 0x68, 0x6a, 0x28, 0x0d, 0xb5, 0x43, 0x10, 0xa5, 0x57, 0x31, 0xd5,
	0x0e, 0xf6, 0x62, 0x49, 0xbb, 0xf5, 0xae, 0x03, 0x3e, 0xf6, 0x0d, 0xfa, 0x58, 0x3d, 0xe6, 0xd8,
	0x53, 0x29, 0xf6, 0x8b, 0x14, 0xad, 0x64, 0xb7, 0xd8, 0xe4, 0xb6, 0xfa, 0xff, 0x6f, 0x3e, 0x18,
	0x0d, 0x9c, 0xa1, 0x12, 0x99, 0xa6, 0xf9, 0xbd, 0xc8, 0x29, 0x51, 0x73, 0x69, 0x24, 0xeb, 0x95,
	0xc6, 0x3e, 0xc2, 0x50, 0xe7, 0x53, 0x2a, 0x31, 0x31, 0x45, 0x92, 0xcb, 0x39, 0x65, 0x66, 0xa9,
	0x48, 0x37, 0x50, 0xe8, 0xa3, 0x12, 0xcd, 0x33, 0xbe, 0x85, 0xb3, 0xcf, 0xa3, 0xac, 0xf6, 0x20,
	0xe7, 0xd7, 0x0b, 0x33, 0xfd, 0x44, 0x4b, 0x16, 0x41, 0x1f, 0x17, 0x66, 0x9a, 0xcd, 0x68, 0x99,
	0x09, 0x1e, 0xb8, 0x57, 0xee, 0xe0, 0x20, 0xf5, 0xb1, 0x69, 0x6f, 0x38, 0xbb, 0x80, 0xa3, 0x4d,
	0x1f, 0x74, 0xae, 0xdc, 0xc1, 0x71, 0xda, 0x6b, 0xcb, 0xf8, 0x7b, 0x07, 0x2e, 0x5a, 0xa1, 0xa8,
	0x84, 0x19, 0xca, 0xaa, 0xa2, 0xdc, 0x08, 0x59, 0x8d, 0x84, 0x21, 0xf6, 0x1c, 0x3c, 0xdb, 0x34,
	0xce, 0x6e, 0xda, 0x45, 0x25, 0x6e, 0x38, 0x7b, 0x09, 0xc7, 0x9c, 0xea, 0x25, 0xb2, 0x52, 0x72,
	0x2a, 0xac, 0xd3, 0x4f, 0xfb, 0x4d, 0x36, 0xae, 0x23, 0xf6, 0x0a, 0x4e, 0xf5, 0x52, 0x1b, 0x2a,
	0xb3, 0x7b, 0x9a, 0x6b, 0x21, 0xab, 0xe0, 0xc0, 0x42, 0x27, 0x4d, 0xfa, 0xa5, 0x09, 0xd9, 0x0b,
	0xe8, 0xa3, 0x52, 0x5b, 0xe6, 0xd0, 0x32, 0x80, 0x4a, 0x6d, 0x80, 0x01, 0x3c, 0x6d, 0x3d, 0x05,
	0x56, 0x93, 0x2c, 0x97, 0x9c, 0x82, 0xae, 0xa5, 0x5a, 0xff, 0x08, 0xab, 0xc9, 0x50, 0x72, 0x62,
	0x97, 0xe0, 0x5b, 0x44, 0x61, 0x3e, 0x0b, 0x3c, 0x8b, 0x1c, 0xd5, 0xc1, 0x1d, 0xe6, 0xb3, 0x6d,
	0x69, 0xe7, 0x7b, 0xff, 0xca, 0x7a, 0x32, 0x7e, 0x07, 0xac, 0xfd, 0x05, 0xb9, 0x14, 0x55, 0x4a,
	0xdf, 0x16, 0xa4, 0x0d, 0x3b, 0x07, 0xaf, 0x24, 0x33, 0x95, 0xcd, 0xee, 0x7e, 0xda, 0x7e, 0x31,
	0x06, 0x87, 0x1c, 0x0d, 0xb6, 0x4b, 0xdb, 0xf7, 0xeb, 0xdf, 0x2e, 0x78, 0xe9, 0xdd, 0xf0, 0x5a,
	0x09, 0xf6, 0x16, 0x4e, 0x77, 0xae, 0x13, 0x26, 0xed, 0x8d, 0x93, 0xbd, 0xcb, 0x85, 0x27, 0xdb,
	0xee, 0x76, 0x51, 0x14, 0xb1, 0xc3, 0xc6, 0x70, 0xfe, 0xc8, 0x2d, 0xe2, 0x5d, 0xcd, 0x3e, 0xb3,
	0xaf, 0xfb, 0x00, 0x4f, 0x76, 0xf7, 0xba, 0xdc, 0xf5, 0xfc, 0x57, 0x86, 0xcf, 0xb6, 0x65, 0x9d,
	0x8e, 0x49, 0x6b, 0x9c, 0x50, 0xec, 0xbc, 0x0f, 0x7f, 0xae, 0x22, 0xf7, 0x61, 0x15, 0xb9, 0x7f,
	0x56, 0x91, 0xfb, 0x63, 0x1d, 0x39, 0x0f, 0xeb, 0xc8, 0xf9, 0xb5, 0x8e, 0x9c, 0x8f, 0x9d, 0xaf,
	0x9e, 0x1d, 0x78, 0xf3, 0x37, 0x00, 0x00, 0xff, 0xff, 0x51, 0xfb, 0x91, 0x7a, 0xde, 0x02, 0x00,
	0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCApiClient is the client API for RPCApi service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCApiClient interface {
	// api.addAuthKey#a378255b auth_key_id:long auth_key:bytes = Null;
	ApiAddAuthKey(ctx context.Context, in *TLApiAddAuthKey, opts ...grpc.CallOption) (*Null, error)
	// api.initConnectionLite#1933c9ca {X:Type} api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string = Null;
	ApiInitConnectionLite(ctx context.Context, in *TLApiInitConnectionLite, opts ...grpc.CallOption) (*Null, error)
	// api.coinRequest#226d066a method:string data:string = coinMessage;
	ApiCoinRequest(ctx context.Context, in *TLApiCoinRequest, opts ...grpc.CallOption) (*CoinMessage, error)
}

type rPCApiClient struct {
	cc *grpc.ClientConn
}

func NewRPCApiClient(cc *grpc.ClientConn) RPCApiClient {
	return &rPCApiClient{cc}
}

func (c *rPCApiClient) ApiAddAuthKey(ctx context.Context, in *TLApiAddAuthKey, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/mtproto.RPCApi/api_addAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCApiClient) ApiInitConnectionLite(ctx context.Context, in *TLApiInitConnectionLite, opts ...grpc.CallOption) (*Null, error) {
	out := new(Null)
	err := c.cc.Invoke(ctx, "/mtproto.RPCApi/api_initConnectionLite", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCApiClient) ApiCoinRequest(ctx context.Context, in *TLApiCoinRequest, opts ...grpc.CallOption) (*CoinMessage, error) {
	out := new(CoinMessage)
	err := c.cc.Invoke(ctx, "/mtproto.RPCApi/api_coinRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCApiServer is the server API for RPCApi service.
type RPCApiServer interface {
	// api.addAuthKey#a378255b auth_key_id:long auth_key:bytes = Null;
	ApiAddAuthKey(context.Context, *TLApiAddAuthKey) (*Null, error)
	// api.initConnectionLite#1933c9ca {X:Type} api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string = Null;
	ApiInitConnectionLite(context.Context, *TLApiInitConnectionLite) (*Null, error)
	// api.coinRequest#226d066a method:string data:string = coinMessage;
	ApiCoinRequest(context.Context, *TLApiCoinRequest) (*CoinMessage, error)
}

// UnimplementedRPCApiServer can be embedded to have forward compatible implementations.
type UnimplementedRPCApiServer struct {
}

func (*UnimplementedRPCApiServer) ApiAddAuthKey(ctx context.Context, req *TLApiAddAuthKey) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiAddAuthKey not implemented")
}
func (*UnimplementedRPCApiServer) ApiInitConnectionLite(ctx context.Context, req *TLApiInitConnectionLite) (*Null, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiInitConnectionLite not implemented")
}
func (*UnimplementedRPCApiServer) ApiCoinRequest(ctx context.Context, req *TLApiCoinRequest) (*CoinMessage, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApiCoinRequest not implemented")
}

func RegisterRPCApiServer(s *grpc.Server, srv RPCApiServer) {
	s.RegisterService(&_RPCApi_serviceDesc, srv)
}

func _RPCApi_ApiAddAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLApiAddAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCApiServer).ApiAddAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCApi/ApiAddAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCApiServer).ApiAddAuthKey(ctx, req.(*TLApiAddAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCApi_ApiInitConnectionLite_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLApiInitConnectionLite)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCApiServer).ApiInitConnectionLite(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCApi/ApiInitConnectionLite",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCApiServer).ApiInitConnectionLite(ctx, req.(*TLApiInitConnectionLite))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCApi_ApiCoinRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLApiCoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCApiServer).ApiCoinRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCApi/ApiCoinRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCApiServer).ApiCoinRequest(ctx, req.(*TLApiCoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCApi_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mtproto.RPCApi",
	HandlerType: (*RPCApiServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "api_addAuthKey",
			Handler:    _RPCApi_ApiAddAuthKey_Handler,
		},
		{
			MethodName: "api_initConnectionLite",
			Handler:    _RPCApi_ApiInitConnectionLite_Handler,
		},
		{
			MethodName: "api_coinRequest",
			Handler:    _RPCApi_ApiCoinRequest_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api_service.proto",
}

func (m *TLApiAddAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLApiAddAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLApiAddAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthKey) > 0 {
		i -= len(m.AuthKey)
		copy(dAtA[i:], m.AuthKey)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.AuthKey)))
		i--
		dAtA[i] = 0x12
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintApiService(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLApiInitConnectionLite) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLApiInitConnectionLite) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLApiInitConnectionLite) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LangCode) > 0 {
		i -= len(m.LangCode)
		copy(dAtA[i:], m.LangCode)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.LangCode)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.LangPack) > 0 {
		i -= len(m.LangPack)
		copy(dAtA[i:], m.LangPack)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.LangPack)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.SystemLangCode) > 0 {
		i -= len(m.SystemLangCode)
		copy(dAtA[i:], m.SystemLangCode)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.SystemLangCode)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.AppVersion) > 0 {
		i -= len(m.AppVersion)
		copy(dAtA[i:], m.AppVersion)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.AppVersion)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.SystemVersion) > 0 {
		i -= len(m.SystemVersion)
		copy(dAtA[i:], m.SystemVersion)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.SystemVersion)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.DeviceModel) > 0 {
		i -= len(m.DeviceModel)
		copy(dAtA[i:], m.DeviceModel)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.DeviceModel)))
		i--
		dAtA[i] = 0x12
	}
	if m.ApiId != 0 {
		i = encodeVarintApiService(dAtA, i, uint64(m.ApiId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLApiCoinRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLApiCoinRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLApiCoinRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Method) > 0 {
		i -= len(m.Method)
		copy(dAtA[i:], m.Method)
		i = encodeVarintApiService(dAtA, i, uint64(len(m.Method)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintApiService(dAtA []byte, offset int, v uint64) int {
	offset -= sovApiService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TLApiAddAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthKeyId != 0 {
		n += 1 + sovApiService(uint64(m.AuthKeyId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	return n
}

func (m *TLApiInitConnectionLite) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ApiId != 0 {
		n += 1 + sovApiService(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	l = len(m.SystemLangCode)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	l = len(m.LangPack)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	return n
}

func (m *TLApiCoinRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovApiService(uint64(l))
	}
	return n
}

func sovApiService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozApiService(x uint64) (n int) {
	return sovApiService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TLApiAddAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_api_addAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_api_addAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApiService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLApiInitConnectionLite) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_api_initConnectionLite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_api_initConnectionLite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemLangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangPack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangPack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApiService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLApiCoinRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApiService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_api_coinRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_api_coinRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApiService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthApiService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApiService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApiService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthApiService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApiService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApiService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApiService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthApiService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupApiService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthApiService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthApiService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApiService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupApiService = fmt.Errorf("proto: unexpected end of group")
)
