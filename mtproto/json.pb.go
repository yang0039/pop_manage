// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: json.proto

package mtproto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor2 int32

const (
	TLConstructor2_CRC32_UNKNOWN2       TLConstructor2 = 0
	TLConstructor2_CRC32_jsonproto_call TLConstructor2 = 468817387
)

var TLConstructor2_name = map[int32]string{
	0:         "CRC32_UNKNOWN2",
	468817387: "CRC32_jsonproto_call",
}

var TLConstructor2_value = map[string]int32{
	"CRC32_UNKNOWN2":       0,
	"CRC32_jsonproto_call": 468817387,
}

func (x TLConstructor2) String() string {
	return proto.EnumName(TLConstructor2_name, int32(x))
}

func (TLConstructor2) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_93d0772b96a2f7bf, []int{0}
}

///////////////////////////////////////////////////////////////////////////////
// jsonproto.call#1bf195eb cmd:int data:string = DataJSON;
type TLJsonprotoCall struct {
	Cmd  int32  `protobuf:"varint,1,opt,name=cmd,proto3" json:"cmd,omitempty"`
	Data string `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *TLJsonprotoCall) Reset()         { *m = TLJsonprotoCall{} }
func (m *TLJsonprotoCall) String() string { return proto.CompactTextString(m) }
func (*TLJsonprotoCall) ProtoMessage()    {}
func (*TLJsonprotoCall) Descriptor() ([]byte, []int) {
	return fileDescriptor_93d0772b96a2f7bf, []int{0}
}
func (m *TLJsonprotoCall) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLJsonprotoCall) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLJsonprotoCall.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLJsonprotoCall) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLJsonprotoCall.Merge(m, src)
}
func (m *TLJsonprotoCall) XXX_Size() int {
	return m.Size()
}
func (m *TLJsonprotoCall) XXX_DiscardUnknown() {
	xxx_messageInfo_TLJsonprotoCall.DiscardUnknown(m)
}

var xxx_messageInfo_TLJsonprotoCall proto.InternalMessageInfo

func (m *TLJsonprotoCall) GetCmd() int32 {
	if m != nil {
		return m.Cmd
	}
	return 0
}

func (m *TLJsonprotoCall) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func init() {
	proto.RegisterEnum("mtproto.TLConstructor2", TLConstructor2_name, TLConstructor2_value)
	proto.RegisterType((*TLJsonprotoCall)(nil), "mtproto.TL_jsonproto_call")
}

func init() { proto.RegisterFile("json.proto", fileDescriptor_93d0772b96a2f7bf) }

var fileDescriptor_93d0772b96a2f7bf = []byte{
	// 231 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0xe2, 0xca, 0x2a, 0xce, 0xcf,
	0xd3, 0x2b, 0x28, 0xca, 0x2f, 0xc9, 0x17, 0x62, 0xcf, 0x2d, 0x01, 0x33, 0xa4, 0x44, 0x8a, 0x93,
	0x33, 0x52, 0x73, 0x13, 0xf5, 0x4a, 0x72, 0xf4, 0x8a, 0x2b, 0xf3, 0x92, 0x21, 0xd2, 0x4a, 0x96,
	0x5c, 0x82, 0x21, 0x3e, 0xf1, 0x20, 0xf5, 0x60, 0x7e, 0x7c, 0x72, 0x62, 0x4e, 0x8e, 0x90, 0x00,
	0x17, 0x73, 0x72, 0x6e, 0x8a, 0x04, 0xa3, 0x02, 0xa3, 0x06, 0x6b, 0x10, 0x88, 0x29, 0x24, 0xc4,
	0xc5, 0x92, 0x92, 0x58, 0x92, 0x28, 0xc1, 0xa4, 0xc0, 0xa8, 0xc1, 0x19, 0x04, 0x66, 0x6b, 0x39,
	0x71, 0xf1, 0x85, 0xf8, 0x38, 0xe7, 0xe7, 0x15, 0x97, 0x14, 0x95, 0x26, 0x97, 0xe4, 0x17, 0x19,
	0x09, 0x09, 0x71, 0xf1, 0x39, 0x07, 0x39, 0x1b, 0x1b, 0xc5, 0x87, 0xfa, 0x79, 0xfb, 0xf9, 0x87,
	0xfb, 0x19, 0x09, 0x30, 0x08, 0xc9, 0x70, 0x89, 0x40, 0xc4, 0x50, 0xed, 0x10, 0x78, 0xbd, 0xfa,
	0xd8, 0x7d, 0x46, 0xa3, 0x40, 0x2e, 0x9e, 0xa0, 0x00, 0x67, 0x2f, 0x98, 0x94, 0x90, 0x23, 0x17,
	0x1f, 0x9a, 0x5b, 0xa4, 0xf4, 0xa0, 0x1e, 0xd0, 0xc3, 0x70, 0xa7, 0x94, 0x20, 0x5c, 0xce, 0x25,
	0xb1, 0x24, 0xd1, 0x2b, 0xd8, 0xdf, 0x4f, 0x89, 0xc1, 0x49, 0xe2, 0xc4, 0x23, 0x39, 0xc6, 0x0b,
	0x8f, 0xe4, 0x18, 0x1f, 0x3c, 0x92, 0x63, 0x9c, 0xf0, 0x58, 0x8e, 0xe1, 0xc2, 0x63, 0x39, 0x86,
	0x1b, 0x8f, 0xe5, 0x18, 0x92, 0xd8, 0xc0, 0x6a, 0x8d, 0x01, 0x01, 0x00, 0x00, 0xff, 0xff, 0xa1,
	0x5f, 0x60, 0x7e, 0x1f, 0x01, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCJsonprotoClient is the client API for RPCJsonproto service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCJsonprotoClient interface {
	// jsonproto.call#1bf195eb cmd:int data:string = DataJSON;
	JsonprotoCall(ctx context.Context, in *TLJsonprotoCall, opts ...grpc.CallOption) (*DataJSON, error)
}

type rPCJsonprotoClient struct {
	cc *grpc.ClientConn
}

func NewRPCJsonprotoClient(cc *grpc.ClientConn) RPCJsonprotoClient {
	return &rPCJsonprotoClient{cc}
}

func (c *rPCJsonprotoClient) JsonprotoCall(ctx context.Context, in *TLJsonprotoCall, opts ...grpc.CallOption) (*DataJSON, error) {
	out := new(DataJSON)
	err := c.cc.Invoke(ctx, "/mtproto.RPCJsonproto/jsonproto_call", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCJsonprotoServer is the server API for RPCJsonproto service.
type RPCJsonprotoServer interface {
	// jsonproto.call#1bf195eb cmd:int data:string = DataJSON;
	JsonprotoCall(context.Context, *TLJsonprotoCall) (*DataJSON, error)
}

// UnimplementedRPCJsonprotoServer can be embedded to have forward compatible implementations.
type UnimplementedRPCJsonprotoServer struct {
}

func (*UnimplementedRPCJsonprotoServer) JsonprotoCall(ctx context.Context, req *TLJsonprotoCall) (*DataJSON, error) {
	return nil, status.Errorf(codes.Unimplemented, "method JsonprotoCall not implemented")
}

func RegisterRPCJsonprotoServer(s *grpc.Server, srv RPCJsonprotoServer) {
	s.RegisterService(&_RPCJsonproto_serviceDesc, srv)
}

func _RPCJsonproto_JsonprotoCall_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLJsonprotoCall)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCJsonprotoServer).JsonprotoCall(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCJsonproto/JsonprotoCall",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCJsonprotoServer).JsonprotoCall(ctx, req.(*TLJsonprotoCall))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCJsonproto_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mtproto.RPCJsonproto",
	HandlerType: (*RPCJsonprotoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "jsonproto_call",
			Handler:    _RPCJsonproto_JsonprotoCall_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "json.proto",
}

func (m *TLJsonprotoCall) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLJsonprotoCall) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLJsonprotoCall) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintJson(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0x12
	}
	if m.Cmd != 0 {
		i = encodeVarintJson(dAtA, i, uint64(m.Cmd))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintJson(dAtA []byte, offset int, v uint64) int {
	offset -= sovJson(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TLJsonprotoCall) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Cmd != 0 {
		n += 1 + sovJson(uint64(m.Cmd))
	}
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovJson(uint64(l))
	}
	return n
}

func sovJson(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozJson(x uint64) (n int) {
	return sovJson(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TLJsonprotoCall) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowJson
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_jsonproto_call: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_jsonproto_call: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			m.Cmd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJson
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cmd |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowJson
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthJson
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthJson
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipJson(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthJson
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthJson
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipJson(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowJson
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJson
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowJson
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthJson
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupJson
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthJson
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthJson        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowJson          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupJson = fmt.Errorf("proto: unexpected end of group")
)
