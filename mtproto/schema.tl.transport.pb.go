// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema.tl.transport.proto

package mtproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

///////////////////////////////////////////////////////////////////////////////
// RpcError <--
//  + TL_rpc_error
//
type RpcError_Data struct {
	ErrorCode    int32  `protobuf:"varint,1,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	ErrorMessage string `protobuf:"bytes,2,opt,name=error_message,json=errorMessage,proto3" json:"error_message,omitempty"`
}

func (m *RpcError_Data) Reset()         { *m = RpcError_Data{} }
func (m *RpcError_Data) String() string { return proto.CompactTextString(m) }
func (*RpcError_Data) ProtoMessage()    {}
func (*RpcError_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{0}
}
func (m *RpcError_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcError_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcError_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcError_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcError_Data.Merge(m, src)
}
func (m *RpcError_Data) XXX_Size() int {
	return m.Size()
}
func (m *RpcError_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcError_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RpcError_Data proto.InternalMessageInfo

func (m *RpcError_Data) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *RpcError_Data) GetErrorMessage() string {
	if m != nil {
		return m.ErrorMessage
	}
	return ""
}

type RpcError struct {
	Constructor TLConstructor  `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *RpcError_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *RpcError) Reset()         { *m = RpcError{} }
func (m *RpcError) String() string { return proto.CompactTextString(m) }
func (*RpcError) ProtoMessage()    {}
func (*RpcError) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{1}
}
func (m *RpcError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcError.Merge(m, src)
}
func (m *RpcError) XXX_Size() int {
	return m.Size()
}
func (m *RpcError) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcError.DiscardUnknown(m)
}

var xxx_messageInfo_RpcError proto.InternalMessageInfo

func (m *RpcError) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *RpcError) GetData2() *RpcError_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// rpc_error#2144ca19 error_code:int error_message:string = RpcError;
type TLRpcError struct {
	Data2 *RpcError_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLRpcError) Reset()         { *m = TLRpcError{} }
func (m *TLRpcError) String() string { return proto.CompactTextString(m) }
func (*TLRpcError) ProtoMessage()    {}
func (*TLRpcError) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{2}
}
func (m *TLRpcError) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcError) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcError.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcError) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcError.Merge(m, src)
}
func (m *TLRpcError) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcError) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcError.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcError proto.InternalMessageInfo

func (m *TLRpcError) GetData2() *RpcError_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// FutureSalts <--
//  + TL_future_salts
//
type FutureSalts_Data struct {
	ReqMsgId int64           `protobuf:"varint,1,opt,name=req_msg_id,json=reqMsgId,proto3" json:"req_msg_id,omitempty"`
	Now      int32           `protobuf:"varint,2,opt,name=now,proto3" json:"now,omitempty"`
	Salts    []*TLFutureSalt `protobuf:"bytes,3,rep,name=salts,proto3" json:"salts,omitempty"`
}

func (m *FutureSalts_Data) Reset()         { *m = FutureSalts_Data{} }
func (m *FutureSalts_Data) String() string { return proto.CompactTextString(m) }
func (*FutureSalts_Data) ProtoMessage()    {}
func (*FutureSalts_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{3}
}
func (m *FutureSalts_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FutureSalts_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FutureSalts_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FutureSalts_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureSalts_Data.Merge(m, src)
}
func (m *FutureSalts_Data) XXX_Size() int {
	return m.Size()
}
func (m *FutureSalts_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureSalts_Data.DiscardUnknown(m)
}

var xxx_messageInfo_FutureSalts_Data proto.InternalMessageInfo

func (m *FutureSalts_Data) GetReqMsgId() int64 {
	if m != nil {
		return m.ReqMsgId
	}
	return 0
}

func (m *FutureSalts_Data) GetNow() int32 {
	if m != nil {
		return m.Now
	}
	return 0
}

func (m *FutureSalts_Data) GetSalts() []*TLFutureSalt {
	if m != nil {
		return m.Salts
	}
	return nil
}

type FutureSalts struct {
	Constructor TLConstructor     `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *FutureSalts_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *FutureSalts) Reset()         { *m = FutureSalts{} }
func (m *FutureSalts) String() string { return proto.CompactTextString(m) }
func (*FutureSalts) ProtoMessage()    {}
func (*FutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{4}
}
func (m *FutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureSalts.Merge(m, src)
}
func (m *FutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *FutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_FutureSalts proto.InternalMessageInfo

func (m *FutureSalts) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *FutureSalts) GetData2() *FutureSalts_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// future_salts#ae500895 req_msg_id:long now:int salts:vector<future_salt> = FutureSalts;
type TLFutureSalts struct {
	Data2 *FutureSalts_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLFutureSalts) Reset()         { *m = TLFutureSalts{} }
func (m *TLFutureSalts) String() string { return proto.CompactTextString(m) }
func (*TLFutureSalts) ProtoMessage()    {}
func (*TLFutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{5}
}
func (m *TLFutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLFutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLFutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLFutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLFutureSalts.Merge(m, src)
}
func (m *TLFutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *TLFutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_TLFutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_TLFutureSalts proto.InternalMessageInfo

func (m *TLFutureSalts) GetData2() *FutureSalts_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// help_ConfigSimple <--
//  + TL_help_configSimple
//  + TL_help_configSimple114
//
type Help_ConfigSimple_Data struct {
	Date       int32              `protobuf:"varint,1,opt,name=date,proto3" json:"date,omitempty"`
	Expires    int32              `protobuf:"varint,2,opt,name=expires,proto3" json:"expires,omitempty"`
	DcId       int32              `protobuf:"varint,3,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	IpPortList []*TLIpPort        `protobuf:"bytes,4,rep,name=ip_port_list,json=ipPortList,proto3" json:"ip_port_list,omitempty"`
	Rules      []*AccessPointRule `protobuf:"bytes,5,rep,name=rules,proto3" json:"rules,omitempty"`
}

func (m *Help_ConfigSimple_Data) Reset()         { *m = Help_ConfigSimple_Data{} }
func (m *Help_ConfigSimple_Data) String() string { return proto.CompactTextString(m) }
func (*Help_ConfigSimple_Data) ProtoMessage()    {}
func (*Help_ConfigSimple_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{6}
}
func (m *Help_ConfigSimple_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Help_ConfigSimple_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Help_ConfigSimple_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Help_ConfigSimple_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Help_ConfigSimple_Data.Merge(m, src)
}
func (m *Help_ConfigSimple_Data) XXX_Size() int {
	return m.Size()
}
func (m *Help_ConfigSimple_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Help_ConfigSimple_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Help_ConfigSimple_Data proto.InternalMessageInfo

func (m *Help_ConfigSimple_Data) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *Help_ConfigSimple_Data) GetExpires() int32 {
	if m != nil {
		return m.Expires
	}
	return 0
}

func (m *Help_ConfigSimple_Data) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *Help_ConfigSimple_Data) GetIpPortList() []*TLIpPort {
	if m != nil {
		return m.IpPortList
	}
	return nil
}

func (m *Help_ConfigSimple_Data) GetRules() []*AccessPointRule {
	if m != nil {
		return m.Rules
	}
	return nil
}

type Help_ConfigSimple struct {
	Constructor TLConstructor           `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *Help_ConfigSimple_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *Help_ConfigSimple) Reset()         { *m = Help_ConfigSimple{} }
func (m *Help_ConfigSimple) String() string { return proto.CompactTextString(m) }
func (*Help_ConfigSimple) ProtoMessage()    {}
func (*Help_ConfigSimple) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{7}
}
func (m *Help_ConfigSimple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Help_ConfigSimple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Help_ConfigSimple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Help_ConfigSimple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Help_ConfigSimple.Merge(m, src)
}
func (m *Help_ConfigSimple) XXX_Size() int {
	return m.Size()
}
func (m *Help_ConfigSimple) XXX_DiscardUnknown() {
	xxx_messageInfo_Help_ConfigSimple.DiscardUnknown(m)
}

var xxx_messageInfo_Help_ConfigSimple proto.InternalMessageInfo

func (m *Help_ConfigSimple) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *Help_ConfigSimple) GetData2() *Help_ConfigSimple_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// help.configSimple#d997c3c5 date:int expires:int dc_id:int ip_port_list:Vector<ipPort> = help.ConfigSimple;
type TLHelpConfigSimple struct {
	Data2 *Help_ConfigSimple_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLHelpConfigSimple) Reset()         { *m = TLHelpConfigSimple{} }
func (m *TLHelpConfigSimple) String() string { return proto.CompactTextString(m) }
func (*TLHelpConfigSimple) ProtoMessage()    {}
func (*TLHelpConfigSimple) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{8}
}
func (m *TLHelpConfigSimple) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLHelpConfigSimple) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLHelpConfigSimple.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLHelpConfigSimple) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLHelpConfigSimple.Merge(m, src)
}
func (m *TLHelpConfigSimple) XXX_Size() int {
	return m.Size()
}
func (m *TLHelpConfigSimple) XXX_DiscardUnknown() {
	xxx_messageInfo_TLHelpConfigSimple.DiscardUnknown(m)
}

var xxx_messageInfo_TLHelpConfigSimple proto.InternalMessageInfo

func (m *TLHelpConfigSimple) GetData2() *Help_ConfigSimple_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// help.configSimple#66d2808 date:int expires:int rules:vector<AccessPointRule> = help.ConfigSimple;
type TLHelpConfigSimple114 struct {
	Data2 *Help_ConfigSimple_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLHelpConfigSimple114) Reset()         { *m = TLHelpConfigSimple114{} }
func (m *TLHelpConfigSimple114) String() string { return proto.CompactTextString(m) }
func (*TLHelpConfigSimple114) ProtoMessage()    {}
func (*TLHelpConfigSimple114) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{9}
}
func (m *TLHelpConfigSimple114) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLHelpConfigSimple114) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLHelpConfigSimple114.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLHelpConfigSimple114) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLHelpConfigSimple114.Merge(m, src)
}
func (m *TLHelpConfigSimple114) XXX_Size() int {
	return m.Size()
}
func (m *TLHelpConfigSimple114) XXX_DiscardUnknown() {
	xxx_messageInfo_TLHelpConfigSimple114.DiscardUnknown(m)
}

var xxx_messageInfo_TLHelpConfigSimple114 proto.InternalMessageInfo

func (m *TLHelpConfigSimple114) GetData2() *Help_ConfigSimple_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// TlsBlock <--
//  + TL_tlsBlockString
//  + TL_tlsBlockRandom
//  + TL_tlsBlockZero
//  + TL_tlsBlockDomain
//  + TL_tlsBlockGrease
//  + TL_tlsBlockPublicKey
//  + TL_tlsBlockScope
//
type TlsBlock_Data struct {
	Data    string      `protobuf:"bytes,1,opt,name=data,proto3" json:"data,omitempty"`
	Length  int32       `protobuf:"varint,2,opt,name=length,proto3" json:"length,omitempty"`
	Seed    int32       `protobuf:"varint,3,opt,name=seed,proto3" json:"seed,omitempty"`
	Entries []*TlsBlock `protobuf:"bytes,4,rep,name=entries,proto3" json:"entries,omitempty"`
}

func (m *TlsBlock_Data) Reset()         { *m = TlsBlock_Data{} }
func (m *TlsBlock_Data) String() string { return proto.CompactTextString(m) }
func (*TlsBlock_Data) ProtoMessage()    {}
func (*TlsBlock_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{10}
}
func (m *TlsBlock_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsBlock_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TlsBlock_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TlsBlock_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsBlock_Data.Merge(m, src)
}
func (m *TlsBlock_Data) XXX_Size() int {
	return m.Size()
}
func (m *TlsBlock_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsBlock_Data.DiscardUnknown(m)
}

var xxx_messageInfo_TlsBlock_Data proto.InternalMessageInfo

func (m *TlsBlock_Data) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

func (m *TlsBlock_Data) GetLength() int32 {
	if m != nil {
		return m.Length
	}
	return 0
}

func (m *TlsBlock_Data) GetSeed() int32 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *TlsBlock_Data) GetEntries() []*TlsBlock {
	if m != nil {
		return m.Entries
	}
	return nil
}

type TlsBlock struct {
	Constructor TLConstructor  `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TlsBlock) Reset()         { *m = TlsBlock{} }
func (m *TlsBlock) String() string { return proto.CompactTextString(m) }
func (*TlsBlock) ProtoMessage()    {}
func (*TlsBlock) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{11}
}
func (m *TlsBlock) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsBlock) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TlsBlock.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TlsBlock) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsBlock.Merge(m, src)
}
func (m *TlsBlock) XXX_Size() int {
	return m.Size()
}
func (m *TlsBlock) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsBlock.DiscardUnknown(m)
}

var xxx_messageInfo_TlsBlock proto.InternalMessageInfo

func (m *TlsBlock) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *TlsBlock) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockString#4218a164 data:string = TlsBlock;
type TLTlsBlockString struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockString) Reset()         { *m = TLTlsBlockString{} }
func (m *TLTlsBlockString) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockString) ProtoMessage()    {}
func (*TLTlsBlockString) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{12}
}
func (m *TLTlsBlockString) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockString) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockString.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockString) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockString.Merge(m, src)
}
func (m *TLTlsBlockString) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockString) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockString.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockString proto.InternalMessageInfo

func (m *TLTlsBlockString) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockRandom#4d4dc41e length:int = TlsBlock;
type TLTlsBlockRandom struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockRandom) Reset()         { *m = TLTlsBlockRandom{} }
func (m *TLTlsBlockRandom) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockRandom) ProtoMessage()    {}
func (*TLTlsBlockRandom) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{13}
}
func (m *TLTlsBlockRandom) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockRandom) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockRandom.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockRandom) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockRandom.Merge(m, src)
}
func (m *TLTlsBlockRandom) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockRandom) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockRandom.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockRandom proto.InternalMessageInfo

func (m *TLTlsBlockRandom) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockZero#9333afb length:int = TlsBlock;
type TLTlsBlockZero struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockZero) Reset()         { *m = TLTlsBlockZero{} }
func (m *TLTlsBlockZero) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockZero) ProtoMessage()    {}
func (*TLTlsBlockZero) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{14}
}
func (m *TLTlsBlockZero) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockZero) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockZero.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockZero) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockZero.Merge(m, src)
}
func (m *TLTlsBlockZero) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockZero) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockZero.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockZero proto.InternalMessageInfo

func (m *TLTlsBlockZero) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockDomain#10e8636f = TlsBlock;
type TLTlsBlockDomain struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockDomain) Reset()         { *m = TLTlsBlockDomain{} }
func (m *TLTlsBlockDomain) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockDomain) ProtoMessage()    {}
func (*TLTlsBlockDomain) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{15}
}
func (m *TLTlsBlockDomain) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockDomain) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockDomain.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockDomain) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockDomain.Merge(m, src)
}
func (m *TLTlsBlockDomain) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockDomain) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockDomain.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockDomain proto.InternalMessageInfo

func (m *TLTlsBlockDomain) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockGrease#e675a1c1 seed:int = TlsBlock;
type TLTlsBlockGrease struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockGrease) Reset()         { *m = TLTlsBlockGrease{} }
func (m *TLTlsBlockGrease) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockGrease) ProtoMessage()    {}
func (*TLTlsBlockGrease) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{16}
}
func (m *TLTlsBlockGrease) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockGrease) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockGrease.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockGrease) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockGrease.Merge(m, src)
}
func (m *TLTlsBlockGrease) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockGrease) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockGrease.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockGrease proto.InternalMessageInfo

func (m *TLTlsBlockGrease) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockPublicKey#9eb95b5c = TlsBlock;
type TLTlsBlockPublicKey struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockPublicKey) Reset()         { *m = TLTlsBlockPublicKey{} }
func (m *TLTlsBlockPublicKey) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockPublicKey) ProtoMessage()    {}
func (*TLTlsBlockPublicKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{17}
}
func (m *TLTlsBlockPublicKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockPublicKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockPublicKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockPublicKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockPublicKey.Merge(m, src)
}
func (m *TLTlsBlockPublicKey) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockPublicKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockPublicKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockPublicKey proto.InternalMessageInfo

func (m *TLTlsBlockPublicKey) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsBlockScope#e725d44f entries:Vector<TlsBlock> = TlsBlock;
type TLTlsBlockScope struct {
	Data2 *TlsBlock_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsBlockScope) Reset()         { *m = TLTlsBlockScope{} }
func (m *TLTlsBlockScope) String() string { return proto.CompactTextString(m) }
func (*TLTlsBlockScope) ProtoMessage()    {}
func (*TLTlsBlockScope) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{18}
}
func (m *TLTlsBlockScope) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsBlockScope) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsBlockScope.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsBlockScope) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsBlockScope.Merge(m, src)
}
func (m *TLTlsBlockScope) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsBlockScope) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsBlockScope.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsBlockScope proto.InternalMessageInfo

func (m *TLTlsBlockScope) GetData2() *TlsBlock_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsAck <--
//  + TL_msgs_ack
//
type MsgsAck_Data struct {
	MsgIds []int64 `protobuf:"varint,1,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
}

func (m *MsgsAck_Data) Reset()         { *m = MsgsAck_Data{} }
func (m *MsgsAck_Data) String() string { return proto.CompactTextString(m) }
func (*MsgsAck_Data) ProtoMessage()    {}
func (*MsgsAck_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{19}
}
func (m *MsgsAck_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsAck_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsAck_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsAck_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsAck_Data.Merge(m, src)
}
func (m *MsgsAck_Data) XXX_Size() int {
	return m.Size()
}
func (m *MsgsAck_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsAck_Data.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsAck_Data proto.InternalMessageInfo

func (m *MsgsAck_Data) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

type MsgsAck struct {
	Constructor TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *MsgsAck_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *MsgsAck) Reset()         { *m = MsgsAck{} }
func (m *MsgsAck) String() string { return proto.CompactTextString(m) }
func (*MsgsAck) ProtoMessage()    {}
func (*MsgsAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{20}
}
func (m *MsgsAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsAck.Merge(m, src)
}
func (m *MsgsAck) XXX_Size() int {
	return m.Size()
}
func (m *MsgsAck) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsAck.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsAck proto.InternalMessageInfo

func (m *MsgsAck) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *MsgsAck) GetData2() *MsgsAck_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msgs_ack#62d6b459 msg_ids:Vector<long> = MsgsAck;
type TLMsgsAck struct {
	Data2 *MsgsAck_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgsAck) Reset()         { *m = TLMsgsAck{} }
func (m *TLMsgsAck) String() string { return proto.CompactTextString(m) }
func (*TLMsgsAck) ProtoMessage()    {}
func (*TLMsgsAck) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{21}
}
func (m *TLMsgsAck) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsAck) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsAck.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsAck) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsAck.Merge(m, src)
}
func (m *TLMsgsAck) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsAck) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsAck.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsAck proto.InternalMessageInfo

func (m *TLMsgsAck) GetData2() *MsgsAck_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsStateInfo <--
//  + TL_msgs_state_info
//
type MsgsStateInfo_Data struct {
	ReqMsgId int64  `protobuf:"varint,1,opt,name=req_msg_id,json=reqMsgId,proto3" json:"req_msg_id,omitempty"`
	Info     string `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *MsgsStateInfo_Data) Reset()         { *m = MsgsStateInfo_Data{} }
func (m *MsgsStateInfo_Data) String() string { return proto.CompactTextString(m) }
func (*MsgsStateInfo_Data) ProtoMessage()    {}
func (*MsgsStateInfo_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{22}
}
func (m *MsgsStateInfo_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsStateInfo_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsStateInfo_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsStateInfo_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsStateInfo_Data.Merge(m, src)
}
func (m *MsgsStateInfo_Data) XXX_Size() int {
	return m.Size()
}
func (m *MsgsStateInfo_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsStateInfo_Data.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsStateInfo_Data proto.InternalMessageInfo

func (m *MsgsStateInfo_Data) GetReqMsgId() int64 {
	if m != nil {
		return m.ReqMsgId
	}
	return 0
}

func (m *MsgsStateInfo_Data) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type MsgsStateInfo struct {
	Constructor TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *MsgsStateInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *MsgsStateInfo) Reset()         { *m = MsgsStateInfo{} }
func (m *MsgsStateInfo) String() string { return proto.CompactTextString(m) }
func (*MsgsStateInfo) ProtoMessage()    {}
func (*MsgsStateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{23}
}
func (m *MsgsStateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsStateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsStateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsStateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsStateInfo.Merge(m, src)
}
func (m *MsgsStateInfo) XXX_Size() int {
	return m.Size()
}
func (m *MsgsStateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsStateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsStateInfo proto.InternalMessageInfo

func (m *MsgsStateInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *MsgsStateInfo) GetData2() *MsgsStateInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msgs_state_info#04deb57d req_msg_id:long info:string = MsgsStateInfo;
type TLMsgsStateInfo struct {
	Data2 *MsgsStateInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgsStateInfo) Reset()         { *m = TLMsgsStateInfo{} }
func (m *TLMsgsStateInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgsStateInfo) ProtoMessage()    {}
func (*TLMsgsStateInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{24}
}
func (m *TLMsgsStateInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsStateInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsStateInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsStateInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsStateInfo.Merge(m, src)
}
func (m *TLMsgsStateInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsStateInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsStateInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsStateInfo proto.InternalMessageInfo

func (m *TLMsgsStateInfo) GetData2() *MsgsStateInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsAllInfo <--
//  + TL_msgs_all_info
//
type MsgsAllInfo_Data struct {
	MsgIds []int64 `protobuf:"varint,1,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
	Info   string  `protobuf:"bytes,2,opt,name=info,proto3" json:"info,omitempty"`
}

func (m *MsgsAllInfo_Data) Reset()         { *m = MsgsAllInfo_Data{} }
func (m *MsgsAllInfo_Data) String() string { return proto.CompactTextString(m) }
func (*MsgsAllInfo_Data) ProtoMessage()    {}
func (*MsgsAllInfo_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{25}
}
func (m *MsgsAllInfo_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsAllInfo_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsAllInfo_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsAllInfo_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsAllInfo_Data.Merge(m, src)
}
func (m *MsgsAllInfo_Data) XXX_Size() int {
	return m.Size()
}
func (m *MsgsAllInfo_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsAllInfo_Data.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsAllInfo_Data proto.InternalMessageInfo

func (m *MsgsAllInfo_Data) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

func (m *MsgsAllInfo_Data) GetInfo() string {
	if m != nil {
		return m.Info
	}
	return ""
}

type MsgsAllInfo struct {
	Constructor TLConstructor     `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *MsgsAllInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *MsgsAllInfo) Reset()         { *m = MsgsAllInfo{} }
func (m *MsgsAllInfo) String() string { return proto.CompactTextString(m) }
func (*MsgsAllInfo) ProtoMessage()    {}
func (*MsgsAllInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{26}
}
func (m *MsgsAllInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsAllInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsAllInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsAllInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsAllInfo.Merge(m, src)
}
func (m *MsgsAllInfo) XXX_Size() int {
	return m.Size()
}
func (m *MsgsAllInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsAllInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsAllInfo proto.InternalMessageInfo

func (m *MsgsAllInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *MsgsAllInfo) GetData2() *MsgsAllInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msgs_all_info#8cc0d131 msg_ids:Vector<long> info:string = MsgsAllInfo;
type TLMsgsAllInfo struct {
	Data2 *MsgsAllInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgsAllInfo) Reset()         { *m = TLMsgsAllInfo{} }
func (m *TLMsgsAllInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgsAllInfo) ProtoMessage()    {}
func (*TLMsgsAllInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{27}
}
func (m *TLMsgsAllInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsAllInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsAllInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsAllInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsAllInfo.Merge(m, src)
}
func (m *TLMsgsAllInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsAllInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsAllInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsAllInfo proto.InternalMessageInfo

func (m *TLMsgsAllInfo) GetData2() *MsgsAllInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// RpcDropAnswer <--
//  + TL_rpc_answer_unknown
//  + TL_rpc_answer_dropped_running
//  + TL_rpc_answer_dropped
//
type RpcDropAnswer_Data struct {
	MsgId int64 `protobuf:"varint,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	SeqNo int32 `protobuf:"varint,2,opt,name=seq_no,json=seqNo,proto3" json:"seq_no,omitempty"`
	Bytes int32 `protobuf:"varint,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
}

func (m *RpcDropAnswer_Data) Reset()         { *m = RpcDropAnswer_Data{} }
func (m *RpcDropAnswer_Data) String() string { return proto.CompactTextString(m) }
func (*RpcDropAnswer_Data) ProtoMessage()    {}
func (*RpcDropAnswer_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{28}
}
func (m *RpcDropAnswer_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcDropAnswer_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcDropAnswer_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcDropAnswer_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcDropAnswer_Data.Merge(m, src)
}
func (m *RpcDropAnswer_Data) XXX_Size() int {
	return m.Size()
}
func (m *RpcDropAnswer_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcDropAnswer_Data.DiscardUnknown(m)
}

var xxx_messageInfo_RpcDropAnswer_Data proto.InternalMessageInfo

func (m *RpcDropAnswer_Data) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *RpcDropAnswer_Data) GetSeqNo() int32 {
	if m != nil {
		return m.SeqNo
	}
	return 0
}

func (m *RpcDropAnswer_Data) GetBytes() int32 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

type RpcDropAnswer struct {
	Constructor TLConstructor       `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *RpcDropAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *RpcDropAnswer) Reset()         { *m = RpcDropAnswer{} }
func (m *RpcDropAnswer) String() string { return proto.CompactTextString(m) }
func (*RpcDropAnswer) ProtoMessage()    {}
func (*RpcDropAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{29}
}
func (m *RpcDropAnswer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RpcDropAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RpcDropAnswer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RpcDropAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RpcDropAnswer.Merge(m, src)
}
func (m *RpcDropAnswer) XXX_Size() int {
	return m.Size()
}
func (m *RpcDropAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_RpcDropAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_RpcDropAnswer proto.InternalMessageInfo

func (m *RpcDropAnswer) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *RpcDropAnswer) GetData2() *RpcDropAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// rpc_answer_unknown#5e2ad36e = RpcDropAnswer;
type TLRpcAnswerUnknown struct {
	Data2 *RpcDropAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLRpcAnswerUnknown) Reset()         { *m = TLRpcAnswerUnknown{} }
func (m *TLRpcAnswerUnknown) String() string { return proto.CompactTextString(m) }
func (*TLRpcAnswerUnknown) ProtoMessage()    {}
func (*TLRpcAnswerUnknown) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{30}
}
func (m *TLRpcAnswerUnknown) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcAnswerUnknown) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcAnswerUnknown.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcAnswerUnknown) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcAnswerUnknown.Merge(m, src)
}
func (m *TLRpcAnswerUnknown) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcAnswerUnknown) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcAnswerUnknown.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcAnswerUnknown proto.InternalMessageInfo

func (m *TLRpcAnswerUnknown) GetData2() *RpcDropAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// rpc_answer_dropped_running#cd78e586 = RpcDropAnswer;
type TLRpcAnswerDroppedRunning struct {
	Data2 *RpcDropAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLRpcAnswerDroppedRunning) Reset()         { *m = TLRpcAnswerDroppedRunning{} }
func (m *TLRpcAnswerDroppedRunning) String() string { return proto.CompactTextString(m) }
func (*TLRpcAnswerDroppedRunning) ProtoMessage()    {}
func (*TLRpcAnswerDroppedRunning) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{31}
}
func (m *TLRpcAnswerDroppedRunning) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcAnswerDroppedRunning) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcAnswerDroppedRunning.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcAnswerDroppedRunning) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcAnswerDroppedRunning.Merge(m, src)
}
func (m *TLRpcAnswerDroppedRunning) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcAnswerDroppedRunning) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcAnswerDroppedRunning.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcAnswerDroppedRunning proto.InternalMessageInfo

func (m *TLRpcAnswerDroppedRunning) GetData2() *RpcDropAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// rpc_answer_dropped#a43ad8b7 msg_id:long seq_no:int bytes:int = RpcDropAnswer;
type TLRpcAnswerDropped struct {
	Data2 *RpcDropAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLRpcAnswerDropped) Reset()         { *m = TLRpcAnswerDropped{} }
func (m *TLRpcAnswerDropped) String() string { return proto.CompactTextString(m) }
func (*TLRpcAnswerDropped) ProtoMessage()    {}
func (*TLRpcAnswerDropped) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{32}
}
func (m *TLRpcAnswerDropped) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLRpcAnswerDropped) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLRpcAnswerDropped.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLRpcAnswerDropped) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLRpcAnswerDropped.Merge(m, src)
}
func (m *TLRpcAnswerDropped) XXX_Size() int {
	return m.Size()
}
func (m *TLRpcAnswerDropped) XXX_DiscardUnknown() {
	xxx_messageInfo_TLRpcAnswerDropped.DiscardUnknown(m)
}

var xxx_messageInfo_TLRpcAnswerDropped proto.InternalMessageInfo

func (m *TLRpcAnswerDropped) GetData2() *RpcDropAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// FutureSalt <--
//  + TL_future_salt
//
type FutureSalt_Data struct {
	ValidSince int32 `protobuf:"varint,1,opt,name=valid_since,json=validSince,proto3" json:"valid_since,omitempty"`
	ValidUntil int32 `protobuf:"varint,2,opt,name=valid_until,json=validUntil,proto3" json:"valid_until,omitempty"`
	Salt       int64 `protobuf:"varint,3,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *FutureSalt_Data) Reset()         { *m = FutureSalt_Data{} }
func (m *FutureSalt_Data) String() string { return proto.CompactTextString(m) }
func (*FutureSalt_Data) ProtoMessage()    {}
func (*FutureSalt_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{33}
}
func (m *FutureSalt_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FutureSalt_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FutureSalt_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FutureSalt_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureSalt_Data.Merge(m, src)
}
func (m *FutureSalt_Data) XXX_Size() int {
	return m.Size()
}
func (m *FutureSalt_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureSalt_Data.DiscardUnknown(m)
}

var xxx_messageInfo_FutureSalt_Data proto.InternalMessageInfo

func (m *FutureSalt_Data) GetValidSince() int32 {
	if m != nil {
		return m.ValidSince
	}
	return 0
}

func (m *FutureSalt_Data) GetValidUntil() int32 {
	if m != nil {
		return m.ValidUntil
	}
	return 0
}

func (m *FutureSalt_Data) GetSalt() int64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

type FutureSalt struct {
	Constructor TLConstructor    `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *FutureSalt_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *FutureSalt) Reset()         { *m = FutureSalt{} }
func (m *FutureSalt) String() string { return proto.CompactTextString(m) }
func (*FutureSalt) ProtoMessage()    {}
func (*FutureSalt) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{34}
}
func (m *FutureSalt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *FutureSalt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_FutureSalt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *FutureSalt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FutureSalt.Merge(m, src)
}
func (m *FutureSalt) XXX_Size() int {
	return m.Size()
}
func (m *FutureSalt) XXX_DiscardUnknown() {
	xxx_messageInfo_FutureSalt.DiscardUnknown(m)
}

var xxx_messageInfo_FutureSalt proto.InternalMessageInfo

func (m *FutureSalt) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *FutureSalt) GetData2() *FutureSalt_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// future_salt#0949d9dc valid_since:int valid_until:int salt:long = FutureSalt;
type TLFutureSalt struct {
	Data2 *FutureSalt_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLFutureSalt) Reset()         { *m = TLFutureSalt{} }
func (m *TLFutureSalt) String() string { return proto.CompactTextString(m) }
func (*TLFutureSalt) ProtoMessage()    {}
func (*TLFutureSalt) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{35}
}
func (m *TLFutureSalt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLFutureSalt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLFutureSalt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLFutureSalt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLFutureSalt.Merge(m, src)
}
func (m *TLFutureSalt) XXX_Size() int {
	return m.Size()
}
func (m *TLFutureSalt) XXX_DiscardUnknown() {
	xxx_messageInfo_TLFutureSalt.DiscardUnknown(m)
}

var xxx_messageInfo_TLFutureSalt proto.InternalMessageInfo

func (m *TLFutureSalt) GetData2() *FutureSalt_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// Pong <--
//  + TL_pong
//
type Pong_Data struct {
	MsgId  int64 `protobuf:"varint,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	PingId int64 `protobuf:"varint,2,opt,name=ping_id,json=pingId,proto3" json:"ping_id,omitempty"`
}

func (m *Pong_Data) Reset()         { *m = Pong_Data{} }
func (m *Pong_Data) String() string { return proto.CompactTextString(m) }
func (*Pong_Data) ProtoMessage()    {}
func (*Pong_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{36}
}
func (m *Pong_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pong_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pong_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pong_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong_Data.Merge(m, src)
}
func (m *Pong_Data) XXX_Size() int {
	return m.Size()
}
func (m *Pong_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Pong_Data proto.InternalMessageInfo

func (m *Pong_Data) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *Pong_Data) GetPingId() int64 {
	if m != nil {
		return m.PingId
	}
	return 0
}

type Pong struct {
	Constructor TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *Pong_Data    `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *Pong) Reset()         { *m = Pong{} }
func (m *Pong) String() string { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()    {}
func (*Pong) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{37}
}
func (m *Pong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong.Merge(m, src)
}
func (m *Pong) XXX_Size() int {
	return m.Size()
}
func (m *Pong) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong.DiscardUnknown(m)
}

var xxx_messageInfo_Pong proto.InternalMessageInfo

func (m *Pong) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *Pong) GetData2() *Pong_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// pong#347773c5 msg_id:long ping_id:long = Pong;
type TLPong struct {
	Data2 *Pong_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLPong) Reset()         { *m = TLPong{} }
func (m *TLPong) String() string { return proto.CompactTextString(m) }
func (*TLPong) ProtoMessage()    {}
func (*TLPong) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{38}
}
func (m *TLPong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPong.Merge(m, src)
}
func (m *TLPong) XXX_Size() int {
	return m.Size()
}
func (m *TLPong) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPong.DiscardUnknown(m)
}

var xxx_messageInfo_TLPong proto.InternalMessageInfo

func (m *TLPong) GetData2() *Pong_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// NewSession <--
//  + TL_new_session_created
//
type NewSession_Data struct {
	FirstMsgId int64 `protobuf:"varint,1,opt,name=first_msg_id,json=firstMsgId,proto3" json:"first_msg_id,omitempty"`
	UniqueId   int64 `protobuf:"varint,2,opt,name=unique_id,json=uniqueId,proto3" json:"unique_id,omitempty"`
	ServerSalt int64 `protobuf:"varint,3,opt,name=server_salt,json=serverSalt,proto3" json:"server_salt,omitempty"`
}

func (m *NewSession_Data) Reset()         { *m = NewSession_Data{} }
func (m *NewSession_Data) String() string { return proto.CompactTextString(m) }
func (*NewSession_Data) ProtoMessage()    {}
func (*NewSession_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{39}
}
func (m *NewSession_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewSession_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewSession_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewSession_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSession_Data.Merge(m, src)
}
func (m *NewSession_Data) XXX_Size() int {
	return m.Size()
}
func (m *NewSession_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSession_Data.DiscardUnknown(m)
}

var xxx_messageInfo_NewSession_Data proto.InternalMessageInfo

func (m *NewSession_Data) GetFirstMsgId() int64 {
	if m != nil {
		return m.FirstMsgId
	}
	return 0
}

func (m *NewSession_Data) GetUniqueId() int64 {
	if m != nil {
		return m.UniqueId
	}
	return 0
}

func (m *NewSession_Data) GetServerSalt() int64 {
	if m != nil {
		return m.ServerSalt
	}
	return 0
}

type NewSession struct {
	Constructor TLConstructor    `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *NewSession_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *NewSession) Reset()         { *m = NewSession{} }
func (m *NewSession) String() string { return proto.CompactTextString(m) }
func (*NewSession) ProtoMessage()    {}
func (*NewSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{40}
}
func (m *NewSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NewSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NewSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NewSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NewSession.Merge(m, src)
}
func (m *NewSession) XXX_Size() int {
	return m.Size()
}
func (m *NewSession) XXX_DiscardUnknown() {
	xxx_messageInfo_NewSession.DiscardUnknown(m)
}

var xxx_messageInfo_NewSession proto.InternalMessageInfo

func (m *NewSession) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *NewSession) GetData2() *NewSession_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// new_session_created#9ec20908 first_msg_id:long unique_id:long server_salt:long = NewSession;
type TLNewSessionCreated struct {
	Data2 *NewSession_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLNewSessionCreated) Reset()         { *m = TLNewSessionCreated{} }
func (m *TLNewSessionCreated) String() string { return proto.CompactTextString(m) }
func (*TLNewSessionCreated) ProtoMessage()    {}
func (*TLNewSessionCreated) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{41}
}
func (m *TLNewSessionCreated) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLNewSessionCreated) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLNewSessionCreated.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLNewSessionCreated) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLNewSessionCreated.Merge(m, src)
}
func (m *TLNewSessionCreated) XXX_Size() int {
	return m.Size()
}
func (m *TLNewSessionCreated) XXX_DiscardUnknown() {
	xxx_messageInfo_TLNewSessionCreated.DiscardUnknown(m)
}

var xxx_messageInfo_TLNewSessionCreated proto.InternalMessageInfo

func (m *TLNewSessionCreated) GetData2() *NewSession_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// HttpWait <--
//  + TL_http_wait
//
type HttpWait_Data struct {
	MaxDelay  int32 `protobuf:"varint,1,opt,name=max_delay,json=maxDelay,proto3" json:"max_delay,omitempty"`
	WaitAfter int32 `protobuf:"varint,2,opt,name=wait_after,json=waitAfter,proto3" json:"wait_after,omitempty"`
	MaxWait   int32 `protobuf:"varint,3,opt,name=max_wait,json=maxWait,proto3" json:"max_wait,omitempty"`
}

func (m *HttpWait_Data) Reset()         { *m = HttpWait_Data{} }
func (m *HttpWait_Data) String() string { return proto.CompactTextString(m) }
func (*HttpWait_Data) ProtoMessage()    {}
func (*HttpWait_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{42}
}
func (m *HttpWait_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpWait_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpWait_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpWait_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpWait_Data.Merge(m, src)
}
func (m *HttpWait_Data) XXX_Size() int {
	return m.Size()
}
func (m *HttpWait_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpWait_Data.DiscardUnknown(m)
}

var xxx_messageInfo_HttpWait_Data proto.InternalMessageInfo

func (m *HttpWait_Data) GetMaxDelay() int32 {
	if m != nil {
		return m.MaxDelay
	}
	return 0
}

func (m *HttpWait_Data) GetWaitAfter() int32 {
	if m != nil {
		return m.WaitAfter
	}
	return 0
}

func (m *HttpWait_Data) GetMaxWait() int32 {
	if m != nil {
		return m.MaxWait
	}
	return 0
}

type HttpWait struct {
	Constructor TLConstructor  `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *HttpWait_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *HttpWait) Reset()         { *m = HttpWait{} }
func (m *HttpWait) String() string { return proto.CompactTextString(m) }
func (*HttpWait) ProtoMessage()    {}
func (*HttpWait) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{43}
}
func (m *HttpWait) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HttpWait) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HttpWait.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HttpWait) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HttpWait.Merge(m, src)
}
func (m *HttpWait) XXX_Size() int {
	return m.Size()
}
func (m *HttpWait) XXX_DiscardUnknown() {
	xxx_messageInfo_HttpWait.DiscardUnknown(m)
}

var xxx_messageInfo_HttpWait proto.InternalMessageInfo

func (m *HttpWait) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *HttpWait) GetData2() *HttpWait_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// http_wait#9299359f max_delay:int wait_after:int max_wait:int = HttpWait;
type TLHttpWait struct {
	Data2 *HttpWait_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLHttpWait) Reset()         { *m = TLHttpWait{} }
func (m *TLHttpWait) String() string { return proto.CompactTextString(m) }
func (*TLHttpWait) ProtoMessage()    {}
func (*TLHttpWait) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{44}
}
func (m *TLHttpWait) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLHttpWait) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLHttpWait.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLHttpWait) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLHttpWait.Merge(m, src)
}
func (m *TLHttpWait) XXX_Size() int {
	return m.Size()
}
func (m *TLHttpWait) XXX_DiscardUnknown() {
	xxx_messageInfo_TLHttpWait.DiscardUnknown(m)
}

var xxx_messageInfo_TLHttpWait proto.InternalMessageInfo

func (m *TLHttpWait) GetData2() *HttpWait_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// BadMsgNotification <--
//  + TL_bad_msg_notification
//  + TL_bad_server_salt
//
type BadMsgNotification_Data struct {
	BadMsgId      int64 `protobuf:"varint,1,opt,name=bad_msg_id,json=badMsgId,proto3" json:"bad_msg_id,omitempty"`
	BadMsgSeqno   int32 `protobuf:"varint,2,opt,name=bad_msg_seqno,json=badMsgSeqno,proto3" json:"bad_msg_seqno,omitempty"`
	ErrorCode     int32 `protobuf:"varint,3,opt,name=error_code,json=errorCode,proto3" json:"error_code,omitempty"`
	NewServerSalt int64 `protobuf:"varint,4,opt,name=new_server_salt,json=newServerSalt,proto3" json:"new_server_salt,omitempty"`
}

func (m *BadMsgNotification_Data) Reset()         { *m = BadMsgNotification_Data{} }
func (m *BadMsgNotification_Data) String() string { return proto.CompactTextString(m) }
func (*BadMsgNotification_Data) ProtoMessage()    {}
func (*BadMsgNotification_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{45}
}
func (m *BadMsgNotification_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadMsgNotification_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadMsgNotification_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadMsgNotification_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadMsgNotification_Data.Merge(m, src)
}
func (m *BadMsgNotification_Data) XXX_Size() int {
	return m.Size()
}
func (m *BadMsgNotification_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_BadMsgNotification_Data.DiscardUnknown(m)
}

var xxx_messageInfo_BadMsgNotification_Data proto.InternalMessageInfo

func (m *BadMsgNotification_Data) GetBadMsgId() int64 {
	if m != nil {
		return m.BadMsgId
	}
	return 0
}

func (m *BadMsgNotification_Data) GetBadMsgSeqno() int32 {
	if m != nil {
		return m.BadMsgSeqno
	}
	return 0
}

func (m *BadMsgNotification_Data) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *BadMsgNotification_Data) GetNewServerSalt() int64 {
	if m != nil {
		return m.NewServerSalt
	}
	return 0
}

type BadMsgNotification struct {
	Constructor TLConstructor            `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *BadMsgNotification_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *BadMsgNotification) Reset()         { *m = BadMsgNotification{} }
func (m *BadMsgNotification) String() string { return proto.CompactTextString(m) }
func (*BadMsgNotification) ProtoMessage()    {}
func (*BadMsgNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{46}
}
func (m *BadMsgNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BadMsgNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BadMsgNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BadMsgNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BadMsgNotification.Merge(m, src)
}
func (m *BadMsgNotification) XXX_Size() int {
	return m.Size()
}
func (m *BadMsgNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_BadMsgNotification.DiscardUnknown(m)
}

var xxx_messageInfo_BadMsgNotification proto.InternalMessageInfo

func (m *BadMsgNotification) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *BadMsgNotification) GetData2() *BadMsgNotification_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// bad_msg_notification#a7eff811 bad_msg_id:long bad_msg_seqno:int error_code:int = BadMsgNotification;
type TLBadMsgNotification struct {
	Data2 *BadMsgNotification_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLBadMsgNotification) Reset()         { *m = TLBadMsgNotification{} }
func (m *TLBadMsgNotification) String() string { return proto.CompactTextString(m) }
func (*TLBadMsgNotification) ProtoMessage()    {}
func (*TLBadMsgNotification) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{47}
}
func (m *TLBadMsgNotification) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBadMsgNotification) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBadMsgNotification.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBadMsgNotification) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBadMsgNotification.Merge(m, src)
}
func (m *TLBadMsgNotification) XXX_Size() int {
	return m.Size()
}
func (m *TLBadMsgNotification) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBadMsgNotification.DiscardUnknown(m)
}

var xxx_messageInfo_TLBadMsgNotification proto.InternalMessageInfo

func (m *TLBadMsgNotification) GetData2() *BadMsgNotification_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// bad_server_salt#edab447b bad_msg_id:long bad_msg_seqno:int error_code:int new_server_salt:long = BadMsgNotification;
type TLBadServerSalt struct {
	Data2 *BadMsgNotification_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLBadServerSalt) Reset()         { *m = TLBadServerSalt{} }
func (m *TLBadServerSalt) String() string { return proto.CompactTextString(m) }
func (*TLBadServerSalt) ProtoMessage()    {}
func (*TLBadServerSalt) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{48}
}
func (m *TLBadServerSalt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBadServerSalt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBadServerSalt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBadServerSalt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBadServerSalt.Merge(m, src)
}
func (m *TLBadServerSalt) XXX_Size() int {
	return m.Size()
}
func (m *TLBadServerSalt) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBadServerSalt.DiscardUnknown(m)
}

var xxx_messageInfo_TLBadServerSalt proto.InternalMessageInfo

func (m *TLBadServerSalt) GetData2() *BadMsgNotification_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgsStateReq <--
//  + TL_msgs_state_req
//
type MsgsStateReq_Data struct {
	MsgIds []int64 `protobuf:"varint,1,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
}

func (m *MsgsStateReq_Data) Reset()         { *m = MsgsStateReq_Data{} }
func (m *MsgsStateReq_Data) String() string { return proto.CompactTextString(m) }
func (*MsgsStateReq_Data) ProtoMessage()    {}
func (*MsgsStateReq_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{49}
}
func (m *MsgsStateReq_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsStateReq_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsStateReq_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsStateReq_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsStateReq_Data.Merge(m, src)
}
func (m *MsgsStateReq_Data) XXX_Size() int {
	return m.Size()
}
func (m *MsgsStateReq_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsStateReq_Data.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsStateReq_Data proto.InternalMessageInfo

func (m *MsgsStateReq_Data) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

type MsgsStateReq struct {
	Constructor TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *MsgsStateReq_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *MsgsStateReq) Reset()         { *m = MsgsStateReq{} }
func (m *MsgsStateReq) String() string { return proto.CompactTextString(m) }
func (*MsgsStateReq) ProtoMessage()    {}
func (*MsgsStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{50}
}
func (m *MsgsStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgsStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgsStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgsStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgsStateReq.Merge(m, src)
}
func (m *MsgsStateReq) XXX_Size() int {
	return m.Size()
}
func (m *MsgsStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgsStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_MsgsStateReq proto.InternalMessageInfo

func (m *MsgsStateReq) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *MsgsStateReq) GetData2() *MsgsStateReq_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msgs_state_req#da69fb52 msg_ids:Vector<long> = MsgsStateReq;
type TLMsgsStateReq struct {
	Data2 *MsgsStateReq_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgsStateReq) Reset()         { *m = TLMsgsStateReq{} }
func (m *TLMsgsStateReq) String() string { return proto.CompactTextString(m) }
func (*TLMsgsStateReq) ProtoMessage()    {}
func (*TLMsgsStateReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{51}
}
func (m *TLMsgsStateReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgsStateReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgsStateReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgsStateReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgsStateReq.Merge(m, src)
}
func (m *TLMsgsStateReq) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgsStateReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgsStateReq.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgsStateReq proto.InternalMessageInfo

func (m *TLMsgsStateReq) GetData2() *MsgsStateReq_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgDetailedInfo <--
//  + TL_msg_detailed_info
//  + TL_msg_new_detailed_info
//
type MsgDetailedInfo_Data struct {
	MsgId       int64 `protobuf:"varint,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	AnswerMsgId int64 `protobuf:"varint,2,opt,name=answer_msg_id,json=answerMsgId,proto3" json:"answer_msg_id,omitempty"`
	Bytes       int32 `protobuf:"varint,3,opt,name=bytes,proto3" json:"bytes,omitempty"`
	Status      int32 `protobuf:"varint,4,opt,name=status,proto3" json:"status,omitempty"`
}

func (m *MsgDetailedInfo_Data) Reset()         { *m = MsgDetailedInfo_Data{} }
func (m *MsgDetailedInfo_Data) String() string { return proto.CompactTextString(m) }
func (*MsgDetailedInfo_Data) ProtoMessage()    {}
func (*MsgDetailedInfo_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{52}
}
func (m *MsgDetailedInfo_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetailedInfo_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetailedInfo_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetailedInfo_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetailedInfo_Data.Merge(m, src)
}
func (m *MsgDetailedInfo_Data) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetailedInfo_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetailedInfo_Data.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetailedInfo_Data proto.InternalMessageInfo

func (m *MsgDetailedInfo_Data) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *MsgDetailedInfo_Data) GetAnswerMsgId() int64 {
	if m != nil {
		return m.AnswerMsgId
	}
	return 0
}

func (m *MsgDetailedInfo_Data) GetBytes() int32 {
	if m != nil {
		return m.Bytes
	}
	return 0
}

func (m *MsgDetailedInfo_Data) GetStatus() int32 {
	if m != nil {
		return m.Status
	}
	return 0
}

type MsgDetailedInfo struct {
	Constructor TLConstructor         `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *MsgDetailedInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *MsgDetailedInfo) Reset()         { *m = MsgDetailedInfo{} }
func (m *MsgDetailedInfo) String() string { return proto.CompactTextString(m) }
func (*MsgDetailedInfo) ProtoMessage()    {}
func (*MsgDetailedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{53}
}
func (m *MsgDetailedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgDetailedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgDetailedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgDetailedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgDetailedInfo.Merge(m, src)
}
func (m *MsgDetailedInfo) XXX_Size() int {
	return m.Size()
}
func (m *MsgDetailedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgDetailedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_MsgDetailedInfo proto.InternalMessageInfo

func (m *MsgDetailedInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *MsgDetailedInfo) GetData2() *MsgDetailedInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msg_detailed_info#276d3ec6 msg_id:long answer_msg_id:long bytes:int status:int = MsgDetailedInfo;
type TLMsgDetailedInfo struct {
	Data2 *MsgDetailedInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgDetailedInfo) Reset()         { *m = TLMsgDetailedInfo{} }
func (m *TLMsgDetailedInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgDetailedInfo) ProtoMessage()    {}
func (*TLMsgDetailedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{54}
}
func (m *TLMsgDetailedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgDetailedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgDetailedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgDetailedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgDetailedInfo.Merge(m, src)
}
func (m *TLMsgDetailedInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgDetailedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgDetailedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgDetailedInfo proto.InternalMessageInfo

func (m *TLMsgDetailedInfo) GetData2() *MsgDetailedInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msg_new_detailed_info#809db6df answer_msg_id:long bytes:int status:int = MsgDetailedInfo;
type TLMsgNewDetailedInfo struct {
	Data2 *MsgDetailedInfo_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgNewDetailedInfo) Reset()         { *m = TLMsgNewDetailedInfo{} }
func (m *TLMsgNewDetailedInfo) String() string { return proto.CompactTextString(m) }
func (*TLMsgNewDetailedInfo) ProtoMessage()    {}
func (*TLMsgNewDetailedInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{55}
}
func (m *TLMsgNewDetailedInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgNewDetailedInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgNewDetailedInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgNewDetailedInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgNewDetailedInfo.Merge(m, src)
}
func (m *TLMsgNewDetailedInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgNewDetailedInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgNewDetailedInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgNewDetailedInfo proto.InternalMessageInfo

func (m *TLMsgNewDetailedInfo) GetData2() *MsgDetailedInfo_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// TlsClientHello <--
//  + TL_tlsClientHello
//
type TlsClientHello_Data struct {
	Blocks []*TlsBlock `protobuf:"bytes,1,rep,name=blocks,proto3" json:"blocks,omitempty"`
}

func (m *TlsClientHello_Data) Reset()         { *m = TlsClientHello_Data{} }
func (m *TlsClientHello_Data) String() string { return proto.CompactTextString(m) }
func (*TlsClientHello_Data) ProtoMessage()    {}
func (*TlsClientHello_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{56}
}
func (m *TlsClientHello_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsClientHello_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TlsClientHello_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TlsClientHello_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsClientHello_Data.Merge(m, src)
}
func (m *TlsClientHello_Data) XXX_Size() int {
	return m.Size()
}
func (m *TlsClientHello_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsClientHello_Data.DiscardUnknown(m)
}

var xxx_messageInfo_TlsClientHello_Data proto.InternalMessageInfo

func (m *TlsClientHello_Data) GetBlocks() []*TlsBlock {
	if m != nil {
		return m.Blocks
	}
	return nil
}

type TlsClientHello struct {
	Constructor TLConstructor        `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *TlsClientHello_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TlsClientHello) Reset()         { *m = TlsClientHello{} }
func (m *TlsClientHello) String() string { return proto.CompactTextString(m) }
func (*TlsClientHello) ProtoMessage()    {}
func (*TlsClientHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{57}
}
func (m *TlsClientHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TlsClientHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TlsClientHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TlsClientHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TlsClientHello.Merge(m, src)
}
func (m *TlsClientHello) XXX_Size() int {
	return m.Size()
}
func (m *TlsClientHello) XXX_DiscardUnknown() {
	xxx_messageInfo_TlsClientHello.DiscardUnknown(m)
}

var xxx_messageInfo_TlsClientHello proto.InternalMessageInfo

func (m *TlsClientHello) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *TlsClientHello) GetData2() *TlsClientHello_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// tlsClientHello#6c52c484 blocks:vector<TlsBlock> = TlsClientHello;
type TLTlsClientHello struct {
	Data2 *TlsClientHello_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLTlsClientHello) Reset()         { *m = TLTlsClientHello{} }
func (m *TLTlsClientHello) String() string { return proto.CompactTextString(m) }
func (*TLTlsClientHello) ProtoMessage()    {}
func (*TLTlsClientHello) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{58}
}
func (m *TLTlsClientHello) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLTlsClientHello) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLTlsClientHello.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLTlsClientHello) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLTlsClientHello.Merge(m, src)
}
func (m *TLTlsClientHello) XXX_Size() int {
	return m.Size()
}
func (m *TLTlsClientHello) XXX_DiscardUnknown() {
	xxx_messageInfo_TLTlsClientHello.DiscardUnknown(m)
}

var xxx_messageInfo_TLTlsClientHello proto.InternalMessageInfo

func (m *TLTlsClientHello) GetData2() *TlsClientHello_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// DestroySessionRes <--
//  + TL_destroy_session_ok
//  + TL_destroy_session_none
//
type DestroySessionRes_Data struct {
	SessionId int64 `protobuf:"varint,1,opt,name=session_id,json=sessionId,proto3" json:"session_id,omitempty"`
}

func (m *DestroySessionRes_Data) Reset()         { *m = DestroySessionRes_Data{} }
func (m *DestroySessionRes_Data) String() string { return proto.CompactTextString(m) }
func (*DestroySessionRes_Data) ProtoMessage()    {}
func (*DestroySessionRes_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{59}
}
func (m *DestroySessionRes_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestroySessionRes_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DestroySessionRes_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DestroySessionRes_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestroySessionRes_Data.Merge(m, src)
}
func (m *DestroySessionRes_Data) XXX_Size() int {
	return m.Size()
}
func (m *DestroySessionRes_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DestroySessionRes_Data.DiscardUnknown(m)
}

var xxx_messageInfo_DestroySessionRes_Data proto.InternalMessageInfo

func (m *DestroySessionRes_Data) GetSessionId() int64 {
	if m != nil {
		return m.SessionId
	}
	return 0
}

type DestroySessionRes struct {
	Constructor TLConstructor           `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *DestroySessionRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *DestroySessionRes) Reset()         { *m = DestroySessionRes{} }
func (m *DestroySessionRes) String() string { return proto.CompactTextString(m) }
func (*DestroySessionRes) ProtoMessage()    {}
func (*DestroySessionRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{60}
}
func (m *DestroySessionRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestroySessionRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DestroySessionRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DestroySessionRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestroySessionRes.Merge(m, src)
}
func (m *DestroySessionRes) XXX_Size() int {
	return m.Size()
}
func (m *DestroySessionRes) XXX_DiscardUnknown() {
	xxx_messageInfo_DestroySessionRes.DiscardUnknown(m)
}

var xxx_messageInfo_DestroySessionRes proto.InternalMessageInfo

func (m *DestroySessionRes) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *DestroySessionRes) GetData2() *DestroySessionRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// destroy_session_ok#e22045fc session_id:long = DestroySessionRes;
type TLDestroySessionOk struct {
	Data2 *DestroySessionRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDestroySessionOk) Reset()         { *m = TLDestroySessionOk{} }
func (m *TLDestroySessionOk) String() string { return proto.CompactTextString(m) }
func (*TLDestroySessionOk) ProtoMessage()    {}
func (*TLDestroySessionOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{61}
}
func (m *TLDestroySessionOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroySessionOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroySessionOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroySessionOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroySessionOk.Merge(m, src)
}
func (m *TLDestroySessionOk) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroySessionOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroySessionOk.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroySessionOk proto.InternalMessageInfo

func (m *TLDestroySessionOk) GetData2() *DestroySessionRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// destroy_session_none#62d350c9 session_id:long = DestroySessionRes;
type TLDestroySessionNone struct {
	Data2 *DestroySessionRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDestroySessionNone) Reset()         { *m = TLDestroySessionNone{} }
func (m *TLDestroySessionNone) String() string { return proto.CompactTextString(m) }
func (*TLDestroySessionNone) ProtoMessage()    {}
func (*TLDestroySessionNone) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{62}
}
func (m *TLDestroySessionNone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroySessionNone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroySessionNone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroySessionNone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroySessionNone.Merge(m, src)
}
func (m *TLDestroySessionNone) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroySessionNone) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroySessionNone.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroySessionNone proto.InternalMessageInfo

func (m *TLDestroySessionNone) GetData2() *DestroySessionRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// AccessPointRule <--
//  + TL_accessPointRule
//
type AccessPointRule_Data struct {
	PhonePrefixRules string    `protobuf:"bytes,1,opt,name=phone_prefix_rules,json=phonePrefixRules,proto3" json:"phone_prefix_rules,omitempty"`
	DcId             int32     `protobuf:"varint,2,opt,name=dc_id,json=dcId,proto3" json:"dc_id,omitempty"`
	Ips              []*IpPort `protobuf:"bytes,3,rep,name=ips,proto3" json:"ips,omitempty"`
}

func (m *AccessPointRule_Data) Reset()         { *m = AccessPointRule_Data{} }
func (m *AccessPointRule_Data) String() string { return proto.CompactTextString(m) }
func (*AccessPointRule_Data) ProtoMessage()    {}
func (*AccessPointRule_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{63}
}
func (m *AccessPointRule_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessPointRule_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessPointRule_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessPointRule_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessPointRule_Data.Merge(m, src)
}
func (m *AccessPointRule_Data) XXX_Size() int {
	return m.Size()
}
func (m *AccessPointRule_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessPointRule_Data.DiscardUnknown(m)
}

var xxx_messageInfo_AccessPointRule_Data proto.InternalMessageInfo

func (m *AccessPointRule_Data) GetPhonePrefixRules() string {
	if m != nil {
		return m.PhonePrefixRules
	}
	return ""
}

func (m *AccessPointRule_Data) GetDcId() int32 {
	if m != nil {
		return m.DcId
	}
	return 0
}

func (m *AccessPointRule_Data) GetIps() []*IpPort {
	if m != nil {
		return m.Ips
	}
	return nil
}

type AccessPointRule struct {
	Constructor TLConstructor         `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *AccessPointRule_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *AccessPointRule) Reset()         { *m = AccessPointRule{} }
func (m *AccessPointRule) String() string { return proto.CompactTextString(m) }
func (*AccessPointRule) ProtoMessage()    {}
func (*AccessPointRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{64}
}
func (m *AccessPointRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AccessPointRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AccessPointRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AccessPointRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AccessPointRule.Merge(m, src)
}
func (m *AccessPointRule) XXX_Size() int {
	return m.Size()
}
func (m *AccessPointRule) XXX_DiscardUnknown() {
	xxx_messageInfo_AccessPointRule.DiscardUnknown(m)
}

var xxx_messageInfo_AccessPointRule proto.InternalMessageInfo

func (m *AccessPointRule) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *AccessPointRule) GetData2() *AccessPointRule_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// accessPointRule#20634ce phone_prefix_rules:string dc_id:int ips:vector<IpPort> = AccessPointRule;
type TLAccessPointRule struct {
	Data2 *AccessPointRule_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLAccessPointRule) Reset()         { *m = TLAccessPointRule{} }
func (m *TLAccessPointRule) String() string { return proto.CompactTextString(m) }
func (*TLAccessPointRule) ProtoMessage()    {}
func (*TLAccessPointRule) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{65}
}
func (m *TLAccessPointRule) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAccessPointRule) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAccessPointRule.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAccessPointRule) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAccessPointRule.Merge(m, src)
}
func (m *TLAccessPointRule) XXX_Size() int {
	return m.Size()
}
func (m *TLAccessPointRule) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAccessPointRule.DiscardUnknown(m)
}

var xxx_messageInfo_TLAccessPointRule proto.InternalMessageInfo

func (m *TLAccessPointRule) GetData2() *AccessPointRule_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// MsgResendReq <--
//  + TL_msg_resend_req
//
type MsgResendReq_Data struct {
	MsgIds []int64 `protobuf:"varint,1,rep,packed,name=msg_ids,json=msgIds,proto3" json:"msg_ids,omitempty"`
}

func (m *MsgResendReq_Data) Reset()         { *m = MsgResendReq_Data{} }
func (m *MsgResendReq_Data) String() string { return proto.CompactTextString(m) }
func (*MsgResendReq_Data) ProtoMessage()    {}
func (*MsgResendReq_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{66}
}
func (m *MsgResendReq_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResendReq_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResendReq_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResendReq_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResendReq_Data.Merge(m, src)
}
func (m *MsgResendReq_Data) XXX_Size() int {
	return m.Size()
}
func (m *MsgResendReq_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResendReq_Data.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResendReq_Data proto.InternalMessageInfo

func (m *MsgResendReq_Data) GetMsgIds() []int64 {
	if m != nil {
		return m.MsgIds
	}
	return nil
}

type MsgResendReq struct {
	Constructor TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *MsgResendReq_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *MsgResendReq) Reset()         { *m = MsgResendReq{} }
func (m *MsgResendReq) String() string { return proto.CompactTextString(m) }
func (*MsgResendReq) ProtoMessage()    {}
func (*MsgResendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{67}
}
func (m *MsgResendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MsgResendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MsgResendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MsgResendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MsgResendReq.Merge(m, src)
}
func (m *MsgResendReq) XXX_Size() int {
	return m.Size()
}
func (m *MsgResendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_MsgResendReq.DiscardUnknown(m)
}

var xxx_messageInfo_MsgResendReq proto.InternalMessageInfo

func (m *MsgResendReq) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *MsgResendReq) GetData2() *MsgResendReq_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// msg_resend_req#7d861a08 msg_ids:Vector<long> = MsgResendReq;
type TLMsgResendReq struct {
	Data2 *MsgResendReq_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLMsgResendReq) Reset()         { *m = TLMsgResendReq{} }
func (m *TLMsgResendReq) String() string { return proto.CompactTextString(m) }
func (*TLMsgResendReq) ProtoMessage()    {}
func (*TLMsgResendReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{68}
}
func (m *TLMsgResendReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLMsgResendReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLMsgResendReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLMsgResendReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLMsgResendReq.Merge(m, src)
}
func (m *TLMsgResendReq) XXX_Size() int {
	return m.Size()
}
func (m *TLMsgResendReq) XXX_DiscardUnknown() {
	xxx_messageInfo_TLMsgResendReq.DiscardUnknown(m)
}

var xxx_messageInfo_TLMsgResendReq proto.InternalMessageInfo

func (m *TLMsgResendReq) GetData2() *MsgResendReq_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// IpPort <--
//  + TL_ipPort
//  + TL_ipPortSecret
//
type IpPort_Data struct {
	Ipv4   int32  `protobuf:"varint,1,opt,name=ipv4,proto3" json:"ipv4,omitempty"`
	Port   int32  `protobuf:"varint,2,opt,name=port,proto3" json:"port,omitempty"`
	Secret []byte `protobuf:"bytes,3,opt,name=secret,proto3" json:"secret,omitempty"`
}

func (m *IpPort_Data) Reset()         { *m = IpPort_Data{} }
func (m *IpPort_Data) String() string { return proto.CompactTextString(m) }
func (*IpPort_Data) ProtoMessage()    {}
func (*IpPort_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{69}
}
func (m *IpPort_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpPort_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpPort_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpPort_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPort_Data.Merge(m, src)
}
func (m *IpPort_Data) XXX_Size() int {
	return m.Size()
}
func (m *IpPort_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPort_Data.DiscardUnknown(m)
}

var xxx_messageInfo_IpPort_Data proto.InternalMessageInfo

func (m *IpPort_Data) GetIpv4() int32 {
	if m != nil {
		return m.Ipv4
	}
	return 0
}

func (m *IpPort_Data) GetPort() int32 {
	if m != nil {
		return m.Port
	}
	return 0
}

func (m *IpPort_Data) GetSecret() []byte {
	if m != nil {
		return m.Secret
	}
	return nil
}

type IpPort struct {
	Constructor TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *IpPort_Data  `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *IpPort) Reset()         { *m = IpPort{} }
func (m *IpPort) String() string { return proto.CompactTextString(m) }
func (*IpPort) ProtoMessage()    {}
func (*IpPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{70}
}
func (m *IpPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *IpPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_IpPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *IpPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_IpPort.Merge(m, src)
}
func (m *IpPort) XXX_Size() int {
	return m.Size()
}
func (m *IpPort) XXX_DiscardUnknown() {
	xxx_messageInfo_IpPort.DiscardUnknown(m)
}

var xxx_messageInfo_IpPort proto.InternalMessageInfo

func (m *IpPort) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *IpPort) GetData2() *IpPort_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// ipPort#d433ad73 ipv4:int port:int = IpPort;
type TLIpPort struct {
	Data2 *IpPort_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLIpPort) Reset()         { *m = TLIpPort{} }
func (m *TLIpPort) String() string { return proto.CompactTextString(m) }
func (*TLIpPort) ProtoMessage()    {}
func (*TLIpPort) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{71}
}
func (m *TLIpPort) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLIpPort) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLIpPort.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLIpPort) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLIpPort.Merge(m, src)
}
func (m *TLIpPort) XXX_Size() int {
	return m.Size()
}
func (m *TLIpPort) XXX_DiscardUnknown() {
	xxx_messageInfo_TLIpPort.DiscardUnknown(m)
}

var xxx_messageInfo_TLIpPort proto.InternalMessageInfo

func (m *TLIpPort) GetData2() *IpPort_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// ipPortSecret#402d9b47 ipv4:int port:int secret:bytes = IpPort;
type TLIpPortSecret struct {
	Data2 *IpPort_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLIpPortSecret) Reset()         { *m = TLIpPortSecret{} }
func (m *TLIpPortSecret) String() string { return proto.CompactTextString(m) }
func (*TLIpPortSecret) ProtoMessage()    {}
func (*TLIpPortSecret) Descriptor() ([]byte, []int) {
	return fileDescriptor_253819edc71e8ec7, []int{72}
}
func (m *TLIpPortSecret) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLIpPortSecret) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLIpPortSecret.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLIpPortSecret) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLIpPortSecret.Merge(m, src)
}
func (m *TLIpPortSecret) XXX_Size() int {
	return m.Size()
}
func (m *TLIpPortSecret) XXX_DiscardUnknown() {
	xxx_messageInfo_TLIpPortSecret.DiscardUnknown(m)
}

var xxx_messageInfo_TLIpPortSecret proto.InternalMessageInfo

func (m *TLIpPortSecret) GetData2() *IpPort_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

func init() {
	proto.RegisterType((*RpcError_Data)(nil), "mtproto.RpcError_Data")
	proto.RegisterType((*RpcError)(nil), "mtproto.RpcError")
	proto.RegisterType((*TLRpcError)(nil), "mtproto.TL_rpc_error")
	proto.RegisterType((*FutureSalts_Data)(nil), "mtproto.FutureSalts_Data")
	proto.RegisterType((*FutureSalts)(nil), "mtproto.FutureSalts")
	proto.RegisterType((*TLFutureSalts)(nil), "mtproto.TL_future_salts")
	proto.RegisterType((*Help_ConfigSimple_Data)(nil), "mtproto.help_ConfigSimple_Data")
	proto.RegisterType((*Help_ConfigSimple)(nil), "mtproto.help_ConfigSimple")
	proto.RegisterType((*TLHelpConfigSimple)(nil), "mtproto.TL_help_configSimple")
	proto.RegisterType((*TLHelpConfigSimple114)(nil), "mtproto.TL_help_configSimple114")
	proto.RegisterType((*TlsBlock_Data)(nil), "mtproto.TlsBlock_Data")
	proto.RegisterType((*TlsBlock)(nil), "mtproto.TlsBlock")
	proto.RegisterType((*TLTlsBlockString)(nil), "mtproto.TL_tlsBlockString")
	proto.RegisterType((*TLTlsBlockRandom)(nil), "mtproto.TL_tlsBlockRandom")
	proto.RegisterType((*TLTlsBlockZero)(nil), "mtproto.TL_tlsBlockZero")
	proto.RegisterType((*TLTlsBlockDomain)(nil), "mtproto.TL_tlsBlockDomain")
	proto.RegisterType((*TLTlsBlockGrease)(nil), "mtproto.TL_tlsBlockGrease")
	proto.RegisterType((*TLTlsBlockPublicKey)(nil), "mtproto.TL_tlsBlockPublicKey")
	proto.RegisterType((*TLTlsBlockScope)(nil), "mtproto.TL_tlsBlockScope")
	proto.RegisterType((*MsgsAck_Data)(nil), "mtproto.MsgsAck_Data")
	proto.RegisterType((*MsgsAck)(nil), "mtproto.MsgsAck")
	proto.RegisterType((*TLMsgsAck)(nil), "mtproto.TL_msgs_ack")
	proto.RegisterType((*MsgsStateInfo_Data)(nil), "mtproto.MsgsStateInfo_Data")
	proto.RegisterType((*MsgsStateInfo)(nil), "mtproto.MsgsStateInfo")
	proto.RegisterType((*TLMsgsStateInfo)(nil), "mtproto.TL_msgs_state_info")
	proto.RegisterType((*MsgsAllInfo_Data)(nil), "mtproto.MsgsAllInfo_Data")
	proto.RegisterType((*MsgsAllInfo)(nil), "mtproto.MsgsAllInfo")
	proto.RegisterType((*TLMsgsAllInfo)(nil), "mtproto.TL_msgs_all_info")
	proto.RegisterType((*RpcDropAnswer_Data)(nil), "mtproto.RpcDropAnswer_Data")
	proto.RegisterType((*RpcDropAnswer)(nil), "mtproto.RpcDropAnswer")
	proto.RegisterType((*TLRpcAnswerUnknown)(nil), "mtproto.TL_rpc_answer_unknown")
	proto.RegisterType((*TLRpcAnswerDroppedRunning)(nil), "mtproto.TL_rpc_answer_dropped_running")
	proto.RegisterType((*TLRpcAnswerDropped)(nil), "mtproto.TL_rpc_answer_dropped")
	proto.RegisterType((*FutureSalt_Data)(nil), "mtproto.FutureSalt_Data")
	proto.RegisterType((*FutureSalt)(nil), "mtproto.FutureSalt")
	proto.RegisterType((*TLFutureSalt)(nil), "mtproto.TL_future_salt")
	proto.RegisterType((*Pong_Data)(nil), "mtproto.Pong_Data")
	proto.RegisterType((*Pong)(nil), "mtproto.Pong")
	proto.RegisterType((*TLPong)(nil), "mtproto.TL_pong")
	proto.RegisterType((*NewSession_Data)(nil), "mtproto.NewSession_Data")
	proto.RegisterType((*NewSession)(nil), "mtproto.NewSession")
	proto.RegisterType((*TLNewSessionCreated)(nil), "mtproto.TL_new_session_created")
	proto.RegisterType((*HttpWait_Data)(nil), "mtproto.HttpWait_Data")
	proto.RegisterType((*HttpWait)(nil), "mtproto.HttpWait")
	proto.RegisterType((*TLHttpWait)(nil), "mtproto.TL_http_wait")
	proto.RegisterType((*BadMsgNotification_Data)(nil), "mtproto.BadMsgNotification_Data")
	proto.RegisterType((*BadMsgNotification)(nil), "mtproto.BadMsgNotification")
	proto.RegisterType((*TLBadMsgNotification)(nil), "mtproto.TL_bad_msg_notification")
	proto.RegisterType((*TLBadServerSalt)(nil), "mtproto.TL_bad_server_salt")
	proto.RegisterType((*MsgsStateReq_Data)(nil), "mtproto.MsgsStateReq_Data")
	proto.RegisterType((*MsgsStateReq)(nil), "mtproto.MsgsStateReq")
	proto.RegisterType((*TLMsgsStateReq)(nil), "mtproto.TL_msgs_state_req")
	proto.RegisterType((*MsgDetailedInfo_Data)(nil), "mtproto.MsgDetailedInfo_Data")
	proto.RegisterType((*MsgDetailedInfo)(nil), "mtproto.MsgDetailedInfo")
	proto.RegisterType((*TLMsgDetailedInfo)(nil), "mtproto.TL_msg_detailed_info")
	proto.RegisterType((*TLMsgNewDetailedInfo)(nil), "mtproto.TL_msg_new_detailed_info")
	proto.RegisterType((*TlsClientHello_Data)(nil), "mtproto.TlsClientHello_Data")
	proto.RegisterType((*TlsClientHello)(nil), "mtproto.TlsClientHello")
	proto.RegisterType((*TLTlsClientHello)(nil), "mtproto.TL_tlsClientHello")
	proto.RegisterType((*DestroySessionRes_Data)(nil), "mtproto.DestroySessionRes_Data")
	proto.RegisterType((*DestroySessionRes)(nil), "mtproto.DestroySessionRes")
	proto.RegisterType((*TLDestroySessionOk)(nil), "mtproto.TL_destroy_session_ok")
	proto.RegisterType((*TLDestroySessionNone)(nil), "mtproto.TL_destroy_session_none")
	proto.RegisterType((*AccessPointRule_Data)(nil), "mtproto.AccessPointRule_Data")
	proto.RegisterType((*AccessPointRule)(nil), "mtproto.AccessPointRule")
	proto.RegisterType((*TLAccessPointRule)(nil), "mtproto.TL_accessPointRule")
	proto.RegisterType((*MsgResendReq_Data)(nil), "mtproto.MsgResendReq_Data")
	proto.RegisterType((*MsgResendReq)(nil), "mtproto.MsgResendReq")
	proto.RegisterType((*TLMsgResendReq)(nil), "mtproto.TL_msg_resend_req")
	proto.RegisterType((*IpPort_Data)(nil), "mtproto.IpPort_Data")
	proto.RegisterType((*IpPort)(nil), "mtproto.IpPort")
	proto.RegisterType((*TLIpPort)(nil), "mtproto.TL_ipPort")
	proto.RegisterType((*TLIpPortSecret)(nil), "mtproto.TL_ipPortSecret")
}

func init() { proto.RegisterFile("schema.tl.transport.proto", fileDescriptor_253819edc71e8ec7) }

var fileDescriptor_253819edc71e8ec7 = []byte{
	// 1692 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x58, 0x4b, 0x73, 0x1b, 0x37,
	0x12, 0x36, 0x45, 0x51, 0x14, 0x9b, 0x92, 0x25, 0x8d, 0xf5, 0xa0, 0x5f, 0xb2, 0x96, 0x5b, 0xb5,
	0xab, 0x5d, 0x7b, 0xb5, 0x6b, 0xc9, 0xfb, 0xa8, 0x7d, 0x94, 0xad, 0x87, 0x6d, 0x71, 0x4d, 0x29,
	0xca, 0x90, 0xa9, 0xa4, 0x72, 0x99, 0x1a, 0xcd, 0x80, 0xd4, 0x44, 0x43, 0x60, 0x08, 0x80, 0x7a,
	0xa4, 0x5c, 0x49, 0x0e, 0xa9, 0x9c, 0xf3, 0x1b, 0xf2, 0x4f, 0x72, 0xcb, 0xd1, 0xc7, 0x1c, 0x53,
	0xf6, 0x1f, 0x49, 0xe1, 0x35, 0x9c, 0xa1, 0xe8, 0xd8, 0x24, 0xcd, 0x13, 0x07, 0x8d, 0xc6, 0x87,
	0xaf, 0x1b, 0x4d, 0x74, 0xa3, 0xe1, 0x26, 0xf3, 0x4e, 0x50, 0xcb, 0xdd, 0xe0, 0xe1, 0x06, 0xa7,
	0x2e, 0x66, 0x11, 0xa1, 0x7c, 0x23, 0xa2, 0x84, 0x13, 0x2b, 0xdf, 0xe2, 0xf2, 0xe3, 0xd6, 0x52,
	0x57, 0xc7, 0xa3, 0xde, 0xd6, 0xa6, 0x9a, 0x2f, 0xd7, 0x60, 0xd6, 0x8e, 0xbc, 0xa7, 0x94, 0x12,
	0xea, 0xec, 0xb9, 0xdc, 0xb5, 0xee, 0x02, 0x20, 0x39, 0xf2, 0x88, 0x8f, 0x4a, 0x99, 0xb5, 0xcc,
	0x7a, 0xce, 0x2e, 0x48, 0xc9, 0x2e, 0xf1, 0x91, 0xf5, 0x7b, 0x98, 0x55, 0xd3, 0x2d, 0xc4, 0x98,
	0xdb, 0x44, 0xa5, 0x89, 0xb5, 0xcc, 0x7a, 0xc1, 0x9e, 0x91, 0xc2, 0x03, 0x25, 0x2b, 0x53, 0x98,
	0x36, 0xa0, 0xd6, 0xbf, 0xa0, 0xe8, 0x11, 0xcc, 0x38, 0xed, 0x78, 0x9c, 0x50, 0x09, 0x78, 0x7d,
	0x73, 0x79, 0x43, 0xd3, 0xda, 0xa8, 0x57, 0x77, 0xbb, 0xb3, 0x76, 0x52, 0xd5, 0x7a, 0x00, 0x39,
	0xdf, 0xe5, 0xee, 0xa6, 0xdc, 0xa2, 0x98, 0x58, 0x93, 0x22, 0x6c, 0x2b, 0xa5, 0xf2, 0x7f, 0x61,
	0xa6, 0x5e, 0x75, 0x68, 0xe4, 0x39, 0x92, 0xca, 0x80, 0xab, 0xdb, 0x30, 0xff, 0xac, 0xc3, 0x3b,
	0x14, 0xd5, 0xdc, 0x90, 0x33, 0xe5, 0x89, 0x3b, 0x00, 0x14, 0xb5, 0x9d, 0x16, 0x6b, 0x3a, 0x81,
	0x2f, 0x89, 0x67, 0xed, 0x69, 0x8a, 0xda, 0x07, 0xac, 0x59, 0xf1, 0xad, 0x79, 0xc8, 0x62, 0x72,
	0x2e, 0xd1, 0x73, 0xb6, 0xf8, 0xb4, 0xfe, 0x02, 0x39, 0x26, 0x56, 0x97, 0xb2, 0x6b, 0xd9, 0xf5,
	0xe2, 0xe6, 0x4a, 0xc2, 0x46, 0xa7, 0x21, 0xc1, 0x1d, 0x31, 0x6f, 0x2b, 0xad, 0xf2, 0x05, 0x14,
	0x13, 0x5b, 0x8e, 0xe0, 0xa7, 0xbf, 0xa6, 0x2d, 0xbd, 0x19, 0xaf, 0xe9, 0xb5, 0xc8, 0x18, 0xbb,
	0x03, 0x73, 0x69, 0x4a, 0x6c, 0x70, 0x8c, 0x1f, 0x33, 0xb0, 0x7c, 0x82, 0xc2, 0xc8, 0xd9, 0x25,
	0xb8, 0x11, 0x34, 0x6b, 0x41, 0x2b, 0x0a, 0x91, 0xf2, 0x9b, 0x05, 0x93, 0xbe, 0xcb, 0x4d, 0xec,
	0xc8, 0x6f, 0xab, 0x04, 0x79, 0x74, 0x11, 0x05, 0x14, 0x31, 0xed, 0x31, 0x33, 0xb4, 0x6e, 0x40,
	0xce, 0xf7, 0x84, 0x83, 0xb3, 0x5a, 0xdd, 0xab, 0xf8, 0xd6, 0x23, 0x98, 0x09, 0x22, 0x47, 0x84,
	0xb1, 0x13, 0x06, 0x8c, 0x97, 0x26, 0xa5, 0x47, 0xad, 0xa4, 0x47, 0x83, 0xe8, 0x88, 0x50, 0x6e,
	0x83, 0xfa, 0xad, 0x06, 0x8c, 0x5b, 0x1b, 0x90, 0xa3, 0x9d, 0x10, 0xb1, 0x52, 0x4e, 0xaa, 0x97,
	0x62, 0xf5, 0x6d, 0xcf, 0x43, 0x8c, 0x1d, 0x91, 0x00, 0x73, 0xbb, 0x13, 0x22, 0x5b, 0xa9, 0x95,
	0xbf, 0xcd, 0xc0, 0xc2, 0x15, 0x1b, 0x46, 0x38, 0x88, 0xbf, 0xa7, 0x9d, 0x78, 0x2f, 0x5e, 0xd3,
	0xdf, 0x51, 0xc6, 0x95, 0x07, 0xb0, 0x58, 0xaf, 0x3a, 0x52, 0xc7, 0x4b, 0x12, 0x19, 0x12, 0xee,
	0x08, 0x56, 0xfa, 0xc1, 0x3d, 0x7c, 0xf8, 0x68, 0x58, 0xc4, 0x97, 0x30, 0x5b, 0x0f, 0xd9, 0x4e,
	0x48, 0xbc, 0xd3, 0xe4, 0x09, 0xbb, 0xd2, 0x37, 0x05, 0x79, 0xc2, 0xae, 0xb5, 0x0c, 0x53, 0x21,
	0xc2, 0x4d, 0x7e, 0xa2, 0x0f, 0x58, 0x8f, 0x84, 0x2e, 0x43, 0x28, 0x3e, 0x5e, 0xf1, 0x6d, 0xdd,
	0x87, 0x3c, 0xc2, 0x9c, 0x06, 0x88, 0xe9, 0x93, 0x5d, 0xe8, 0xba, 0x57, 0x6f, 0x64, 0x1b, 0x0d,
	0x71, 0x99, 0x18, 0xe1, 0x38, 0x2e, 0x93, 0x94, 0x65, 0xc6, 0xe2, 0x6d, 0x58, 0xa8, 0x57, 0x1d,
	0xae, 0xa7, 0x6a, 0x9c, 0x06, 0xb8, 0x39, 0x12, 0x84, 0xed, 0x62, 0x9f, 0xb4, 0x06, 0x84, 0x78,
	0x2c, 0xff, 0xa7, 0x06, 0xe2, 0x73, 0x44, 0xc9, 0x48, 0x1c, 0xf6, 0x48, 0xcb, 0x0d, 0xf0, 0x48,
	0x10, 0xcf, 0x29, 0x72, 0x19, 0x1a, 0x10, 0x62, 0x4f, 0xc6, 0xb7, 0x81, 0x38, 0xea, 0x1c, 0x87,
	0x81, 0xf7, 0x02, 0x5d, 0x0e, 0x88, 0xf2, 0x04, 0xe6, 0x93, 0x47, 0xe2, 0x91, 0x68, 0x50, 0x1e,
	0x7f, 0x84, 0x99, 0x03, 0xd6, 0x64, 0xdb, 0x26, 0x8a, 0x57, 0x20, 0xaf, 0xee, 0x76, 0x56, 0xca,
	0xac, 0x65, 0xd7, 0xb3, 0xf6, 0x54, 0x4b, 0xdc, 0xec, 0xac, 0x1c, 0x41, 0x5e, 0x2b, 0x8e, 0x10,
	0x70, 0xf7, 0xd3, 0xdc, 0x96, 0xe2, 0x35, 0x49, 0x0e, 0x86, 0xda, 0xbf, 0xa1, 0x58, 0xaf, 0x8a,
	0x4c, 0xc3, 0x1c, 0xd7, 0x3b, 0x1d, 0x6c, 0xed, 0x33, 0xb0, 0x84, 0xb8, 0xc6, 0x5d, 0x8e, 0x2a,
	0xb8, 0x41, 0xde, 0x27, 0x79, 0x59, 0x30, 0x19, 0xe0, 0x06, 0xd1, 0xc9, 0x5b, 0x7e, 0x8b, 0x7f,
	0x79, 0x0a, 0x67, 0x04, 0xdb, 0x1f, 0xa6, 0xf9, 0xdf, 0x4e, 0xf1, 0x4f, 0x13, 0x35, 0x56, 0x3c,
	0x07, 0xcb, 0x78, 0x80, 0x09, 0x05, 0x47, 0x70, 0x1a, 0x06, 0xe8, 0x31, 0xcc, 0x4b, 0x2f, 0x85,
	0x61, 0xd7, 0x19, 0x6f, 0x3b, 0xe9, 0xbe, 0x7e, 0xb8, 0x80, 0x62, 0x02, 0x60, 0x1c, 0x79, 0xb9,
	0x97, 0x9f, 0xa1, 0xbe, 0x2b, 0x43, 0x5c, 0x45, 0x41, 0x18, 0x2a, 0x0f, 0x0c, 0x0c, 0xf2, 0x19,
	0x58, 0x76, 0xe4, 0xed, 0x51, 0x12, 0x6d, 0x63, 0x76, 0x8e, 0x74, 0x55, 0xb7, 0x04, 0x53, 0xa9,
	0x50, 0xc8, 0x49, 0x07, 0x08, 0x31, 0x43, 0x6d, 0x07, 0x13, 0x7d, 0x69, 0xe7, 0x18, 0x6a, 0x1f,
	0x12, 0x6b, 0x11, 0x72, 0xc7, 0x97, 0x1c, 0x31, 0x7d, 0x69, 0xab, 0x81, 0x08, 0x90, 0x14, 0xf2,
	0x38, 0x02, 0xe4, 0x2a, 0x75, 0x63, 0xd7, 0xff, 0x61, 0x49, 0xd7, 0x77, 0xae, 0x9a, 0xec, 0xe0,
	0x53, 0x4c, 0xce, 0xf1, 0x30, 0x58, 0x36, 0xdc, 0x4d, 0x63, 0xf9, 0x94, 0x44, 0x11, 0xf2, 0x1d,
	0xda, 0xc1, 0x58, 0x5c, 0xf5, 0x1f, 0x82, 0x9f, 0xc6, 0x1c, 0x06, 0xab, 0x09, 0x73, 0xdd, 0xba,
	0x4b, 0x1d, 0xe0, 0x3d, 0x28, 0x9e, 0xb9, 0x61, 0xe0, 0x3b, 0x2c, 0xc0, 0x9e, 0xa9, 0xad, 0x40,
	0x8a, 0x6a, 0x42, 0xd2, 0x55, 0xe8, 0x60, 0x1e, 0x84, 0xfa, 0x3c, 0x95, 0xc2, 0x27, 0x42, 0x22,
	0x13, 0xb1, 0x1b, 0x72, 0x79, 0xa6, 0x59, 0x5b, 0x7e, 0x97, 0xcf, 0x00, 0xba, 0x1b, 0x8d, 0x70,
	0x9e, 0x1b, 0x69, 0x1b, 0x4b, 0x7d, 0xca, 0xc7, 0x9e, 0xcb, 0xfc, 0x7a, 0xba, 0x02, 0x1d, 0x18,
	0xe1, 0x3f, 0x50, 0x38, 0x22, 0xb8, 0xf9, 0x9b, 0xd1, 0xbd, 0x02, 0xf9, 0x28, 0xc0, 0x52, 0x3e,
	0x21, 0xe5, 0x53, 0x62, 0x58, 0xf1, 0xcb, 0x5f, 0xc0, 0xa4, 0x58, 0x3c, 0x82, 0xc1, 0xeb, 0x69,
	0xba, 0xdd, 0xca, 0x34, 0x26, 0x65, 0x88, 0x6e, 0x41, 0xbe, 0x5e, 0x75, 0x22, 0xb1, 0xdd, 0xfb,
	0x2f, 0x6a, 0xc3, 0xdc, 0x21, 0x3a, 0xaf, 0x21, 0xc6, 0x02, 0x82, 0x95, 0x8d, 0x6b, 0x30, 0xd3,
	0x08, 0x28, 0xe3, 0xe9, 0x2b, 0x1d, 0xa4, 0x4c, 0x5d, 0xea, 0xb7, 0xa1, 0xd0, 0xc1, 0x41, 0xbb,
	0x83, 0xba, 0x06, 0x4f, 0x2b, 0x41, 0xc5, 0x17, 0xe1, 0xc1, 0x10, 0x3d, 0x43, 0xd4, 0x49, 0x04,
	0x01, 0x28, 0x51, 0x4d, 0x87, 0x42, 0x77, 0xcb, 0x71, 0x84, 0x42, 0x8f, 0x41, 0xc6, 0xd4, 0x7d,
	0x58, 0xae, 0x57, 0x1d, 0x8c, 0xce, 0x1d, 0xa6, 0x67, 0x3d, 0x8a, 0x5c, 0x8e, 0xfc, 0x81, 0x91,
	0x1a, 0x30, 0xbb, 0xcf, 0x79, 0xf4, 0xa9, 0x1b, 0xe8, 0xff, 0xcc, 0x6d, 0x28, 0xb4, 0xdc, 0x0b,
	0xc7, 0x47, 0xa1, 0x7b, 0xa9, 0xff, 0x31, 0xd3, 0x2d, 0xf7, 0x62, 0x4f, 0x8c, 0xc5, 0x3b, 0xf7,
	0x5c, 0x68, 0xba, 0x0d, 0x8e, 0xa8, 0xfe, 0xbb, 0x14, 0x84, 0x64, 0x5b, 0x08, 0xac, 0x9b, 0x20,
	0x54, 0x1d, 0x21, 0xd0, 0xb7, 0x60, 0xbe, 0xe5, 0x5e, 0x08, 0x6c, 0x51, 0x90, 0x9a, 0x7d, 0xc6,
	0x51, 0x90, 0xa6, 0x6c, 0x48, 0xbf, 0x6e, 0x4f, 0x38, 0x8f, 0x24, 0xa5, 0x01, 0x57, 0xff, 0x90,
	0x81, 0x95, 0x1d, 0xd7, 0x3f, 0x60, 0xcd, 0x43, 0xc2, 0x83, 0x46, 0xe0, 0xb9, 0x3c, 0x8e, 0xab,
	0x3b, 0x00, 0xc7, 0xae, 0xdf, 0x53, 0x28, 0x1c, 0x4b, 0xe5, 0x8a, 0x6f, 0x95, 0x61, 0xd6, 0xcc,
	0x32, 0xd4, 0x8e, 0xf3, 0x44, 0x51, 0x29, 0xd4, 0x84, 0xa8, 0xa7, 0x63, 0x90, 0xed, 0xed, 0x18,
	0xfc, 0x01, 0xe6, 0xd4, 0xe9, 0x76, 0xa3, 0x6f, 0x52, 0xee, 0x32, 0x8b, 0xc5, 0x39, 0xc6, 0x01,
	0xf8, 0x5d, 0x06, 0xac, 0xab, 0x24, 0x47, 0xf0, 0xf0, 0x3f, 0xd2, 0x3e, 0x5a, 0x8b, 0xd7, 0xbc,
	0xc5, 0x15, 0xc6, 0x5b, 0x1f, 0xcb, 0x07, 0x94, 0x31, 0x1b, 0x27, 0xc9, 0x0c, 0x0b, 0x59, 0x95,
	0xd5, 0x8d, 0x80, 0x4c, 0xb8, 0x61, 0x68, 0xb4, 0x07, 0xb0, 0x10, 0xd7, 0x3f, 0x36, 0x6a, 0xbf,
	0xa3, 0x9a, 0xfd, 0x52, 0x95, 0xbd, 0x46, 0x7b, 0x04, 0x87, 0xfe, 0x2d, 0xcd, 0xf7, 0xd6, 0xd5,
	0x6a, 0xcc, 0xb0, 0x31, 0x4c, 0x9f, 0xca, 0xd7, 0x43, 0xa2, 0xaa, 0xa3, 0xa8, 0x3d, 0x04, 0xcc,
	0xd7, 0xb0, 0x78, 0xc0, 0x9a, 0x7b, 0x88, 0xbb, 0x41, 0x88, 0xfc, 0x6e, 0x5d, 0xf7, 0x96, 0x7b,
	0xbf, 0x0c, 0xb3, 0x3a, 0x07, 0xeb, 0x59, 0x75, 0x19, 0x16, 0x95, 0x50, 0x05, 0x76, 0xdf, 0x12,
	0x47, 0x3c, 0x62, 0x05, 0xcf, 0x0e, 0x93, 0x21, 0x9a, 0xb3, 0xf5, 0xa8, 0xfc, 0x4d, 0x06, 0xe6,
	0x7a, 0x18, 0x8c, 0xe0, 0xc7, 0xad, 0xb4, 0x03, 0xee, 0x26, 0x1d, 0x70, 0xc5, 0x48, 0xe3, 0x83,
	0x17, 0xf2, 0x15, 0x25, 0x0c, 0xf2, 0xb5, 0x8a, 0x2a, 0x10, 0x87, 0x02, 0xfb, 0x08, 0x4a, 0x1a,
	0x4c, 0xfc, 0x35, 0x3f, 0x00, 0xe0, 0x13, 0xb8, 0x51, 0x0f, 0xd9, 0x6e, 0x18, 0x20, 0xcc, 0xf7,
	0x51, 0x18, 0xea, 0x03, 0xfa, 0x13, 0x4c, 0x1d, 0x8b, 0x77, 0x98, 0x8a, 0xc9, 0xbe, 0xef, 0x7c,
	0xad, 0x50, 0xfe, 0x0a, 0xae, 0xa7, 0x11, 0x46, 0x70, 0xf0, 0x66, 0xda, 0x84, 0x3b, 0xc9, 0x5d,
	0x7b, 0x39, 0x76, 0x1f, 0x20, 0xfa, 0xa1, 0x9b, 0xa4, 0x30, 0x0c, 0xd0, 0x3f, 0x61, 0x79, 0x0f,
	0x31, 0x4e, 0xc9, 0xa5, 0x4e, 0x52, 0x36, 0x62, 0x71, 0x6b, 0xd5, 0xe4, 0xb8, 0x38, 0x64, 0x0b,
	0x5a, 0x52, 0xf1, 0x65, 0x3b, 0xea, 0xca, 0xca, 0x71, 0xb4, 0xa3, 0xfa, 0xd3, 0x33, 0xfc, 0x0f,
	0x65, 0x21, 0xeb, 0x2b, 0x9d, 0x38, 0x29, 0x93, 0xd3, 0x61, 0xf1, 0x54, 0x3f, 0xaa, 0x17, 0x0f,
	0x13, 0x8c, 0x86, 0x45, 0x7c, 0x09, 0x8b, 0x3d, 0x1d, 0x3d, 0xe5, 0xdf, 0x07, 0x60, 0x45, 0x27,
	0x04, 0x23, 0x27, 0xa2, 0xa8, 0x11, 0x5c, 0x38, 0xaa, 0x19, 0xa8, 0x9a, 0x54, 0xf3, 0x72, 0xe6,
	0x48, 0x4e, 0x88, 0x15, 0x89, 0xc6, 0xe3, 0x44, 0xa2, 0xf1, 0xf8, 0x3b, 0xc8, 0x06, 0x91, 0xe9,
	0xe0, 0xce, 0xc5, 0x7c, 0x2a, 0xaa, 0xd9, 0x28, 0xe6, 0xe4, 0x5d, 0xd0, 0xb3, 0xfd, 0x38, 0xee,
	0x82, 0x7e, 0x16, 0x1a, 0x07, 0x54, 0x64, 0x3a, 0x71, 0x7b, 0x48, 0x0c, 0x05, 0xa5, 0x72, 0x89,
	0x8d, 0x18, 0xc2, 0xfe, 0xfb, 0xe6, 0x92, 0x58, 0x7b, 0x4c, 0xb9, 0x24, 0xcd, 0xe6, 0x4a, 0x2e,
	0x71, 0xa8, 0x9c, 0x7f, 0x67, 0x2e, 0xe9, 0x0f, 0x73, 0x00, 0x45, 0x75, 0x9a, 0x71, 0x2b, 0x33,
	0x88, 0xce, 0x1e, 0x99, 0x66, 0xb5, 0xf8, 0x16, 0xb2, 0x88, 0x50, 0x6e, 0x02, 0x43, 0x7c, 0xcb,
	0xcc, 0x80, 0x3c, 0x8a, 0x54, 0x35, 0x38, 0x63, 0xeb, 0x51, 0x19, 0xc3, 0x94, 0x82, 0x1b, 0xc1,
	0x17, 0x7f, 0x4e, 0x1b, 0xb1, 0xd8, 0x13, 0x76, 0x3d, 0xb7, 0x4b, 0x21, 0x6e, 0x7e, 0x0f, 0xb4,
	0xf0, 0x7f, 0xb2, 0x99, 0xa8, 0x16, 0xd6, 0x24, 0xf7, 0x41, 0x96, 0xef, 0xdc, 0xfa, 0xe9, 0xf5,
	0x6a, 0xe6, 0xd5, 0xeb, 0xd5, 0xcc, 0x2f, 0xaf, 0x57, 0x33, 0xdf, 0xbf, 0x59, 0xbd, 0xf6, 0xea,
	0xcd, 0xea, 0xb5, 0x9f, 0xdf, 0xac, 0x5e, 0xdb, 0x9f, 0x38, 0x9e, 0x92, 0xab, 0xb6, 0x7e, 0x0d,
	0x00, 0x00, 0xff, 0xff, 0xea, 0x42, 0x43, 0x6f, 0x87, 0x1a, 0x00, 0x00,
}

func (m *RpcError_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcError_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcError_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ErrorMessage) > 0 {
		i -= len(m.ErrorMessage)
		copy(dAtA[i:], m.ErrorMessage)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.ErrorMessage)))
		i--
		dAtA[i] = 0x12
	}
	if m.ErrorCode != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RpcError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcError) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcError) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcError) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FutureSalts_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FutureSalts_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FutureSalts_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Salts) > 0 {
		for iNdEx := len(m.Salts) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Salts[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.Now != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Now))
		i--
		dAtA[i] = 0x10
	}
	if m.ReqMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ReqMsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FutureSalts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FutureSalts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLFutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLFutureSalts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLFutureSalts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Help_ConfigSimple_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Help_ConfigSimple_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Help_ConfigSimple_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rules) > 0 {
		for iNdEx := len(m.Rules) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rules[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x2a
		}
	}
	if len(m.IpPortList) > 0 {
		for iNdEx := len(m.IpPortList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.IpPortList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.DcId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x18
	}
	if m.Expires != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Expires))
		i--
		dAtA[i] = 0x10
	}
	if m.Date != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Help_ConfigSimple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Help_ConfigSimple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Help_ConfigSimple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLHelpConfigSimple) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLHelpConfigSimple) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLHelpConfigSimple) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLHelpConfigSimple114) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLHelpConfigSimple114) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLHelpConfigSimple114) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TlsBlock_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsBlock_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsBlock_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for iNdEx := len(m.Entries) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Entries[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Seed != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Seed))
		i--
		dAtA[i] = 0x18
	}
	if m.Length != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Length))
		i--
		dAtA[i] = 0x10
	}
	if len(m.Data) > 0 {
		i -= len(m.Data)
		copy(dAtA[i:], m.Data)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Data)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TlsBlock) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsBlock) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsBlock) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockString) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockString) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockString) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockRandom) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockRandom) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockRandom) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockZero) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockZero) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockZero) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockDomain) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockDomain) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockDomain) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockGrease) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockGrease) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockGrease) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockPublicKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockPublicKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockPublicKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsBlockScope) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsBlockScope) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsBlockScope) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MsgsAck_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAck_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsAck_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		dAtA17 := make([]byte, len(m.MsgIds)*10)
		var j16 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsAck) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsAck) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsAck) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MsgsStateInfo_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsStateInfo_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsStateInfo_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x12
	}
	if m.ReqMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ReqMsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgsStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsStateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsStateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsStateInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsStateInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsStateInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MsgsAllInfo_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAllInfo_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsAllInfo_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Info) > 0 {
		i -= len(m.Info)
		copy(dAtA[i:], m.Info)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Info)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.MsgIds) > 0 {
		dAtA23 := make([]byte, len(m.MsgIds)*10)
		var j22 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA23[j22] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j22++
			}
			dAtA23[j22] = uint8(num)
			j22++
		}
		i -= j22
		copy(dAtA[i:], dAtA23[:j22])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j22))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsAllInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsAllInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsAllInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsAllInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsAllInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsAllInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *RpcDropAnswer_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcDropAnswer_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcDropAnswer_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Bytes != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x18
	}
	if m.SeqNo != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.SeqNo))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *RpcDropAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RpcDropAnswer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *RpcDropAnswer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcAnswerUnknown) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcAnswerUnknown) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcAnswerUnknown) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcAnswerDroppedRunning) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcAnswerDroppedRunning) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcAnswerDroppedRunning) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLRpcAnswerDropped) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLRpcAnswerDropped) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLRpcAnswerDropped) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *FutureSalt_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FutureSalt_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FutureSalt_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Salt != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x18
	}
	if m.ValidUntil != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ValidUntil))
		i--
		dAtA[i] = 0x10
	}
	if m.ValidSince != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ValidSince))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *FutureSalt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *FutureSalt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *FutureSalt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLFutureSalt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLFutureSalt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLFutureSalt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Pong_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pong_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PingId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.PingId))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Pong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Pong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLPong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPong) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPong) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *NewSession_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewSession_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewSession_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerSalt != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ServerSalt))
		i--
		dAtA[i] = 0x18
	}
	if m.UniqueId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.UniqueId))
		i--
		dAtA[i] = 0x10
	}
	if m.FirstMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.FirstMsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *NewSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NewSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *NewSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLNewSessionCreated) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLNewSessionCreated) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLNewSessionCreated) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *HttpWait_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpWait_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpWait_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxWait != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MaxWait))
		i--
		dAtA[i] = 0x18
	}
	if m.WaitAfter != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.WaitAfter))
		i--
		dAtA[i] = 0x10
	}
	if m.MaxDelay != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MaxDelay))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *HttpWait) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HttpWait) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HttpWait) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLHttpWait) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLHttpWait) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLHttpWait) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *BadMsgNotification_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadMsgNotification_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadMsgNotification_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.NewServerSalt != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.NewServerSalt))
		i--
		dAtA[i] = 0x20
	}
	if m.ErrorCode != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.ErrorCode))
		i--
		dAtA[i] = 0x18
	}
	if m.BadMsgSeqno != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.BadMsgSeqno))
		i--
		dAtA[i] = 0x10
	}
	if m.BadMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.BadMsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BadMsgNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BadMsgNotification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BadMsgNotification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLBadMsgNotification) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBadMsgNotification) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBadMsgNotification) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLBadServerSalt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBadServerSalt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBadServerSalt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MsgsStateReq_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsStateReq_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsStateReq_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		dAtA42 := make([]byte, len(m.MsgIds)*10)
		var j41 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA42[j41] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j41++
			}
			dAtA42[j41] = uint8(num)
			j41++
		}
		i -= j41
		copy(dAtA[i:], dAtA42[:j41])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j41))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgsStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgsStateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgsStateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgsStateReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgsStateReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgsStateReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MsgDetailedInfo_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetailedInfo_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetailedInfo_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Status != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Status))
		i--
		dAtA[i] = 0x20
	}
	if m.Bytes != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Bytes))
		i--
		dAtA[i] = 0x18
	}
	if m.AnswerMsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.AnswerMsgId))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MsgDetailedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgDetailedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgDetailedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgDetailedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgDetailedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgDetailedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgNewDetailedInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgNewDetailedInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgNewDetailedInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TlsClientHello_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsClientHello_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsClientHello_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for iNdEx := len(m.Blocks) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Blocks[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *TlsClientHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TlsClientHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TlsClientHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLTlsClientHello) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLTlsClientHello) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLTlsClientHello) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DestroySessionRes_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroySessionRes_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestroySessionRes_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.SessionId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.SessionId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DestroySessionRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroySessionRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestroySessionRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroySessionOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroySessionOk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroySessionOk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroySessionNone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroySessionNone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroySessionNone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *AccessPointRule_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessPointRule_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessPointRule_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Ips) > 0 {
		for iNdEx := len(m.Ips) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Ips[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x1a
		}
	}
	if m.DcId != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.DcId))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PhonePrefixRules) > 0 {
		i -= len(m.PhonePrefixRules)
		copy(dAtA[i:], m.PhonePrefixRules)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.PhonePrefixRules)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AccessPointRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AccessPointRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AccessPointRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAccessPointRule) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAccessPointRule) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAccessPointRule) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *MsgResendReq_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResendReq_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResendReq_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		dAtA56 := make([]byte, len(m.MsgIds)*10)
		var j55 int
		for _, num1 := range m.MsgIds {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA56[j55] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j55++
			}
			dAtA56[j55] = uint8(num)
			j55++
		}
		i -= j55
		copy(dAtA[i:], dAtA56[:j55])
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(j55))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MsgResendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MsgResendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MsgResendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLMsgResendReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLMsgResendReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLMsgResendReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *IpPort_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpPort_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpPort_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Secret) > 0 {
		i -= len(m.Secret)
		copy(dAtA[i:], m.Secret)
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(len(m.Secret)))
		i--
		dAtA[i] = 0x1a
	}
	if m.Port != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Port))
		i--
		dAtA[i] = 0x10
	}
	if m.Ipv4 != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Ipv4))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *IpPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *IpPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *IpPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlTransport(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLIpPort) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLIpPort) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLIpPort) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLIpPortSecret) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLIpPortSecret) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLIpPortSecret) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlTransport(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchemaTlTransport(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchemaTlTransport(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *RpcError_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ErrorCode != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ErrorCode))
	}
	l = len(m.ErrorMessage)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *RpcError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLRpcError) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *FutureSalts_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ReqMsgId))
	}
	if m.Now != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Now))
	}
	if len(m.Salts) > 0 {
		for _, e := range m.Salts {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	return n
}

func (m *FutureSalts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLFutureSalts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *Help_ConfigSimple_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Date != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Date))
	}
	if m.Expires != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Expires))
	}
	if m.DcId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.DcId))
	}
	if len(m.IpPortList) > 0 {
		for _, e := range m.IpPortList {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	if len(m.Rules) > 0 {
		for _, e := range m.Rules {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	return n
}

func (m *Help_ConfigSimple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLHelpConfigSimple) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLHelpConfigSimple114) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TlsBlock_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Data)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.Length != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Length))
	}
	if m.Seed != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Seed))
	}
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	return n
}

func (m *TlsBlock) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockString) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockRandom) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockZero) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockDomain) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockGrease) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockPublicKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsBlockScope) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgsAck_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	return n
}

func (m *MsgsAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgsAck) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgsStateInfo_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ReqMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ReqMsgId))
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgsStateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgsStateInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgsAllInfo_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	l = len(m.Info)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgsAllInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgsAllInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *RpcDropAnswer_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MsgId))
	}
	if m.SeqNo != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.SeqNo))
	}
	if m.Bytes != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Bytes))
	}
	return n
}

func (m *RpcDropAnswer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLRpcAnswerUnknown) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLRpcAnswerDroppedRunning) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLRpcAnswerDropped) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *FutureSalt_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ValidSince != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ValidSince))
	}
	if m.ValidUntil != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ValidUntil))
	}
	if m.Salt != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Salt))
	}
	return n
}

func (m *FutureSalt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLFutureSalt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *Pong_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MsgId))
	}
	if m.PingId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.PingId))
	}
	return n
}

func (m *Pong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLPong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *NewSession_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.FirstMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.FirstMsgId))
	}
	if m.UniqueId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.UniqueId))
	}
	if m.ServerSalt != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ServerSalt))
	}
	return n
}

func (m *NewSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLNewSessionCreated) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *HttpWait_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MaxDelay != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MaxDelay))
	}
	if m.WaitAfter != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.WaitAfter))
	}
	if m.MaxWait != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MaxWait))
	}
	return n
}

func (m *HttpWait) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLHttpWait) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *BadMsgNotification_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.BadMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.BadMsgId))
	}
	if m.BadMsgSeqno != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.BadMsgSeqno))
	}
	if m.ErrorCode != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.ErrorCode))
	}
	if m.NewServerSalt != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.NewServerSalt))
	}
	return n
}

func (m *BadMsgNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLBadMsgNotification) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLBadServerSalt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgsStateReq_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	return n
}

func (m *MsgsStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgsStateReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgDetailedInfo_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.MsgId))
	}
	if m.AnswerMsgId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.AnswerMsgId))
	}
	if m.Bytes != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Bytes))
	}
	if m.Status != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Status))
	}
	return n
}

func (m *MsgDetailedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgDetailedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgNewDetailedInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TlsClientHello_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Blocks) > 0 {
		for _, e := range m.Blocks {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	return n
}

func (m *TlsClientHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLTlsClientHello) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *DestroySessionRes_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.SessionId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.SessionId))
	}
	return n
}

func (m *DestroySessionRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLDestroySessionOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLDestroySessionNone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *AccessPointRule_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PhonePrefixRules)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	if m.DcId != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.DcId))
	}
	if len(m.Ips) > 0 {
		for _, e := range m.Ips {
			l = e.Size()
			n += 1 + l + sovSchemaTlTransport(uint64(l))
		}
	}
	return n
}

func (m *AccessPointRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLAccessPointRule) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *MsgResendReq_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.MsgIds) > 0 {
		l = 0
		for _, e := range m.MsgIds {
			l += sovSchemaTlTransport(uint64(e))
		}
		n += 1 + sovSchemaTlTransport(uint64(l)) + l
	}
	return n
}

func (m *MsgResendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLMsgResendReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *IpPort_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ipv4 != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Ipv4))
	}
	if m.Port != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Port))
	}
	l = len(m.Secret)
	if l > 0 {
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *IpPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlTransport(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLIpPort) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func (m *TLIpPortSecret) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlTransport(uint64(l))
	}
	return n
}

func sovSchemaTlTransport(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchemaTlTransport(x uint64) (n int) {
	return sovSchemaTlTransport(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *RpcError_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcError_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcError_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ErrorMessage = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcError: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcError: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcError_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcError) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_error: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_error: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcError_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FutureSalts_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FutureSalts_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FutureSalts_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMsgId", wireType)
			}
			m.ReqMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Now", wireType)
			}
			m.Now = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Now |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Salts = append(m.Salts, &TLFutureSalt{})
			if err := m.Salts[len(m.Salts)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FutureSalts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FutureSalts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &FutureSalts_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLFutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_future_salts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_future_salts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &FutureSalts_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Help_ConfigSimple_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_ConfigSimple_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_ConfigSimple_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Expires", wireType)
			}
			m.Expires = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Expires |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IpPortList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IpPortList = append(m.IpPortList, &TLIpPort{})
			if err := m.IpPortList[len(m.IpPortList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rules", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rules = append(m.Rules, &AccessPointRule{})
			if err := m.Rules[len(m.Rules)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Help_ConfigSimple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: help_ConfigSimple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: help_ConfigSimple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Help_ConfigSimple_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLHelpConfigSimple) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_help_configSimple: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_help_configSimple: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Help_ConfigSimple_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLHelpConfigSimple114) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_help_configSimple114: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_help_configSimple114: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Help_ConfigSimple_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsBlock_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsBlock_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsBlock_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Length", wireType)
			}
			m.Length = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Length |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &TlsBlock{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsBlock) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsBlock: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsBlock: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockString) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockString: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockString: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockRandom) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockRandom: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockRandom: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockZero) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockZero: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockZero: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockDomain) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockDomain: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockDomain: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockGrease) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockGrease: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockGrease: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockPublicKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockPublicKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockPublicKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsBlockScope) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsBlockScope: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsBlockScope: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsBlock_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAck_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAck_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAck_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAck: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAck: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsAck_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsAck) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_ack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_ack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsAck_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsStateInfo_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsStateInfo_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsStateInfo_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReqMsgId", wireType)
			}
			m.ReqMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReqMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsStateInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsStateInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsStateInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsStateInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_state_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_state_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsStateInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAllInfo_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAllInfo_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAllInfo_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Info = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsAllInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsAllInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsAllInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsAllInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsAllInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_all_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_all_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsAllInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcDropAnswer_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcDropAnswer_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcDropAnswer_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeqNo", wireType)
			}
			m.SeqNo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeqNo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RpcDropAnswer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RpcDropAnswer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RpcDropAnswer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcAnswerUnknown) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_answer_unknown: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_answer_unknown: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcAnswerDroppedRunning) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped_running: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped_running: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLRpcAnswerDropped) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_rpc_answer_dropped: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &RpcDropAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FutureSalt_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FutureSalt_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FutureSalt_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidSince", wireType)
			}
			m.ValidSince = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidSince |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ValidUntil", wireType)
			}
			m.ValidUntil = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ValidUntil |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FutureSalt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FutureSalt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FutureSalt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &FutureSalt_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLFutureSalt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_future_salt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_future_salt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &FutureSalt_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PingId", wireType)
			}
			m.PingId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PingId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Pong_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Pong_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewSession_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewSession_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewSession_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FirstMsgId", wireType)
			}
			m.FirstMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FirstMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UniqueId", wireType)
			}
			m.UniqueId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UniqueId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerSalt", wireType)
			}
			m.ServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerSalt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NewSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NewSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NewSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &NewSession_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLNewSessionCreated) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_new_session_created: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_new_session_created: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &NewSession_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpWait_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpWait_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpWait_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxDelay", wireType)
			}
			m.MaxDelay = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxDelay |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field WaitAfter", wireType)
			}
			m.WaitAfter = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.WaitAfter |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxWait", wireType)
			}
			m.MaxWait = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxWait |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *HttpWait) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HttpWait: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HttpWait: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &HttpWait_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLHttpWait) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_http_wait: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_http_wait: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &HttpWait_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadMsgNotification_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadMsgNotification_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadMsgNotification_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadMsgId", wireType)
			}
			m.BadMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BadMsgSeqno", wireType)
			}
			m.BadMsgSeqno = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BadMsgSeqno |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			m.ErrorCode = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ErrorCode |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewServerSalt", wireType)
			}
			m.NewServerSalt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NewServerSalt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BadMsgNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BadMsgNotification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BadMsgNotification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BadMsgNotification_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBadMsgNotification) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_bad_msg_notification: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_bad_msg_notification: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BadMsgNotification_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBadServerSalt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_bad_server_salt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_bad_server_salt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BadMsgNotification_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsStateReq_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsStateReq_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsStateReq_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgsStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgsStateReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgsStateReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsStateReq_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgsStateReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msgs_state_req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msgs_state_req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgsStateReq_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetailedInfo_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetailedInfo_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetailedInfo_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnswerMsgId", wireType)
			}
			m.AnswerMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AnswerMsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bytes", wireType)
			}
			m.Bytes = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Bytes |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Status", wireType)
			}
			m.Status = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Status |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgDetailedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgDetailedInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgDetailedInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgDetailedInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgDetailedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msg_detailed_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msg_detailed_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgDetailedInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgNewDetailedInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msg_new_detailed_info: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msg_new_detailed_info: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgDetailedInfo_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsClientHello_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsClientHello_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsClientHello_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Blocks", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Blocks = append(m.Blocks, &TlsBlock{})
			if err := m.Blocks[len(m.Blocks)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TlsClientHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TlsClientHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TlsClientHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsClientHello_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLTlsClientHello) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_tlsClientHello: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_tlsClientHello: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &TlsClientHello_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroySessionRes_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroySessionRes_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroySessionRes_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionId", wireType)
			}
			m.SessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroySessionRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroySessionRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroySessionRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroySessionRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroySessionOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_session_ok: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_session_ok: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroySessionRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroySessionNone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_session_none: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_session_none: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroySessionRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessPointRule_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessPointRule_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessPointRule_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhonePrefixRules", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PhonePrefixRules = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DcId", wireType)
			}
			m.DcId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DcId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ips", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ips = append(m.Ips, &IpPort{})
			if err := m.Ips[len(m.Ips)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AccessPointRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AccessPointRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AccessPointRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &AccessPointRule_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAccessPointRule) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_accessPointRule: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_accessPointRule: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &AccessPointRule_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResendReq_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResendReq_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResendReq_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.MsgIds = append(m.MsgIds, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlTransport
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlTransport
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.MsgIds) == 0 {
					m.MsgIds = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlTransport
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.MsgIds = append(m.MsgIds, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgIds", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MsgResendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MsgResendReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MsgResendReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgResendReq_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLMsgResendReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_msg_resend_req: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_msg_resend_req: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &MsgResendReq_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpPort_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpPort_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpPort_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ipv4", wireType)
			}
			m.Ipv4 = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Ipv4 |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Port", wireType)
			}
			m.Port = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Port |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Secret = append(m.Secret[:0], dAtA[iNdEx:postIndex]...)
			if m.Secret == nil {
				m.Secret = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *IpPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: IpPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: IpPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &IpPort_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLIpPort) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_ipPort: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_ipPort: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &IpPort_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLIpPortSecret) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_ipPortSecret: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_ipPortSecret: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &IpPort_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlTransport(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlTransport
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchemaTlTransport(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchemaTlTransport
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaTlTransport
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchemaTlTransport
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchemaTlTransport
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchemaTlTransport
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchemaTlTransport        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchemaTlTransport          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchemaTlTransport = fmt.Errorf("proto: unexpected end of group")
)
