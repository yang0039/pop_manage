// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cfs_service.proto

package mtproto

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type UploadPhotoFileRequest struct {
	UserId int32      `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	PType  int32      `protobuf:"varint,2,opt,name=p_type,json=pType,proto3" json:"p_type,omitempty"`
	AuthId int64      `protobuf:"varint,3,opt,name=authId,proto3" json:"authId,omitempty"`
	File   *InputFile `protobuf:"bytes,4,opt,name=file,proto3" json:"file,omitempty"`
	Layer  int32      `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *UploadPhotoFileRequest) Reset()         { *m = UploadPhotoFileRequest{} }
func (m *UploadPhotoFileRequest) String() string { return proto.CompactTextString(m) }
func (*UploadPhotoFileRequest) ProtoMessage()    {}
func (*UploadPhotoFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{0}
}
func (m *UploadPhotoFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UploadPhotoFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UploadPhotoFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UploadPhotoFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadPhotoFileRequest.Merge(m, src)
}
func (m *UploadPhotoFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *UploadPhotoFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadPhotoFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadPhotoFileRequest proto.InternalMessageInfo

func (m *UploadPhotoFileRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UploadPhotoFileRequest) GetPType() int32 {
	if m != nil {
		return m.PType
	}
	return 0
}

func (m *UploadPhotoFileRequest) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *UploadPhotoFileRequest) GetFile() *InputFile {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *UploadPhotoFileRequest) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type GetPhotoFileDataRequest struct {
	PhotoId    int64 `protobuf:"varint,1,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
	AccessHash int64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Layer      int32 `protobuf:"varint,3,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *GetPhotoFileDataRequest) Reset()         { *m = GetPhotoFileDataRequest{} }
func (m *GetPhotoFileDataRequest) String() string { return proto.CompactTextString(m) }
func (*GetPhotoFileDataRequest) ProtoMessage()    {}
func (*GetPhotoFileDataRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{1}
}
func (m *GetPhotoFileDataRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *GetPhotoFileDataRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_GetPhotoFileDataRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *GetPhotoFileDataRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GetPhotoFileDataRequest.Merge(m, src)
}
func (m *GetPhotoFileDataRequest) XXX_Size() int {
	return m.Size()
}
func (m *GetPhotoFileDataRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_GetPhotoFileDataRequest.DiscardUnknown(m)
}

var xxx_messageInfo_GetPhotoFileDataRequest proto.InternalMessageInfo

func (m *GetPhotoFileDataRequest) GetPhotoId() int64 {
	if m != nil {
		return m.PhotoId
	}
	return 0
}

func (m *GetPhotoFileDataRequest) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *GetPhotoFileDataRequest) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type PhotoDataRsp struct {
	PhotoId    int64        `protobuf:"varint,1,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
	AccessHash int64        `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Date       int32        `protobuf:"varint,3,opt,name=date,proto3" json:"date,omitempty"`
	SizeList   []*PhotoSize `protobuf:"bytes,4,rep,name=size_list,json=sizeList,proto3" json:"size_list,omitempty"`
}

func (m *PhotoDataRsp) Reset()         { *m = PhotoDataRsp{} }
func (m *PhotoDataRsp) String() string { return proto.CompactTextString(m) }
func (*PhotoDataRsp) ProtoMessage()    {}
func (*PhotoDataRsp) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{2}
}
func (m *PhotoDataRsp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhotoDataRsp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhotoDataRsp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhotoDataRsp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoDataRsp.Merge(m, src)
}
func (m *PhotoDataRsp) XXX_Size() int {
	return m.Size()
}
func (m *PhotoDataRsp) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoDataRsp.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoDataRsp proto.InternalMessageInfo

func (m *PhotoDataRsp) GetPhotoId() int64 {
	if m != nil {
		return m.PhotoId
	}
	return 0
}

func (m *PhotoDataRsp) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *PhotoDataRsp) GetDate() int32 {
	if m != nil {
		return m.Date
	}
	return 0
}

func (m *PhotoDataRsp) GetSizeList() []*PhotoSize {
	if m != nil {
		return m.SizeList
	}
	return nil
}

type CfsUploadedPhotoMedia struct {
	UserId int32                      `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	PType  int32                      `protobuf:"varint,2,opt,name=p_type,json=pType,proto3" json:"p_type,omitempty"`
	AuthId int64                      `protobuf:"varint,3,opt,name=authId,proto3" json:"authId,omitempty"`
	Media  *TLInputMediaUploadedPhoto `protobuf:"bytes,4,opt,name=media,proto3" json:"media,omitempty"`
	Layer  int32                      `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *CfsUploadedPhotoMedia) Reset()         { *m = CfsUploadedPhotoMedia{} }
func (m *CfsUploadedPhotoMedia) String() string { return proto.CompactTextString(m) }
func (*CfsUploadedPhotoMedia) ProtoMessage()    {}
func (*CfsUploadedPhotoMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{3}
}
func (m *CfsUploadedPhotoMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CfsUploadedPhotoMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CfsUploadedPhotoMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CfsUploadedPhotoMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CfsUploadedPhotoMedia.Merge(m, src)
}
func (m *CfsUploadedPhotoMedia) XXX_Size() int {
	return m.Size()
}
func (m *CfsUploadedPhotoMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_CfsUploadedPhotoMedia.DiscardUnknown(m)
}

var xxx_messageInfo_CfsUploadedPhotoMedia proto.InternalMessageInfo

func (m *CfsUploadedPhotoMedia) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CfsUploadedPhotoMedia) GetPType() int32 {
	if m != nil {
		return m.PType
	}
	return 0
}

func (m *CfsUploadedPhotoMedia) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *CfsUploadedPhotoMedia) GetMedia() *TLInputMediaUploadedPhoto {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *CfsUploadedPhotoMedia) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type CfsUploadedDocumentMedia struct {
	UserId int32                         `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	AuthId int64                         `protobuf:"varint,2,opt,name=authId,proto3" json:"authId,omitempty"`
	Media  *TLInputMediaUploadedDocument `protobuf:"bytes,3,opt,name=media,proto3" json:"media,omitempty"`
	Layer  int32                         `protobuf:"varint,4,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *CfsUploadedDocumentMedia) Reset()         { *m = CfsUploadedDocumentMedia{} }
func (m *CfsUploadedDocumentMedia) String() string { return proto.CompactTextString(m) }
func (*CfsUploadedDocumentMedia) ProtoMessage()    {}
func (*CfsUploadedDocumentMedia) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{4}
}
func (m *CfsUploadedDocumentMedia) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *CfsUploadedDocumentMedia) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_CfsUploadedDocumentMedia.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *CfsUploadedDocumentMedia) XXX_Merge(src proto.Message) {
	xxx_messageInfo_CfsUploadedDocumentMedia.Merge(m, src)
}
func (m *CfsUploadedDocumentMedia) XXX_Size() int {
	return m.Size()
}
func (m *CfsUploadedDocumentMedia) XXX_DiscardUnknown() {
	xxx_messageInfo_CfsUploadedDocumentMedia.DiscardUnknown(m)
}

var xxx_messageInfo_CfsUploadedDocumentMedia proto.InternalMessageInfo

func (m *CfsUploadedDocumentMedia) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *CfsUploadedDocumentMedia) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *CfsUploadedDocumentMedia) GetMedia() *TLInputMediaUploadedDocument {
	if m != nil {
		return m.Media
	}
	return nil
}

func (m *CfsUploadedDocumentMedia) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type DocumentId struct {
	Id         int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash int64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Version    int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	Layer      int32 `protobuf:"varint,4,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *DocumentId) Reset()         { *m = DocumentId{} }
func (m *DocumentId) String() string { return proto.CompactTextString(m) }
func (*DocumentId) ProtoMessage()    {}
func (*DocumentId) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{5}
}
func (m *DocumentId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentId.Merge(m, src)
}
func (m *DocumentId) XXX_Size() int {
	return m.Size()
}
func (m *DocumentId) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentId.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentId proto.InternalMessageInfo

func (m *DocumentId) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *DocumentId) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *DocumentId) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DocumentId) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type DocumentAttributeList struct {
	Attributes []*DocumentAttribute `protobuf:"bytes,1,rep,name=attributes,proto3" json:"attributes,omitempty"`
}

func (m *DocumentAttributeList) Reset()         { *m = DocumentAttributeList{} }
func (m *DocumentAttributeList) String() string { return proto.CompactTextString(m) }
func (*DocumentAttributeList) ProtoMessage()    {}
func (*DocumentAttributeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{6}
}
func (m *DocumentAttributeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentAttributeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentAttributeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentAttributeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentAttributeList.Merge(m, src)
}
func (m *DocumentAttributeList) XXX_Size() int {
	return m.Size()
}
func (m *DocumentAttributeList) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentAttributeList.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentAttributeList proto.InternalMessageInfo

func (m *DocumentAttributeList) GetAttributes() []*DocumentAttribute {
	if m != nil {
		return m.Attributes
	}
	return nil
}

type DocumentIdList struct {
	IdList []int64 `protobuf:"varint,1,rep,packed,name=id_list,json=idList,proto3" json:"id_list,omitempty"`
	Layer  int32   `protobuf:"varint,2,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *DocumentIdList) Reset()         { *m = DocumentIdList{} }
func (m *DocumentIdList) String() string { return proto.CompactTextString(m) }
func (*DocumentIdList) ProtoMessage()    {}
func (*DocumentIdList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{7}
}
func (m *DocumentIdList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentIdList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentIdList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentIdList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentIdList.Merge(m, src)
}
func (m *DocumentIdList) XXX_Size() int {
	return m.Size()
}
func (m *DocumentIdList) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentIdList.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentIdList proto.InternalMessageInfo

func (m *DocumentIdList) GetIdList() []int64 {
	if m != nil {
		return m.IdList
	}
	return nil
}

func (m *DocumentIdList) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

type DocumentList struct {
	Documents []*Document `protobuf:"bytes,1,rep,name=documents,proto3" json:"documents,omitempty"`
}

func (m *DocumentList) Reset()         { *m = DocumentList{} }
func (m *DocumentList) String() string { return proto.CompactTextString(m) }
func (*DocumentList) ProtoMessage()    {}
func (*DocumentList) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{8}
}
func (m *DocumentList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentList.Merge(m, src)
}
func (m *DocumentList) XXX_Size() int {
	return m.Size()
}
func (m *DocumentList) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentList.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentList proto.InternalMessageInfo

func (m *DocumentList) GetDocuments() []*Document {
	if m != nil {
		return m.Documents
	}
	return nil
}

type MergeEncryptedFileRequest struct {
	UserId         int32 `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	AuthId         int64 `protobuf:"varint,2,opt,name=authId,proto3" json:"authId,omitempty"`
	PartId         int64 `protobuf:"varint,3,opt,name=part_id,json=partId,proto3" json:"part_id,omitempty"`
	Parts          int32 `protobuf:"varint,4,opt,name=parts,proto3" json:"parts,omitempty"`
	KeyFingerprint int32 `protobuf:"varint,5,opt,name=key_fingerprint,json=keyFingerprint,proto3" json:"key_fingerprint,omitempty"`
}

func (m *MergeEncryptedFileRequest) Reset()         { *m = MergeEncryptedFileRequest{} }
func (m *MergeEncryptedFileRequest) String() string { return proto.CompactTextString(m) }
func (*MergeEncryptedFileRequest) ProtoMessage()    {}
func (*MergeEncryptedFileRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{9}
}
func (m *MergeEncryptedFileRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MergeEncryptedFileRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MergeEncryptedFileRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MergeEncryptedFileRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MergeEncryptedFileRequest.Merge(m, src)
}
func (m *MergeEncryptedFileRequest) XXX_Size() int {
	return m.Size()
}
func (m *MergeEncryptedFileRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_MergeEncryptedFileRequest.DiscardUnknown(m)
}

var xxx_messageInfo_MergeEncryptedFileRequest proto.InternalMessageInfo

func (m *MergeEncryptedFileRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *MergeEncryptedFileRequest) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *MergeEncryptedFileRequest) GetPartId() int64 {
	if m != nil {
		return m.PartId
	}
	return 0
}

func (m *MergeEncryptedFileRequest) GetParts() int32 {
	if m != nil {
		return m.Parts
	}
	return 0
}

func (m *MergeEncryptedFileRequest) GetKeyFingerprint() int32 {
	if m != nil {
		return m.KeyFingerprint
	}
	return 0
}

type PhotoVideo struct {
	UserId       int32   `protobuf:"varint,1,opt,name=userId,proto3" json:"userId,omitempty"`
	AuthId       int64   `protobuf:"varint,2,opt,name=authId,proto3" json:"authId,omitempty"`
	FilePartId   int64   `protobuf:"varint,3,opt,name=file_part_id,json=filePartId,proto3" json:"file_part_id,omitempty"`
	Md5Checksum  string  `protobuf:"bytes,4,opt,name=md5_checksum,json=md5Checksum,proto3" json:"md5_checksum,omitempty"`
	VideoName    string  `protobuf:"bytes,5,opt,name=video_name,json=videoName,proto3" json:"video_name,omitempty"`
	Parts        int32   `protobuf:"varint,6,opt,name=parts,proto3" json:"parts,omitempty"`
	VideoStartTs float64 `protobuf:"fixed64,7,opt,name=video_start_ts,json=videoStartTs,proto3" json:"video_start_ts,omitempty"`
	Layer        int32   `protobuf:"varint,8,opt,name=layer,proto3" json:"layer,omitempty"`
}

func (m *PhotoVideo) Reset()         { *m = PhotoVideo{} }
func (m *PhotoVideo) String() string { return proto.CompactTextString(m) }
func (*PhotoVideo) ProtoMessage()    {}
func (*PhotoVideo) Descriptor() ([]byte, []int) {
	return fileDescriptor_e40e39152a1a5819, []int{10}
}
func (m *PhotoVideo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhotoVideo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhotoVideo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhotoVideo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoVideo.Merge(m, src)
}
func (m *PhotoVideo) XXX_Size() int {
	return m.Size()
}
func (m *PhotoVideo) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoVideo.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoVideo proto.InternalMessageInfo

func (m *PhotoVideo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *PhotoVideo) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *PhotoVideo) GetFilePartId() int64 {
	if m != nil {
		return m.FilePartId
	}
	return 0
}

func (m *PhotoVideo) GetMd5Checksum() string {
	if m != nil {
		return m.Md5Checksum
	}
	return ""
}

func (m *PhotoVideo) GetVideoName() string {
	if m != nil {
		return m.VideoName
	}
	return ""
}

func (m *PhotoVideo) GetParts() int32 {
	if m != nil {
		return m.Parts
	}
	return 0
}

func (m *PhotoVideo) GetVideoStartTs() float64 {
	if m != nil {
		return m.VideoStartTs
	}
	return 0
}

func (m *PhotoVideo) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func init() {
	proto.RegisterType((*UploadPhotoFileRequest)(nil), "mtproto.UploadPhotoFileRequest")
	proto.RegisterType((*GetPhotoFileDataRequest)(nil), "mtproto.GetPhotoFileDataRequest")
	proto.RegisterType((*PhotoDataRsp)(nil), "mtproto.PhotoDataRsp")
	proto.RegisterType((*CfsUploadedPhotoMedia)(nil), "mtproto.CfsUploadedPhotoMedia")
	proto.RegisterType((*CfsUploadedDocumentMedia)(nil), "mtproto.CfsUploadedDocumentMedia")
	proto.RegisterType((*DocumentId)(nil), "mtproto.DocumentId")
	proto.RegisterType((*DocumentAttributeList)(nil), "mtproto.DocumentAttributeList")
	proto.RegisterType((*DocumentIdList)(nil), "mtproto.DocumentIdList")
	proto.RegisterType((*DocumentList)(nil), "mtproto.DocumentList")
	proto.RegisterType((*MergeEncryptedFileRequest)(nil), "mtproto.MergeEncryptedFileRequest")
	proto.RegisterType((*PhotoVideo)(nil), "mtproto.PhotoVideo")
}

func init() { proto.RegisterFile("cfs_service.proto", fileDescriptor_e40e39152a1a5819) }

var fileDescriptor_e40e39152a1a5819 = []byte{
	// 880 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x55, 0xdd, 0x6e, 0x1b, 0x45,
	0x14, 0xce, 0xf8, 0x37, 0x3e, 0xb1, 0x5c, 0x75, 0xf2, 0xb7, 0x31, 0xaa, 0xeb, 0x1a, 0x54, 0x72,
	0xe5, 0x4a, 0x45, 0xbd, 0x28, 0x3f, 0xaa, 0x20, 0x6d, 0xa9, 0xa5, 0x06, 0xa2, 0x4d, 0xa0, 0xe2,
	0x6a, 0x99, 0xec, 0x1e, 0xc7, 0xa3, 0x78, 0xbd, 0xcb, 0xce, 0xac, 0x25, 0xf7, 0x25, 0xe0, 0x05,
	0xe0, 0x86, 0x07, 0xe0, 0x05, 0x78, 0x00, 0x2e, 0x7b, 0xc9, 0x25, 0x4a, 0xde, 0x80, 0x27, 0x40,
	0x33, 0xb3, 0xbf, 0xb5, 0x5d, 0x05, 0xc1, 0xdd, 0x9e, 0x33, 0xdf, 0x39, 0xdf, 0x37, 0xf3, 0xcd,
	0x9c, 0x85, 0xdb, 0xee, 0x58, 0x38, 0x02, 0xa3, 0x39, 0x77, 0x71, 0x18, 0x46, 0x81, 0x0c, 0x68,
	0xd3, 0x97, 0xfa, 0xa3, 0xbb, 0x23, 0xdc, 0x09, 0xfa, 0x6c, 0x28, 0xa7, 0x43, 0xb1, 0x98, 0xb9,
	0x66, 0x79, 0xf0, 0x33, 0x81, 0xbd, 0x6f, 0xc2, 0x69, 0xc0, 0xbc, 0x93, 0x49, 0x20, 0x83, 0xe7,
	0x7c, 0x8a, 0x36, 0xfe, 0x10, 0xa3, 0x90, 0x74, 0x0f, 0x1a, 0xb1, 0xc0, 0x68, 0xe4, 0x59, 0xa4,
	0x4f, 0x0e, 0xeb, 0x76, 0x12, 0xd1, 0x5d, 0x68, 0x84, 0x8e, 0x5c, 0x84, 0x68, 0x55, 0x74, 0xbe,
	0x1e, 0x9e, 0x2d, 0x42, 0x54, 0x70, 0x16, 0xcb, 0xc9, 0xc8, 0xb3, 0xaa, 0x7d, 0x72, 0x58, 0xb5,
	0x93, 0x88, 0xde, 0x87, 0xda, 0x98, 0x4f, 0xd1, 0xaa, 0xf5, 0xc9, 0xe1, 0xd6, 0x43, 0x3a, 0x4c,
	0xf4, 0x0c, 0x47, 0xb3, 0x30, 0x96, 0x9a, 0x4f, 0xaf, 0xd3, 0x1d, 0xa8, 0x4f, 0xd9, 0x02, 0x23,
	0xab, 0x6e, 0xba, 0xea, 0x60, 0x70, 0x09, 0xfb, 0x5f, 0xa2, 0xcc, 0xb4, 0x3d, 0x65, 0x92, 0xa5,
	0xfa, 0x0e, 0x60, 0x33, 0x54, 0x79, 0x87, 0x1b, 0x85, 0x55, 0xbb, 0xa9, 0xe3, 0x91, 0x47, 0xef,
	0xc2, 0x16, 0x73, 0x5d, 0x14, 0xc2, 0x99, 0x30, 0x31, 0xd1, 0x3a, 0xab, 0x36, 0x98, 0xd4, 0x0b,
	0x26, 0x26, 0x39, 0x59, 0xb5, 0x48, 0xf6, 0x23, 0x81, 0xb6, 0xa6, 0xd2, 0x34, 0x22, 0xfc, 0x4f,
	0x14, 0x14, 0x6a, 0x1e, 0x93, 0x98, 0x30, 0xe8, 0x6f, 0xfa, 0x00, 0x5a, 0x82, 0xbf, 0x46, 0x67,
	0xca, 0x85, 0xb4, 0x6a, 0xfd, 0x6a, 0xe9, 0x40, 0x34, 0xf3, 0x29, 0x7f, 0x8d, 0xf6, 0xa6, 0x02,
	0xbd, 0xe4, 0x42, 0x0e, 0x7e, 0x23, 0xb0, 0x7b, 0x34, 0x16, 0xc6, 0x21, 0x34, 0x1e, 0x1d, 0xa3,
	0xc7, 0xd9, 0xff, 0xe5, 0xce, 0x63, 0xa8, 0xfb, 0xaa, 0x5f, 0x62, 0xcf, 0xfb, 0x99, 0x9a, 0xb3,
	0x97, 0x0e, 0x57, 0x0e, 0x69, 0xb6, 0x12, 0xbf, 0x6d, 0x2a, 0xd6, 0x18, 0xf6, 0x0b, 0x01, 0xab,
	0xa0, 0xf8, 0x69, 0xe0, 0xc6, 0x3e, 0xce, 0xe4, 0xbb, 0x45, 0xe7, 0xea, 0x2a, 0x25, 0x75, 0x9f,
	0xa6, 0xea, 0xaa, 0x5a, 0xdd, 0xfd, 0x77, 0xab, 0x4b, 0xb9, 0x96, 0x04, 0xd6, 0x8a, 0x02, 0x7d,
	0x80, 0x14, 0x38, 0xf2, 0x68, 0x07, 0x2a, 0x99, 0xb7, 0x15, 0x7e, 0x03, 0x5b, 0x2d, 0x68, 0xce,
	0x31, 0x12, 0x3c, 0x98, 0x25, 0xce, 0xa6, 0xe1, 0x1a, 0xba, 0x53, 0xd8, 0x4d, 0xe9, 0x3e, 0x97,
	0x32, 0xe2, 0xe7, 0xb1, 0xd4, 0xd6, 0xd2, 0x8f, 0x01, 0x58, 0x9a, 0x10, 0x16, 0xd1, 0x97, 0xa1,
	0x9b, 0x6d, 0x70, 0xa9, 0xc6, 0x2e, 0xa0, 0x07, 0x4f, 0xa0, 0x93, 0xef, 0x41, 0x77, 0xdb, 0x87,
	0x26, 0xf7, 0xcc, 0xbd, 0x52, 0xad, 0xaa, 0x76, 0x83, 0x9b, 0x85, 0x4c, 0x55, 0xa5, 0xa8, 0xea,
	0x09, 0xb4, 0xd3, 0x06, 0x1a, 0xf5, 0x00, 0x5a, 0x5e, 0x12, 0xa7, 0x5a, 0x6e, 0x2f, 0x69, 0xb1,
	0x73, 0xcc, 0xe0, 0x57, 0x02, 0x07, 0xc7, 0x18, 0x5d, 0xe0, 0xb3, 0x99, 0x1b, 0x2d, 0x42, 0x89,
	0xde, 0x4d, 0x46, 0xc7, 0x3a, 0x9f, 0xf7, 0xa1, 0x19, 0xb2, 0x48, 0xaa, 0x67, 0x96, 0x5c, 0x4f,
	0x15, 0x8e, 0x3c, 0xa5, 0x5e, 0x7d, 0x89, 0xf4, 0x4c, 0x75, 0x40, 0x3f, 0x84, 0x5b, 0x97, 0xb8,
	0x70, 0xc6, 0x7c, 0x76, 0x81, 0x51, 0x18, 0xf1, 0x99, 0x4c, 0xee, 0x60, 0xe7, 0x12, 0x17, 0xcf,
	0xf3, 0xec, 0xe0, 0x6f, 0x02, 0xa0, 0xef, 0xec, 0xb7, 0xdc, 0xc3, 0xe0, 0x5f, 0xcb, 0xea, 0x43,
	0x5b, 0x8d, 0x26, 0xa7, 0xac, 0x0d, 0x54, 0xee, 0xc4, 0xe8, 0xbb, 0x07, 0x6d, 0xdf, 0x7b, 0xe4,
	0xb8, 0x13, 0x74, 0x2f, 0x45, 0xec, 0x6b, 0x99, 0x2d, 0x7b, 0xcb, 0xf7, 0x1e, 0x1d, 0x25, 0x29,
	0x7a, 0x07, 0x60, 0xae, 0xd8, 0x9d, 0x19, 0xf3, 0x51, 0xeb, 0x6c, 0xd9, 0x2d, 0x9d, 0xf9, 0x8a,
	0xf9, 0x98, 0xef, 0xb0, 0x51, 0xdc, 0xe1, 0x07, 0xd0, 0x31, 0x45, 0x42, 0x2a, 0x6e, 0x29, 0xac,
	0x66, 0x9f, 0x1c, 0x12, 0xbb, 0xad, 0xb3, 0xa7, 0x2a, 0x79, 0x26, 0x72, 0x6f, 0x37, 0x0b, 0xde,
	0x3e, 0xfc, 0xbd, 0x0e, 0x0d, 0xfb, 0xe4, 0xe8, 0x68, 0x2c, 0xe8, 0x31, 0x6c, 0xab, 0x3f, 0x42,
	0x5c, 0x1e, 0xf0, 0xf4, 0x6e, 0x66, 0xed, 0xea, 0xd1, 0xdf, 0xdd, 0x2d, 0x0f, 0xa5, 0x74, 0x1c,
	0x7e, 0x0d, 0x3b, 0xaa, 0xdd, 0xc5, 0x5b, 0x03, 0x99, 0xf6, 0x33, 0xf8, 0x9a, 0x59, 0xbd, 0xae,
	0xe1, 0x2b, 0xd8, 0xcb, 0xf5, 0x95, 0xc6, 0x5b, 0x2f, 0x2b, 0x58, 0x39, 0xfe, 0xba, 0x77, 0x8a,
	0xa3, 0xc0, 0x47, 0x21, 0xd8, 0x05, 0xea, 0x15, 0x8d, 0xa1, 0xdf, 0xc3, 0x41, 0xb1, 0x71, 0x79,
	0x0a, 0xdd, 0x5b, 0xd5, 0xbb, 0x04, 0xe9, 0xf6, 0xd7, 0xb5, 0x4f, 0x61, 0xf4, 0x31, 0xdc, 0x4a,
	0xce, 0x22, 0x4b, 0x6d, 0x2f, 0xbd, 0x98, 0x91, 0xd7, 0x5d, 0x7e, 0x46, 0xf4, 0x99, 0x71, 0xa5,
	0x50, 0x6a, 0x9e, 0xf0, 0x8a, 0x72, 0xb5, 0x50, 0x38, 0xbc, 0x12, 0xfe, 0x3b, 0x73, 0x78, 0xfe,
	0xd2, 0x2b, 0xa4, 0x83, 0xac, 0x60, 0xed, 0x13, 0xed, 0xbe, 0x97, 0x61, 0x4a, 0xcb, 0x8e, 0x36,
	0xf4, 0x33, 0xd3, 0x5a, 0xb0, 0x39, 0x66, 0x83, 0x48, 0xbc, 0xc2, 0xf3, 0x70, 0xf5, 0x1e, 0x3b,
	0x65, 0x77, 0xe9, 0x27, 0xe6, 0x9e, 0x14, 0xae, 0x9d, 0x79, 0x7f, 0xdb, 0x65, 0x9c, 0x4e, 0xbe,
	0x5d, 0xfc, 0x45, 0xf7, 0x8f, 0xab, 0x1e, 0x79, 0x73, 0xd5, 0x23, 0x7f, 0x5d, 0xf5, 0xc8, 0x4f,
	0xd7, 0xbd, 0x8d, 0x37, 0xd7, 0xbd, 0x8d, 0x3f, 0xaf, 0x7b, 0x1b, 0x2f, 0x2a, 0xe7, 0x0d, 0x0d,
	0xfc, 0xe8, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x78, 0x5b, 0x7d, 0x76, 0xe8, 0x08, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCCfsClient is the client API for RPCCfs service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCCfsClient interface {
	CfsUploadPhotoFile(ctx context.Context, in *UploadPhotoFileRequest, opts ...grpc.CallOption) (*PhotoDataRsp, error)
	CfsGetPhotoFileData(ctx context.Context, in *GetPhotoFileDataRequest, opts ...grpc.CallOption) (*PhotoDataRsp, error)
	CfsUploadedPhotoMedia(ctx context.Context, in *CfsUploadedPhotoMedia, opts ...grpc.CallOption) (*TLMessageMediaPhoto, error)
	CfsUploadedDocumentMedia(ctx context.Context, in *CfsUploadedDocumentMedia, opts ...grpc.CallOption) (*TLMessageMediaDocument, error)
	CfsGetDocument(ctx context.Context, in *DocumentId, opts ...grpc.CallOption) (*Document, error)
	CfsGetDocumentList(ctx context.Context, in *DocumentIdList, opts ...grpc.CallOption) (*DocumentList, error)
	CfsMergeEncryptedFile(ctx context.Context, in *MergeEncryptedFileRequest, opts ...grpc.CallOption) (*EncryptedFile_Data, error)
	CfsSaveDocumentAsWebp(ctx context.Context, in *DocumentId, opts ...grpc.CallOption) (*Photo, error)
	CfsUploadPhotoVideo(ctx context.Context, in *PhotoVideo, opts ...grpc.CallOption) (*Photo, error)
}

type rPCCfsClient struct {
	cc *grpc.ClientConn
}

func NewRPCCfsClient(cc *grpc.ClientConn) RPCCfsClient {
	return &rPCCfsClient{cc}
}

func (c *rPCCfsClient) CfsUploadPhotoFile(ctx context.Context, in *UploadPhotoFileRequest, opts ...grpc.CallOption) (*PhotoDataRsp, error) {
	out := new(PhotoDataRsp)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_uploadPhotoFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsGetPhotoFileData(ctx context.Context, in *GetPhotoFileDataRequest, opts ...grpc.CallOption) (*PhotoDataRsp, error) {
	out := new(PhotoDataRsp)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_getPhotoFileData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsUploadedPhotoMedia(ctx context.Context, in *CfsUploadedPhotoMedia, opts ...grpc.CallOption) (*TLMessageMediaPhoto, error) {
	out := new(TLMessageMediaPhoto)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_uploadedPhotoMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsUploadedDocumentMedia(ctx context.Context, in *CfsUploadedDocumentMedia, opts ...grpc.CallOption) (*TLMessageMediaDocument, error) {
	out := new(TLMessageMediaDocument)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_uploadedDocumentMedia", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsGetDocument(ctx context.Context, in *DocumentId, opts ...grpc.CallOption) (*Document, error) {
	out := new(Document)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_getDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsGetDocumentList(ctx context.Context, in *DocumentIdList, opts ...grpc.CallOption) (*DocumentList, error) {
	out := new(DocumentList)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_getDocumentList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsMergeEncryptedFile(ctx context.Context, in *MergeEncryptedFileRequest, opts ...grpc.CallOption) (*EncryptedFile_Data, error) {
	out := new(EncryptedFile_Data)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_mergeEncryptedFile", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsSaveDocumentAsWebp(ctx context.Context, in *DocumentId, opts ...grpc.CallOption) (*Photo, error) {
	out := new(Photo)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_saveDocumentAsWebp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCfsClient) CfsUploadPhotoVideo(ctx context.Context, in *PhotoVideo, opts ...grpc.CallOption) (*Photo, error) {
	out := new(Photo)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCfs/cfs_uploadPhotoVideo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCCfsServer is the server API for RPCCfs service.
type RPCCfsServer interface {
	CfsUploadPhotoFile(context.Context, *UploadPhotoFileRequest) (*PhotoDataRsp, error)
	CfsGetPhotoFileData(context.Context, *GetPhotoFileDataRequest) (*PhotoDataRsp, error)
	CfsUploadedPhotoMedia(context.Context, *CfsUploadedPhotoMedia) (*TLMessageMediaPhoto, error)
	CfsUploadedDocumentMedia(context.Context, *CfsUploadedDocumentMedia) (*TLMessageMediaDocument, error)
	CfsGetDocument(context.Context, *DocumentId) (*Document, error)
	CfsGetDocumentList(context.Context, *DocumentIdList) (*DocumentList, error)
	CfsMergeEncryptedFile(context.Context, *MergeEncryptedFileRequest) (*EncryptedFile_Data, error)
	CfsSaveDocumentAsWebp(context.Context, *DocumentId) (*Photo, error)
	CfsUploadPhotoVideo(context.Context, *PhotoVideo) (*Photo, error)
}

// UnimplementedRPCCfsServer can be embedded to have forward compatible implementations.
type UnimplementedRPCCfsServer struct {
}

func (*UnimplementedRPCCfsServer) CfsUploadPhotoFile(ctx context.Context, req *UploadPhotoFileRequest) (*PhotoDataRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsUploadPhotoFile not implemented")
}
func (*UnimplementedRPCCfsServer) CfsGetPhotoFileData(ctx context.Context, req *GetPhotoFileDataRequest) (*PhotoDataRsp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsGetPhotoFileData not implemented")
}
func (*UnimplementedRPCCfsServer) CfsUploadedPhotoMedia(ctx context.Context, req *CfsUploadedPhotoMedia) (*TLMessageMediaPhoto, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsUploadedPhotoMedia not implemented")
}
func (*UnimplementedRPCCfsServer) CfsUploadedDocumentMedia(ctx context.Context, req *CfsUploadedDocumentMedia) (*TLMessageMediaDocument, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsUploadedDocumentMedia not implemented")
}
func (*UnimplementedRPCCfsServer) CfsGetDocument(ctx context.Context, req *DocumentId) (*Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsGetDocument not implemented")
}
func (*UnimplementedRPCCfsServer) CfsGetDocumentList(ctx context.Context, req *DocumentIdList) (*DocumentList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsGetDocumentList not implemented")
}
func (*UnimplementedRPCCfsServer) CfsMergeEncryptedFile(ctx context.Context, req *MergeEncryptedFileRequest) (*EncryptedFile_Data, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsMergeEncryptedFile not implemented")
}
func (*UnimplementedRPCCfsServer) CfsSaveDocumentAsWebp(ctx context.Context, req *DocumentId) (*Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsSaveDocumentAsWebp not implemented")
}
func (*UnimplementedRPCCfsServer) CfsUploadPhotoVideo(ctx context.Context, req *PhotoVideo) (*Photo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CfsUploadPhotoVideo not implemented")
}

func RegisterRPCCfsServer(s *grpc.Server, srv RPCCfsServer) {
	s.RegisterService(&_RPCCfs_serviceDesc, srv)
}

func _RPCCfs_CfsUploadPhotoFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UploadPhotoFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsUploadPhotoFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsUploadPhotoFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsUploadPhotoFile(ctx, req.(*UploadPhotoFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsGetPhotoFileData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPhotoFileDataRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsGetPhotoFileData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsGetPhotoFileData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsGetPhotoFileData(ctx, req.(*GetPhotoFileDataRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsUploadedPhotoMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CfsUploadedPhotoMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsUploadedPhotoMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsUploadedPhotoMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsUploadedPhotoMedia(ctx, req.(*CfsUploadedPhotoMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsUploadedDocumentMedia_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CfsUploadedDocumentMedia)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsUploadedDocumentMedia(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsUploadedDocumentMedia",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsUploadedDocumentMedia(ctx, req.(*CfsUploadedDocumentMedia))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsGetDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsGetDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsGetDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsGetDocument(ctx, req.(*DocumentId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsGetDocumentList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentIdList)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsGetDocumentList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsGetDocumentList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsGetDocumentList(ctx, req.(*DocumentIdList))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsMergeEncryptedFile_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MergeEncryptedFileRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsMergeEncryptedFile(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsMergeEncryptedFile",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsMergeEncryptedFile(ctx, req.(*MergeEncryptedFileRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsSaveDocumentAsWebp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsSaveDocumentAsWebp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsSaveDocumentAsWebp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsSaveDocumentAsWebp(ctx, req.(*DocumentId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCfs_CfsUploadPhotoVideo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotoVideo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCfsServer).CfsUploadPhotoVideo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCfs/CfsUploadPhotoVideo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCfsServer).CfsUploadPhotoVideo(ctx, req.(*PhotoVideo))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCCfs_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mtproto.RPCCfs",
	HandlerType: (*RPCCfsServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "cfs_uploadPhotoFile",
			Handler:    _RPCCfs_CfsUploadPhotoFile_Handler,
		},
		{
			MethodName: "cfs_getPhotoFileData",
			Handler:    _RPCCfs_CfsGetPhotoFileData_Handler,
		},
		{
			MethodName: "cfs_uploadedPhotoMedia",
			Handler:    _RPCCfs_CfsUploadedPhotoMedia_Handler,
		},
		{
			MethodName: "cfs_uploadedDocumentMedia",
			Handler:    _RPCCfs_CfsUploadedDocumentMedia_Handler,
		},
		{
			MethodName: "cfs_getDocument",
			Handler:    _RPCCfs_CfsGetDocument_Handler,
		},
		{
			MethodName: "cfs_getDocumentList",
			Handler:    _RPCCfs_CfsGetDocumentList_Handler,
		},
		{
			MethodName: "cfs_mergeEncryptedFile",
			Handler:    _RPCCfs_CfsMergeEncryptedFile_Handler,
		},
		{
			MethodName: "cfs_saveDocumentAsWebp",
			Handler:    _RPCCfs_CfsSaveDocumentAsWebp_Handler,
		},
		{
			MethodName: "cfs_uploadPhotoVideo",
			Handler:    _RPCCfs_CfsUploadPhotoVideo_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "cfs_service.proto",
}

func (m *UploadPhotoFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UploadPhotoFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UploadPhotoFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x28
	}
	if m.File != nil {
		{
			size, err := m.File.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfsService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x18
	}
	if m.PType != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.PType))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *GetPhotoFileDataRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *GetPhotoFileDataRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *GetPhotoFileDataRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x18
	}
	if m.AccessHash != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.PhotoId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.PhotoId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhotoDataRsp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoDataRsp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhotoDataRsp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.SizeList) > 0 {
		for iNdEx := len(m.SizeList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.SizeList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCfsService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x22
		}
	}
	if m.Date != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Date))
		i--
		dAtA[i] = 0x18
	}
	if m.AccessHash != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.PhotoId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.PhotoId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CfsUploadedPhotoMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CfsUploadedPhotoMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CfsUploadedPhotoMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x28
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfsService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x18
	}
	if m.PType != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.PType))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *CfsUploadedDocumentMedia) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *CfsUploadedDocumentMedia) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *CfsUploadedDocumentMedia) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x20
	}
	if m.Media != nil {
		{
			size, err := m.Media.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCfsService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DocumentId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.AccessHash != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DocumentAttributeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentAttributeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentAttributeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for iNdEx := len(m.Attributes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Attributes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCfsService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *DocumentIdList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentIdList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentIdList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x10
	}
	if len(m.IdList) > 0 {
		dAtA5 := make([]byte, len(m.IdList)*10)
		var j4 int
		for _, num1 := range m.IdList {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA5[j4] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j4++
			}
			dAtA5[j4] = uint8(num)
			j4++
		}
		i -= j4
		copy(dAtA[i:], dAtA5[:j4])
		i = encodeVarintCfsService(dAtA, i, uint64(j4))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *DocumentList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Documents) > 0 {
		for iNdEx := len(m.Documents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Documents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCfsService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *MergeEncryptedFileRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MergeEncryptedFileRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MergeEncryptedFileRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyFingerprint != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.KeyFingerprint))
		i--
		dAtA[i] = 0x28
	}
	if m.Parts != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Parts))
		i--
		dAtA[i] = 0x20
	}
	if m.PartId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.PartId))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhotoVideo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoVideo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhotoVideo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Layer != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x40
	}
	if m.VideoStartTs != 0 {
		i -= 8
		encoding_binary.LittleEndian.PutUint64(dAtA[i:], uint64(math.Float64bits(float64(m.VideoStartTs))))
		i--
		dAtA[i] = 0x39
	}
	if m.Parts != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.Parts))
		i--
		dAtA[i] = 0x30
	}
	if len(m.VideoName) > 0 {
		i -= len(m.VideoName)
		copy(dAtA[i:], m.VideoName)
		i = encodeVarintCfsService(dAtA, i, uint64(len(m.VideoName)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Md5Checksum) > 0 {
		i -= len(m.Md5Checksum)
		copy(dAtA[i:], m.Md5Checksum)
		i = encodeVarintCfsService(dAtA, i, uint64(len(m.Md5Checksum)))
		i--
		dAtA[i] = 0x22
	}
	if m.FilePartId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.FilePartId))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCfsService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintCfsService(dAtA []byte, offset int, v uint64) int {
	offset -= sovCfsService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *UploadPhotoFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCfsService(uint64(m.UserId))
	}
	if m.PType != 0 {
		n += 1 + sovCfsService(uint64(m.PType))
	}
	if m.AuthId != 0 {
		n += 1 + sovCfsService(uint64(m.AuthId))
	}
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovCfsService(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func (m *GetPhotoFileDataRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhotoId != 0 {
		n += 1 + sovCfsService(uint64(m.PhotoId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovCfsService(uint64(m.AccessHash))
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func (m *PhotoDataRsp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PhotoId != 0 {
		n += 1 + sovCfsService(uint64(m.PhotoId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovCfsService(uint64(m.AccessHash))
	}
	if m.Date != 0 {
		n += 1 + sovCfsService(uint64(m.Date))
	}
	if len(m.SizeList) > 0 {
		for _, e := range m.SizeList {
			l = e.Size()
			n += 1 + l + sovCfsService(uint64(l))
		}
	}
	return n
}

func (m *CfsUploadedPhotoMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCfsService(uint64(m.UserId))
	}
	if m.PType != 0 {
		n += 1 + sovCfsService(uint64(m.PType))
	}
	if m.AuthId != 0 {
		n += 1 + sovCfsService(uint64(m.AuthId))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovCfsService(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func (m *CfsUploadedDocumentMedia) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCfsService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCfsService(uint64(m.AuthId))
	}
	if m.Media != nil {
		l = m.Media.Size()
		n += 1 + l + sovCfsService(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func (m *DocumentId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCfsService(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovCfsService(uint64(m.AccessHash))
	}
	if m.Version != 0 {
		n += 1 + sovCfsService(uint64(m.Version))
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func (m *DocumentAttributeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Attributes) > 0 {
		for _, e := range m.Attributes {
			l = e.Size()
			n += 1 + l + sovCfsService(uint64(l))
		}
	}
	return n
}

func (m *DocumentIdList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.IdList) > 0 {
		l = 0
		for _, e := range m.IdList {
			l += sovCfsService(uint64(e))
		}
		n += 1 + sovCfsService(uint64(l)) + l
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func (m *DocumentList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Documents) > 0 {
		for _, e := range m.Documents {
			l = e.Size()
			n += 1 + l + sovCfsService(uint64(l))
		}
	}
	return n
}

func (m *MergeEncryptedFileRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCfsService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCfsService(uint64(m.AuthId))
	}
	if m.PartId != 0 {
		n += 1 + sovCfsService(uint64(m.PartId))
	}
	if m.Parts != 0 {
		n += 1 + sovCfsService(uint64(m.Parts))
	}
	if m.KeyFingerprint != 0 {
		n += 1 + sovCfsService(uint64(m.KeyFingerprint))
	}
	return n
}

func (m *PhotoVideo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCfsService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCfsService(uint64(m.AuthId))
	}
	if m.FilePartId != 0 {
		n += 1 + sovCfsService(uint64(m.FilePartId))
	}
	l = len(m.Md5Checksum)
	if l > 0 {
		n += 1 + l + sovCfsService(uint64(l))
	}
	l = len(m.VideoName)
	if l > 0 {
		n += 1 + l + sovCfsService(uint64(l))
	}
	if m.Parts != 0 {
		n += 1 + sovCfsService(uint64(m.Parts))
	}
	if m.VideoStartTs != 0 {
		n += 9
	}
	if m.Layer != 0 {
		n += 1 + sovCfsService(uint64(m.Layer))
	}
	return n
}

func sovCfsService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCfsService(x uint64) (n int) {
	return sovCfsService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *UploadPhotoFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UploadPhotoFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UploadPhotoFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PType", wireType)
			}
			m.PType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &InputFile{}
			}
			if err := m.File.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *GetPhotoFileDataRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: GetPhotoFileDataRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: GetPhotoFileDataRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			m.PhotoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoDataRsp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoDataRsp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoDataRsp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			m.PhotoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Date", wireType)
			}
			m.Date = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Date |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SizeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SizeList = append(m.SizeList, &PhotoSize{})
			if err := m.SizeList[len(m.SizeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CfsUploadedPhotoMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CfsUploadedPhotoMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CfsUploadedPhotoMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PType", wireType)
			}
			m.PType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &TLInputMediaUploadedPhoto{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CfsUploadedDocumentMedia) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CfsUploadedDocumentMedia: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CfsUploadedDocumentMedia: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Media", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Media == nil {
				m.Media = &TLInputMediaUploadedDocument{}
			}
			if err := m.Media.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentAttributeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentAttributeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentAttributeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Attributes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Attributes = append(m.Attributes, &DocumentAttribute{})
			if err := m.Attributes[len(m.Attributes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentIdList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentIdList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentIdList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfsService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.IdList = append(m.IdList, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCfsService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCfsService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCfsService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.IdList) == 0 {
					m.IdList = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCfsService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.IdList = append(m.IdList, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field IdList", wireType)
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Documents = append(m.Documents, &Document{})
			if err := m.Documents[len(m.Documents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MergeEncryptedFileRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MergeEncryptedFileRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MergeEncryptedFileRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartId", wireType)
			}
			m.PartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PartId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			m.Parts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyFingerprint", wireType)
			}
			m.KeyFingerprint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyFingerprint |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoVideo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoVideo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoVideo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilePartId", wireType)
			}
			m.FilePartId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FilePartId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Md5Checksum", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Md5Checksum = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCfsService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCfsService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VideoName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parts", wireType)
			}
			m.Parts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Parts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field VideoStartTs", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint64(encoding_binary.LittleEndian.Uint64(dAtA[iNdEx:]))
			iNdEx += 8
			m.VideoStartTs = float64(math.Float64frombits(v))
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCfsService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCfsService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCfsService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCfsService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCfsService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCfsService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCfsService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCfsService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCfsService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCfsService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCfsService = fmt.Errorf("proto: unexpected end of group")
)
