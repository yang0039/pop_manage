// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cache_service.proto

package mtproto

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type AuthKeyInfo struct {
	UserId  int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId  int64  `protobuf:"varint,2,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	AuthKey []byte `protobuf:"bytes,3,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
}

func (m *AuthKeyInfo) Reset()         { *m = AuthKeyInfo{} }
func (m *AuthKeyInfo) String() string { return proto.CompactTextString(m) }
func (*AuthKeyInfo) ProtoMessage()    {}
func (*AuthKeyInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{0}
}
func (m *AuthKeyInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthKeyInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthKeyInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthKeyInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthKeyInfo.Merge(m, src)
}
func (m *AuthKeyInfo) XXX_Size() int {
	return m.Size()
}
func (m *AuthKeyInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthKeyInfo.DiscardUnknown(m)
}

var xxx_messageInfo_AuthKeyInfo proto.InternalMessageInfo

func (m *AuthKeyInfo) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AuthKeyInfo) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *AuthKeyInfo) GetAuthKey() []byte {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

type ChangeAuthKey struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId int64 `protobuf:"varint,2,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	OldUid int32 `protobuf:"varint,3,opt,name=old_uid,json=oldUid,proto3" json:"old_uid,omitempty"`
}

func (m *ChangeAuthKey) Reset()         { *m = ChangeAuthKey{} }
func (m *ChangeAuthKey) String() string { return proto.CompactTextString(m) }
func (*ChangeAuthKey) ProtoMessage()    {}
func (*ChangeAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{1}
}
func (m *ChangeAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChangeAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChangeAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChangeAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChangeAuthKey.Merge(m, src)
}
func (m *ChangeAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *ChangeAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_ChangeAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_ChangeAuthKey proto.InternalMessageInfo

func (m *ChangeAuthKey) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChangeAuthKey) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *ChangeAuthKey) GetOldUid() int32 {
	if m != nil {
		return m.OldUid
	}
	return 0
}

type UserPresence struct {
	UserId     int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId     int64  `protobuf:"varint,2,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Offline    bool   `protobuf:"varint,3,opt,name=offline,proto3" json:"offline,omitempty"`
	LastSeenIp string `protobuf:"bytes,4,opt,name=last_seen_ip,json=lastSeenIp,proto3" json:"last_seen_ip,omitempty"`
}

func (m *UserPresence) Reset()         { *m = UserPresence{} }
func (m *UserPresence) String() string { return proto.CompactTextString(m) }
func (*UserPresence) ProtoMessage()    {}
func (*UserPresence) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{2}
}
func (m *UserPresence) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPresence) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPresence.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPresence) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPresence.Merge(m, src)
}
func (m *UserPresence) XXX_Size() int {
	return m.Size()
}
func (m *UserPresence) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPresence.DiscardUnknown(m)
}

var xxx_messageInfo_UserPresence proto.InternalMessageInfo

func (m *UserPresence) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserPresence) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *UserPresence) GetOffline() bool {
	if m != nil {
		return m.Offline
	}
	return false
}

func (m *UserPresence) GetLastSeenIp() string {
	if m != nil {
		return m.LastSeenIp
	}
	return ""
}

type UserState struct {
	UserId int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Pts    int32 `protobuf:"varint,2,opt,name=pts,proto3" json:"pts,omitempty"`
	Qts    int32 `protobuf:"varint,3,opt,name=qts,proto3" json:"qts,omitempty"`
	Queue  int32 `protobuf:"varint,4,opt,name=queue,proto3" json:"queue,omitempty"`
}

func (m *UserState) Reset()         { *m = UserState{} }
func (m *UserState) String() string { return proto.CompactTextString(m) }
func (*UserState) ProtoMessage()    {}
func (*UserState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{3}
}
func (m *UserState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserState.Merge(m, src)
}
func (m *UserState) XXX_Size() int {
	return m.Size()
}
func (m *UserState) XXX_DiscardUnknown() {
	xxx_messageInfo_UserState.DiscardUnknown(m)
}

var xxx_messageInfo_UserState proto.InternalMessageInfo

func (m *UserState) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserState) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *UserState) GetQts() int32 {
	if m != nil {
		return m.Qts
	}
	return 0
}

func (m *UserState) GetQueue() int32 {
	if m != nil {
		return m.Queue
	}
	return 0
}

type UserUnreadCount struct {
	UserId      int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId      int64 `protobuf:"varint,2,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	UnreadCount int32 `protobuf:"varint,3,opt,name=unread_count,json=unreadCount,proto3" json:"unread_count,omitempty"`
}

func (m *UserUnreadCount) Reset()         { *m = UserUnreadCount{} }
func (m *UserUnreadCount) String() string { return proto.CompactTextString(m) }
func (*UserUnreadCount) ProtoMessage()    {}
func (*UserUnreadCount) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{4}
}
func (m *UserUnreadCount) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserUnreadCount) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserUnreadCount.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserUnreadCount) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUnreadCount.Merge(m, src)
}
func (m *UserUnreadCount) XXX_Size() int {
	return m.Size()
}
func (m *UserUnreadCount) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUnreadCount.DiscardUnknown(m)
}

var xxx_messageInfo_UserUnreadCount proto.InternalMessageInfo

func (m *UserUnreadCount) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserUnreadCount) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *UserUnreadCount) GetUnreadCount() int32 {
	if m != nil {
		return m.UnreadCount
	}
	return 0
}

type UserUnreadCountList struct {
	UnreadList []*UserUnreadCount `protobuf:"bytes,1,rep,name=unread_list,json=unreadList,proto3" json:"unread_list,omitempty"`
}

func (m *UserUnreadCountList) Reset()         { *m = UserUnreadCountList{} }
func (m *UserUnreadCountList) String() string { return proto.CompactTextString(m) }
func (*UserUnreadCountList) ProtoMessage()    {}
func (*UserUnreadCountList) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{5}
}
func (m *UserUnreadCountList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserUnreadCountList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserUnreadCountList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserUnreadCountList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserUnreadCountList.Merge(m, src)
}
func (m *UserUnreadCountList) XXX_Size() int {
	return m.Size()
}
func (m *UserUnreadCountList) XXX_DiscardUnknown() {
	xxx_messageInfo_UserUnreadCountList.DiscardUnknown(m)
}

var xxx_messageInfo_UserUnreadCountList proto.InternalMessageInfo

func (m *UserUnreadCountList) GetUnreadList() []*UserUnreadCount {
	if m != nil {
		return m.UnreadList
	}
	return nil
}

type UserDialog struct {
	UserId                  int32  `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PeerType                int32  `protobuf:"varint,2,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId                  int32  `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	TopMessage              int32  `protobuf:"varint,4,opt,name=top_message,json=topMessage,proto3" json:"top_message,omitempty"`
	IncrReadInboxMaxId      int32  `protobuf:"varint,5,opt,name=incr_read_inbox_max_id,json=incrReadInboxMaxId,proto3" json:"incr_read_inbox_max_id,omitempty"`
	IncrUnreadCount         int32  `protobuf:"varint,6,opt,name=incr_unread_count,json=incrUnreadCount,proto3" json:"incr_unread_count,omitempty"`
	IncrUnreadMentionsCount int32  `protobuf:"varint,7,opt,name=incr_unread_mentions_count,json=incrUnreadMentionsCount,proto3" json:"incr_unread_mentions_count,omitempty"`
	DraftMessage            []byte `protobuf:"bytes,8,opt,name=draft_message,json=draftMessage,proto3" json:"draft_message,omitempty"`
	IsDelete                bool   `protobuf:"varint,9,opt,name=is_delete,json=isDelete,proto3" json:"is_delete,omitempty"`
	ClearDraft              bool   `protobuf:"varint,10,opt,name=clear_draft,json=clearDraft,proto3" json:"clear_draft,omitempty"`
	UpdateDraft             bool   `protobuf:"varint,11,opt,name=update_draft,json=updateDraft,proto3" json:"update_draft,omitempty"`
	ClearCount              bool   `protobuf:"varint,12,opt,name=clear_count,json=clearCount,proto3" json:"clear_count,omitempty"`
	UpdateMention           bool   `protobuf:"varint,13,opt,name=update_mention,json=updateMention,proto3" json:"update_mention,omitempty"`
	UpdateTopMessage        bool   `protobuf:"varint,14,opt,name=update_top_message,json=updateTopMessage,proto3" json:"update_top_message,omitempty"`
}

func (m *UserDialog) Reset()         { *m = UserDialog{} }
func (m *UserDialog) String() string { return proto.CompactTextString(m) }
func (*UserDialog) ProtoMessage()    {}
func (*UserDialog) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{6}
}
func (m *UserDialog) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserDialog) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserDialog.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserDialog) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserDialog.Merge(m, src)
}
func (m *UserDialog) XXX_Size() int {
	return m.Size()
}
func (m *UserDialog) XXX_DiscardUnknown() {
	xxx_messageInfo_UserDialog.DiscardUnknown(m)
}

var xxx_messageInfo_UserDialog proto.InternalMessageInfo

func (m *UserDialog) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserDialog) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *UserDialog) GetPeerId() int32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *UserDialog) GetTopMessage() int32 {
	if m != nil {
		return m.TopMessage
	}
	return 0
}

func (m *UserDialog) GetIncrReadInboxMaxId() int32 {
	if m != nil {
		return m.IncrReadInboxMaxId
	}
	return 0
}

func (m *UserDialog) GetIncrUnreadCount() int32 {
	if m != nil {
		return m.IncrUnreadCount
	}
	return 0
}

func (m *UserDialog) GetIncrUnreadMentionsCount() int32 {
	if m != nil {
		return m.IncrUnreadMentionsCount
	}
	return 0
}

func (m *UserDialog) GetDraftMessage() []byte {
	if m != nil {
		return m.DraftMessage
	}
	return nil
}

func (m *UserDialog) GetIsDelete() bool {
	if m != nil {
		return m.IsDelete
	}
	return false
}

func (m *UserDialog) GetClearDraft() bool {
	if m != nil {
		return m.ClearDraft
	}
	return false
}

func (m *UserDialog) GetUpdateDraft() bool {
	if m != nil {
		return m.UpdateDraft
	}
	return false
}

func (m *UserDialog) GetClearCount() bool {
	if m != nil {
		return m.ClearCount
	}
	return false
}

func (m *UserDialog) GetUpdateMention() bool {
	if m != nil {
		return m.UpdateMention
	}
	return false
}

func (m *UserDialog) GetUpdateTopMessage() bool {
	if m != nil {
		return m.UpdateTopMessage
	}
	return false
}

type DialogRowPeer struct {
	UserId   int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PeerType int32 `protobuf:"varint,2,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId   int32 `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
}

func (m *DialogRowPeer) Reset()         { *m = DialogRowPeer{} }
func (m *DialogRowPeer) String() string { return proto.CompactTextString(m) }
func (*DialogRowPeer) ProtoMessage()    {}
func (*DialogRowPeer) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{7}
}
func (m *DialogRowPeer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DialogRowPeer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DialogRowPeer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DialogRowPeer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DialogRowPeer.Merge(m, src)
}
func (m *DialogRowPeer) XXX_Size() int {
	return m.Size()
}
func (m *DialogRowPeer) XXX_DiscardUnknown() {
	xxx_messageInfo_DialogRowPeer.DiscardUnknown(m)
}

var xxx_messageInfo_DialogRowPeer proto.InternalMessageInfo

func (m *DialogRowPeer) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *DialogRowPeer) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *DialogRowPeer) GetPeerId() int32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

type ReadHistory struct {
	UserId   int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	PeerType int32 `protobuf:"varint,2,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId   int32 `protobuf:"varint,3,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	MaxId    int32 `protobuf:"varint,4,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
	IsInbox  bool  `protobuf:"varint,5,opt,name=is_inbox,json=isInbox,proto3" json:"is_inbox,omitempty"`
	AuthId   int64 `protobuf:"varint,6,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Pts      int32 `protobuf:"varint,7,opt,name=pts,proto3" json:"pts,omitempty"`
}

func (m *ReadHistory) Reset()         { *m = ReadHistory{} }
func (m *ReadHistory) String() string { return proto.CompactTextString(m) }
func (*ReadHistory) ProtoMessage()    {}
func (*ReadHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{8}
}
func (m *ReadHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReadHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReadHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReadHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReadHistory.Merge(m, src)
}
func (m *ReadHistory) XXX_Size() int {
	return m.Size()
}
func (m *ReadHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ReadHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ReadHistory proto.InternalMessageInfo

func (m *ReadHistory) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReadHistory) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *ReadHistory) GetPeerId() int32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *ReadHistory) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

func (m *ReadHistory) GetIsInbox() bool {
	if m != nil {
		return m.IsInbox
	}
	return false
}

func (m *ReadHistory) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *ReadHistory) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

type ChannelReadHistory struct {
	UserId   int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	FromId   int32 `protobuf:"varint,2,opt,name=from_id,json=fromId,proto3" json:"from_id,omitempty"`
	PeerType int32 `protobuf:"varint,3,opt,name=peer_type,json=peerType,proto3" json:"peer_type,omitempty"`
	PeerId   int32 `protobuf:"varint,4,opt,name=peer_id,json=peerId,proto3" json:"peer_id,omitempty"`
	MaxId    int32 `protobuf:"varint,5,opt,name=max_id,json=maxId,proto3" json:"max_id,omitempty"`
}

func (m *ChannelReadHistory) Reset()         { *m = ChannelReadHistory{} }
func (m *ChannelReadHistory) String() string { return proto.CompactTextString(m) }
func (*ChannelReadHistory) ProtoMessage()    {}
func (*ChannelReadHistory) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{9}
}
func (m *ChannelReadHistory) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChannelReadHistory) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChannelReadHistory.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChannelReadHistory) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChannelReadHistory.Merge(m, src)
}
func (m *ChannelReadHistory) XXX_Size() int {
	return m.Size()
}
func (m *ChannelReadHistory) XXX_DiscardUnknown() {
	xxx_messageInfo_ChannelReadHistory.DiscardUnknown(m)
}

var xxx_messageInfo_ChannelReadHistory proto.InternalMessageInfo

func (m *ChannelReadHistory) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChannelReadHistory) GetFromId() int32 {
	if m != nil {
		return m.FromId
	}
	return 0
}

func (m *ChannelReadHistory) GetPeerType() int32 {
	if m != nil {
		return m.PeerType
	}
	return 0
}

func (m *ChannelReadHistory) GetPeerId() int32 {
	if m != nil {
		return m.PeerId
	}
	return 0
}

func (m *ChannelReadHistory) GetMaxId() int32 {
	if m != nil {
		return m.MaxId
	}
	return 0
}

type LastSeenAt struct {
	UserId     int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	LastSeenAt int32 `protobuf:"varint,2,opt,name=last_seen_at,json=lastSeenAt,proto3" json:"last_seen_at,omitempty"`
}

func (m *LastSeenAt) Reset()         { *m = LastSeenAt{} }
func (m *LastSeenAt) String() string { return proto.CompactTextString(m) }
func (*LastSeenAt) ProtoMessage()    {}
func (*LastSeenAt) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{10}
}
func (m *LastSeenAt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *LastSeenAt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_LastSeenAt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *LastSeenAt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_LastSeenAt.Merge(m, src)
}
func (m *LastSeenAt) XXX_Size() int {
	return m.Size()
}
func (m *LastSeenAt) XXX_DiscardUnknown() {
	xxx_messageInfo_LastSeenAt.DiscardUnknown(m)
}

var xxx_messageInfo_LastSeenAt proto.InternalMessageInfo

func (m *LastSeenAt) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *LastSeenAt) GetLastSeenAt() int32 {
	if m != nil {
		return m.LastSeenAt
	}
	return 0
}

type Int32 struct {
	Id int32 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Int32) Reset()         { *m = Int32{} }
func (m *Int32) String() string { return proto.CompactTextString(m) }
func (*Int32) ProtoMessage()    {}
func (*Int32) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{11}
}
func (m *Int32) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int32) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int32.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int32) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int32.Merge(m, src)
}
func (m *Int32) XXX_Size() int {
	return m.Size()
}
func (m *Int32) XXX_DiscardUnknown() {
	xxx_messageInfo_Int32.DiscardUnknown(m)
}

var xxx_messageInfo_Int32 proto.InternalMessageInfo

func (m *Int32) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Int64 struct {
	Id int64 `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
}

func (m *Int64) Reset()         { *m = Int64{} }
func (m *Int64) String() string { return proto.CompactTextString(m) }
func (*Int64) ProtoMessage()    {}
func (*Int64) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{12}
}
func (m *Int64) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int64) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int64.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int64) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int64.Merge(m, src)
}
func (m *Int64) XXX_Size() int {
	return m.Size()
}
func (m *Int64) XXX_DiscardUnknown() {
	xxx_messageInfo_Int64.DiscardUnknown(m)
}

var xxx_messageInfo_Int64 proto.InternalMessageInfo

func (m *Int64) GetId() int64 {
	if m != nil {
		return m.Id
	}
	return 0
}

type Result struct {
	Ok bool `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
}

func (m *Result) Reset()         { *m = Result{} }
func (m *Result) String() string { return proto.CompactTextString(m) }
func (*Result) ProtoMessage()    {}
func (*Result) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{13}
}
func (m *Result) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Result) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Result.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Result) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Result.Merge(m, src)
}
func (m *Result) XXX_Size() int {
	return m.Size()
}
func (m *Result) XXX_DiscardUnknown() {
	xxx_messageInfo_Result.DiscardUnknown(m)
}

var xxx_messageInfo_Result proto.InternalMessageInfo

func (m *Result) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type Int32List struct {
	Id []int32 `protobuf:"varint,1,rep,packed,name=id,proto3" json:"id,omitempty"`
}

func (m *Int32List) Reset()         { *m = Int32List{} }
func (m *Int32List) String() string { return proto.CompactTextString(m) }
func (*Int32List) ProtoMessage()    {}
func (*Int32List) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{14}
}
func (m *Int32List) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Int32List) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Int32List.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Int32List) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Int32List.Merge(m, src)
}
func (m *Int32List) XXX_Size() int {
	return m.Size()
}
func (m *Int32List) XXX_DiscardUnknown() {
	xxx_messageInfo_Int32List.DiscardUnknown(m)
}

var xxx_messageInfo_Int32List proto.InternalMessageInfo

func (m *Int32List) GetId() []int32 {
	if m != nil {
		return m.Id
	}
	return nil
}

type PhotoFileUnit struct {
	VolumeId int64 `protobuf:"varint,1,opt,name=volume_id,json=volumeId,proto3" json:"volume_id,omitempty"`
	LocalId  int32 `protobuf:"varint,2,opt,name=local_id,json=localId,proto3" json:"local_id,omitempty"`
	Secret   int64 `protobuf:"varint,3,opt,name=secret,proto3" json:"secret,omitempty"`
	Offset   int32 `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit    int32 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *PhotoFileUnit) Reset()         { *m = PhotoFileUnit{} }
func (m *PhotoFileUnit) String() string { return proto.CompactTextString(m) }
func (*PhotoFileUnit) ProtoMessage()    {}
func (*PhotoFileUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{15}
}
func (m *PhotoFileUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhotoFileUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhotoFileUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhotoFileUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoFileUnit.Merge(m, src)
}
func (m *PhotoFileUnit) XXX_Size() int {
	return m.Size()
}
func (m *PhotoFileUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoFileUnit.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoFileUnit proto.InternalMessageInfo

func (m *PhotoFileUnit) GetVolumeId() int64 {
	if m != nil {
		return m.VolumeId
	}
	return 0
}

func (m *PhotoFileUnit) GetLocalId() int32 {
	if m != nil {
		return m.LocalId
	}
	return 0
}

func (m *PhotoFileUnit) GetSecret() int64 {
	if m != nil {
		return m.Secret
	}
	return 0
}

func (m *PhotoFileUnit) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *PhotoFileUnit) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type DocumentFileUnit struct {
	DocumentId int64 `protobuf:"varint,1,opt,name=document_id,json=documentId,proto3" json:"document_id,omitempty"`
	AccessHash int64 `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Version    int32 `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	Offset     int32 `protobuf:"varint,4,opt,name=offset,proto3" json:"offset,omitempty"`
	Limit      int32 `protobuf:"varint,5,opt,name=limit,proto3" json:"limit,omitempty"`
}

func (m *DocumentFileUnit) Reset()         { *m = DocumentFileUnit{} }
func (m *DocumentFileUnit) String() string { return proto.CompactTextString(m) }
func (*DocumentFileUnit) ProtoMessage()    {}
func (*DocumentFileUnit) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{16}
}
func (m *DocumentFileUnit) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DocumentFileUnit) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DocumentFileUnit.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DocumentFileUnit) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DocumentFileUnit.Merge(m, src)
}
func (m *DocumentFileUnit) XXX_Size() int {
	return m.Size()
}
func (m *DocumentFileUnit) XXX_DiscardUnknown() {
	xxx_messageInfo_DocumentFileUnit.DiscardUnknown(m)
}

var xxx_messageInfo_DocumentFileUnit proto.InternalMessageInfo

func (m *DocumentFileUnit) GetDocumentId() int64 {
	if m != nil {
		return m.DocumentId
	}
	return 0
}

func (m *DocumentFileUnit) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *DocumentFileUnit) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *DocumentFileUnit) GetOffset() int32 {
	if m != nil {
		return m.Offset
	}
	return 0
}

func (m *DocumentFileUnit) GetLimit() int32 {
	if m != nil {
		return m.Limit
	}
	return 0
}

type PhotoSizeList struct {
	Sizes []*PhotoSize `protobuf:"bytes,1,rep,name=sizes,proto3" json:"sizes,omitempty"`
}

func (m *PhotoSizeList) Reset()         { *m = PhotoSizeList{} }
func (m *PhotoSizeList) String() string { return proto.CompactTextString(m) }
func (*PhotoSizeList) ProtoMessage()    {}
func (*PhotoSizeList) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{17}
}
func (m *PhotoSizeList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *PhotoSizeList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_PhotoSizeList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *PhotoSizeList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PhotoSizeList.Merge(m, src)
}
func (m *PhotoSizeList) XXX_Size() int {
	return m.Size()
}
func (m *PhotoSizeList) XXX_DiscardUnknown() {
	xxx_messageInfo_PhotoSizeList.DiscardUnknown(m)
}

var xxx_messageInfo_PhotoSizeList proto.InternalMessageInfo

func (m *PhotoSizeList) GetSizes() []*PhotoSize {
	if m != nil {
		return m.Sizes
	}
	return nil
}

type SaltUntilReq struct {
	AuthId int64 `protobuf:"varint,1,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Salt   int64 `protobuf:"varint,2,opt,name=salt,proto3" json:"salt,omitempty"`
}

func (m *SaltUntilReq) Reset()         { *m = SaltUntilReq{} }
func (m *SaltUntilReq) String() string { return proto.CompactTextString(m) }
func (*SaltUntilReq) ProtoMessage()    {}
func (*SaltUntilReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{18}
}
func (m *SaltUntilReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SaltUntilReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SaltUntilReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SaltUntilReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SaltUntilReq.Merge(m, src)
}
func (m *SaltUntilReq) XXX_Size() int {
	return m.Size()
}
func (m *SaltUntilReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SaltUntilReq.DiscardUnknown(m)
}

var xxx_messageInfo_SaltUntilReq proto.InternalMessageInfo

func (m *SaltUntilReq) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *SaltUntilReq) GetSalt() int64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

type SaltsReq struct {
	MsgId  int64 `protobuf:"varint,1,opt,name=msg_id,json=msgId,proto3" json:"msg_id,omitempty"`
	AuthId int64 `protobuf:"varint,2,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Num    int32 `protobuf:"varint,3,opt,name=num,proto3" json:"num,omitempty"`
}

func (m *SaltsReq) Reset()         { *m = SaltsReq{} }
func (m *SaltsReq) String() string { return proto.CompactTextString(m) }
func (*SaltsReq) ProtoMessage()    {}
func (*SaltsReq) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{19}
}
func (m *SaltsReq) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SaltsReq) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SaltsReq.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SaltsReq) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SaltsReq.Merge(m, src)
}
func (m *SaltsReq) XXX_Size() int {
	return m.Size()
}
func (m *SaltsReq) XXX_DiscardUnknown() {
	xxx_messageInfo_SaltsReq.DiscardUnknown(m)
}

var xxx_messageInfo_SaltsReq proto.InternalMessageInfo

func (m *SaltsReq) GetMsgId() int64 {
	if m != nil {
		return m.MsgId
	}
	return 0
}

func (m *SaltsReq) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *SaltsReq) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

type SaltItem struct {
	Salt  int64 `protobuf:"varint,1,opt,name=salt,proto3" json:"salt,omitempty"`
	Until int32 `protobuf:"varint,2,opt,name=until,proto3" json:"until,omitempty"`
}

func (m *SaltItem) Reset()         { *m = SaltItem{} }
func (m *SaltItem) String() string { return proto.CompactTextString(m) }
func (*SaltItem) ProtoMessage()    {}
func (*SaltItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{20}
}
func (m *SaltItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SaltItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SaltItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SaltItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SaltItem.Merge(m, src)
}
func (m *SaltItem) XXX_Size() int {
	return m.Size()
}
func (m *SaltItem) XXX_DiscardUnknown() {
	xxx_messageInfo_SaltItem.DiscardUnknown(m)
}

var xxx_messageInfo_SaltItem proto.InternalMessageInfo

func (m *SaltItem) GetSalt() int64 {
	if m != nil {
		return m.Salt
	}
	return 0
}

func (m *SaltItem) GetUntil() int32 {
	if m != nil {
		return m.Until
	}
	return 0
}

type SeqRequest struct {
	UserId    int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ChannelId int32 `protobuf:"varint,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	AuthId    int64 `protobuf:"varint,3,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Flag      int32 `protobuf:"varint,4,opt,name=flag,proto3" json:"flag,omitempty"`
}

func (m *SeqRequest) Reset()         { *m = SeqRequest{} }
func (m *SeqRequest) String() string { return proto.CompactTextString(m) }
func (*SeqRequest) ProtoMessage()    {}
func (*SeqRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{21}
}
func (m *SeqRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SeqRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SeqRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SeqRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SeqRequest.Merge(m, src)
}
func (m *SeqRequest) XXX_Size() int {
	return m.Size()
}
func (m *SeqRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_SeqRequest.DiscardUnknown(m)
}

var xxx_messageInfo_SeqRequest proto.InternalMessageInfo

func (m *SeqRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *SeqRequest) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *SeqRequest) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *SeqRequest) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

type DialogState struct {
	Pts                 int32 `protobuf:"varint,1,opt,name=pts,proto3" json:"pts,omitempty"`
	UnreadCount         int32 `protobuf:"varint,2,opt,name=unread_count,json=unreadCount,proto3" json:"unread_count,omitempty"`
	TopMessage          int32 `protobuf:"varint,3,opt,name=top_message,json=topMessage,proto3" json:"top_message,omitempty"`
	ReadInboxMaxId      int32 `protobuf:"varint,4,opt,name=read_inbox_max_id,json=readInboxMaxId,proto3" json:"read_inbox_max_id,omitempty"`
	ReadOutboxMaxId     int32 `protobuf:"varint,5,opt,name=read_outbox_max_id,json=readOutboxMaxId,proto3" json:"read_outbox_max_id,omitempty"`
	UnreadMentionsCount int32 `protobuf:"varint,6,opt,name=unread_mentions_count,json=unreadMentionsCount,proto3" json:"unread_mentions_count,omitempty"`
}

func (m *DialogState) Reset()         { *m = DialogState{} }
func (m *DialogState) String() string { return proto.CompactTextString(m) }
func (*DialogState) ProtoMessage()    {}
func (*DialogState) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{22}
}
func (m *DialogState) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DialogState) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DialogState.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DialogState) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DialogState.Merge(m, src)
}
func (m *DialogState) XXX_Size() int {
	return m.Size()
}
func (m *DialogState) XXX_DiscardUnknown() {
	xxx_messageInfo_DialogState.DiscardUnknown(m)
}

var xxx_messageInfo_DialogState proto.InternalMessageInfo

func (m *DialogState) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

func (m *DialogState) GetUnreadCount() int32 {
	if m != nil {
		return m.UnreadCount
	}
	return 0
}

func (m *DialogState) GetTopMessage() int32 {
	if m != nil {
		return m.TopMessage
	}
	return 0
}

func (m *DialogState) GetReadInboxMaxId() int32 {
	if m != nil {
		return m.ReadInboxMaxId
	}
	return 0
}

func (m *DialogState) GetReadOutboxMaxId() int32 {
	if m != nil {
		return m.ReadOutboxMaxId
	}
	return 0
}

func (m *DialogState) GetUnreadMentionsCount() int32 {
	if m != nil {
		return m.UnreadMentionsCount
	}
	return 0
}

type ReceiveItem struct {
	UserId          int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId          int64 `protobuf:"varint,2,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	ChannelId       int32 `protobuf:"varint,3,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
	RecvUpdateMaxId int32 `protobuf:"varint,4,opt,name=recv_update_max_id,json=recvUpdateMaxId,proto3" json:"recv_update_max_id,omitempty"`
	Flag            int32 `protobuf:"varint,5,opt,name=flag,proto3" json:"flag,omitempty"`
	IsDel           bool  `protobuf:"varint,6,opt,name=is_del,json=isDel,proto3" json:"is_del,omitempty"`
}

func (m *ReceiveItem) Reset()         { *m = ReceiveItem{} }
func (m *ReceiveItem) String() string { return proto.CompactTextString(m) }
func (*ReceiveItem) ProtoMessage()    {}
func (*ReceiveItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{23}
}
func (m *ReceiveItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ReceiveItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ReceiveItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ReceiveItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ReceiveItem.Merge(m, src)
}
func (m *ReceiveItem) XXX_Size() int {
	return m.Size()
}
func (m *ReceiveItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ReceiveItem.DiscardUnknown(m)
}

var xxx_messageInfo_ReceiveItem proto.InternalMessageInfo

func (m *ReceiveItem) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ReceiveItem) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *ReceiveItem) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

func (m *ReceiveItem) GetRecvUpdateMaxId() int32 {
	if m != nil {
		return m.RecvUpdateMaxId
	}
	return 0
}

func (m *ReceiveItem) GetFlag() int32 {
	if m != nil {
		return m.Flag
	}
	return 0
}

func (m *ReceiveItem) GetIsDel() bool {
	if m != nil {
		return m.IsDel
	}
	return false
}

type ChatPtsItem struct {
	ChatId int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId int64 `protobuf:"varint,3,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Pts    int32 `protobuf:"varint,4,opt,name=pts,proto3" json:"pts,omitempty"`
}

func (m *ChatPtsItem) Reset()         { *m = ChatPtsItem{} }
func (m *ChatPtsItem) String() string { return proto.CompactTextString(m) }
func (*ChatPtsItem) ProtoMessage()    {}
func (*ChatPtsItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{24}
}
func (m *ChatPtsItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatPtsItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatPtsItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatPtsItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatPtsItem.Merge(m, src)
}
func (m *ChatPtsItem) XXX_Size() int {
	return m.Size()
}
func (m *ChatPtsItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatPtsItem.DiscardUnknown(m)
}

var xxx_messageInfo_ChatPtsItem proto.InternalMessageInfo

func (m *ChatPtsItem) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ChatPtsItem) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ChatPtsItem) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *ChatPtsItem) GetPts() int32 {
	if m != nil {
		return m.Pts
	}
	return 0
}

type MigrateToMegagroupItem struct {
	ChatId    int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	ChannelId int32 `protobuf:"varint,2,opt,name=channel_id,json=channelId,proto3" json:"channel_id,omitempty"`
}

func (m *MigrateToMegagroupItem) Reset()         { *m = MigrateToMegagroupItem{} }
func (m *MigrateToMegagroupItem) String() string { return proto.CompactTextString(m) }
func (*MigrateToMegagroupItem) ProtoMessage()    {}
func (*MigrateToMegagroupItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{25}
}
func (m *MigrateToMegagroupItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MigrateToMegagroupItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MigrateToMegagroupItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MigrateToMegagroupItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MigrateToMegagroupItem.Merge(m, src)
}
func (m *MigrateToMegagroupItem) XXX_Size() int {
	return m.Size()
}
func (m *MigrateToMegagroupItem) XXX_DiscardUnknown() {
	xxx_messageInfo_MigrateToMegagroupItem.DiscardUnknown(m)
}

var xxx_messageInfo_MigrateToMegagroupItem proto.InternalMessageInfo

func (m *MigrateToMegagroupItem) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *MigrateToMegagroupItem) GetChannelId() int32 {
	if m != nil {
		return m.ChannelId
	}
	return 0
}

// 用户从一个Gw上线，或者离线，或者发某个GW CLOSE了的消息，某个GW上线了的消息
// 某个GW上线，或者离线，都要清除这个GW上的所有用户在线信息
type UserConnectItem struct {
	GwServerId int32 `protobuf:"varint,1,opt,name=gw_server_id,json=gwServerId,proto3" json:"gw_server_id,omitempty"`
	UserId     int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthId     int64 `protobuf:"varint,3,opt,name=auth_id,json=authId,proto3" json:"auth_id,omitempty"`
	Connect    bool  `protobuf:"varint,4,opt,name=connect,proto3" json:"connect,omitempty"`
}

func (m *UserConnectItem) Reset()         { *m = UserConnectItem{} }
func (m *UserConnectItem) String() string { return proto.CompactTextString(m) }
func (*UserConnectItem) ProtoMessage()    {}
func (*UserConnectItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{26}
}
func (m *UserConnectItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserConnectItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserConnectItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserConnectItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserConnectItem.Merge(m, src)
}
func (m *UserConnectItem) XXX_Size() int {
	return m.Size()
}
func (m *UserConnectItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UserConnectItem.DiscardUnknown(m)
}

var xxx_messageInfo_UserConnectItem proto.InternalMessageInfo

func (m *UserConnectItem) GetGwServerId() int32 {
	if m != nil {
		return m.GwServerId
	}
	return 0
}

func (m *UserConnectItem) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserConnectItem) GetAuthId() int64 {
	if m != nil {
		return m.AuthId
	}
	return 0
}

func (m *UserConnectItem) GetConnect() bool {
	if m != nil {
		return m.Connect
	}
	return false
}

type UserConns struct {
	UserId int32    `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Conns  []string `protobuf:"bytes,2,rep,name=conns,proto3" json:"conns,omitempty"`
}

func (m *UserConns) Reset()         { *m = UserConns{} }
func (m *UserConns) String() string { return proto.CompactTextString(m) }
func (*UserConns) ProtoMessage()    {}
func (*UserConns) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{27}
}
func (m *UserConns) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserConns) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserConns.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserConns) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserConns.Merge(m, src)
}
func (m *UserConns) XXX_Size() int {
	return m.Size()
}
func (m *UserConns) XXX_DiscardUnknown() {
	xxx_messageInfo_UserConns.DiscardUnknown(m)
}

var xxx_messageInfo_UserConns proto.InternalMessageInfo

func (m *UserConns) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserConns) GetConns() []string {
	if m != nil {
		return m.Conns
	}
	return nil
}

type UserConnsList struct {
	UserConns []*UserConns `protobuf:"bytes,1,rep,name=user_conns,json=userConns,proto3" json:"user_conns,omitempty"`
}

func (m *UserConnsList) Reset()         { *m = UserConnsList{} }
func (m *UserConnsList) String() string { return proto.CompactTextString(m) }
func (*UserConnsList) ProtoMessage()    {}
func (*UserConnsList) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{28}
}
func (m *UserConnsList) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserConnsList) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserConnsList.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserConnsList) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserConnsList.Merge(m, src)
}
func (m *UserConnsList) XXX_Size() int {
	return m.Size()
}
func (m *UserConnsList) XXX_DiscardUnknown() {
	xxx_messageInfo_UserConnsList.DiscardUnknown(m)
}

var xxx_messageInfo_UserConnsList proto.InternalMessageInfo

func (m *UserConnsList) GetUserConns() []*UserConns {
	if m != nil {
		return m.UserConns
	}
	return nil
}

type UsersRequest struct {
	UserId   int32      `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	UidList  *Int32List `protobuf:"bytes,2,opt,name=uid_list,json=uidList,proto3" json:"uid_list,omitempty"`
	IsSimple bool       `protobuf:"varint,3,opt,name=is_simple,json=isSimple,proto3" json:"is_simple,omitempty"`
}

func (m *UsersRequest) Reset()         { *m = UsersRequest{} }
func (m *UsersRequest) String() string { return proto.CompactTextString(m) }
func (*UsersRequest) ProtoMessage()    {}
func (*UsersRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{29}
}
func (m *UsersRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UsersRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UsersRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UsersRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UsersRequest.Merge(m, src)
}
func (m *UsersRequest) XXX_Size() int {
	return m.Size()
}
func (m *UsersRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UsersRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UsersRequest proto.InternalMessageInfo

func (m *UsersRequest) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UsersRequest) GetUidList() *Int32List {
	if m != nil {
		return m.UidList
	}
	return nil
}

func (m *UsersRequest) GetIsSimple() bool {
	if m != nil {
		return m.IsSimple
	}
	return false
}

type MtprotoUsers struct {
	Users []*User `protobuf:"bytes,1,rep,name=users,proto3" json:"users,omitempty"`
}

func (m *MtprotoUsers) Reset()         { *m = MtprotoUsers{} }
func (m *MtprotoUsers) String() string { return proto.CompactTextString(m) }
func (*MtprotoUsers) ProtoMessage()    {}
func (*MtprotoUsers) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{30}
}
func (m *MtprotoUsers) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MtprotoUsers) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MtprotoUsers.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MtprotoUsers) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MtprotoUsers.Merge(m, src)
}
func (m *MtprotoUsers) XXX_Size() int {
	return m.Size()
}
func (m *MtprotoUsers) XXX_DiscardUnknown() {
	xxx_messageInfo_MtprotoUsers.DiscardUnknown(m)
}

var xxx_messageInfo_MtprotoUsers proto.InternalMessageInfo

func (m *MtprotoUsers) GetUsers() []*User {
	if m != nil {
		return m.Users
	}
	return nil
}

type UserPrivacyItem struct {
	UserId  int32 `protobuf:"varint,1,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyType int32 `protobuf:"varint,2,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
}

func (m *UserPrivacyItem) Reset()         { *m = UserPrivacyItem{} }
func (m *UserPrivacyItem) String() string { return proto.CompactTextString(m) }
func (*UserPrivacyItem) ProtoMessage()    {}
func (*UserPrivacyItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{31}
}
func (m *UserPrivacyItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *UserPrivacyItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_UserPrivacyItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *UserPrivacyItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UserPrivacyItem.Merge(m, src)
}
func (m *UserPrivacyItem) XXX_Size() int {
	return m.Size()
}
func (m *UserPrivacyItem) XXX_DiscardUnknown() {
	xxx_messageInfo_UserPrivacyItem.DiscardUnknown(m)
}

var xxx_messageInfo_UserPrivacyItem proto.InternalMessageInfo

func (m *UserPrivacyItem) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *UserPrivacyItem) GetKeyType() int32 {
	if m != nil {
		return m.KeyType
	}
	return 0
}

type ChatRow struct {
	Id                 int32  `protobuf:"varint,1,opt,name=id,proto3" json:"id,omitempty"`
	AccessHash         int64  `protobuf:"varint,2,opt,name=access_hash,json=accessHash,proto3" json:"access_hash,omitempty"`
	Democracy          bool   `protobuf:"varint,3,opt,name=democracy,proto3" json:"democracy,omitempty"`
	CreatorId          int32  `protobuf:"varint,4,opt,name=creator_id,json=creatorId,proto3" json:"creator_id,omitempty"`
	PinnedMsgId        int32  `protobuf:"varint,5,opt,name=pinned_msg_id,json=pinnedMsgId,proto3" json:"pinned_msg_id,omitempty"`
	About              string `protobuf:"bytes,6,opt,name=about,proto3" json:"about,omitempty"`
	Title              string `protobuf:"bytes,7,opt,name=title,proto3" json:"title,omitempty"`
	Type               int32  `protobuf:"varint,8,opt,name=type,proto3" json:"type,omitempty"`
	PhotoId            int64  `protobuf:"varint,9,opt,name=photo_id,json=photoId,proto3" json:"photo_id,omitempty"`
	AdminsEnabled      bool   `protobuf:"varint,10,opt,name=admins_enabled,json=adminsEnabled,proto3" json:"admins_enabled,omitempty"`
	MigratedFromChatId int32  `protobuf:"varint,11,opt,name=migrated_from_chat_id,json=migratedFromChatId,proto3" json:"migrated_from_chat_id,omitempty"`
	MigratedFromMaxId  int32  `protobuf:"varint,12,opt,name=migrated_from_max_id,json=migratedFromMaxId,proto3" json:"migrated_from_max_id,omitempty"`
	MigratedTo         int32  `protobuf:"varint,13,opt,name=migrated_to,json=migratedTo,proto3" json:"migrated_to,omitempty"`
	Username           string `protobuf:"bytes,14,opt,name=username,proto3" json:"username,omitempty"`
	HiddenPrehistory   bool   `protobuf:"varint,15,opt,name=hidden_prehistory,json=hiddenPrehistory,proto3" json:"hidden_prehistory,omitempty"`
	Signatures         bool   `protobuf:"varint,16,opt,name=signatures,proto3" json:"signatures,omitempty"`
	Deactivated        bool   `protobuf:"varint,17,opt,name=deactivated,proto3" json:"deactivated,omitempty"`
	Verified           bool   `protobuf:"varint,18,opt,name=verified,proto3" json:"verified,omitempty"`
	RightsMask         int32  `protobuf:"varint,19,opt,name=rights_mask,json=rightsMask,proto3" json:"rights_mask,omitempty"`
	Version            int32  `protobuf:"varint,20,opt,name=version,proto3" json:"version,omitempty"`
	StickerSetId       int64  `protobuf:"varint,21,opt,name=sticker_set_id,json=stickerSetId,proto3" json:"sticker_set_id,omitempty"`
	AddTime            int32  `protobuf:"varint,22,opt,name=add_time,json=addTime,proto3" json:"add_time,omitempty"`
}

func (m *ChatRow) Reset()         { *m = ChatRow{} }
func (m *ChatRow) String() string { return proto.CompactTextString(m) }
func (*ChatRow) ProtoMessage()    {}
func (*ChatRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{32}
}
func (m *ChatRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatRow.Merge(m, src)
}
func (m *ChatRow) XXX_Size() int {
	return m.Size()
}
func (m *ChatRow) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatRow.DiscardUnknown(m)
}

var xxx_messageInfo_ChatRow proto.InternalMessageInfo

func (m *ChatRow) GetId() int32 {
	if m != nil {
		return m.Id
	}
	return 0
}

func (m *ChatRow) GetAccessHash() int64 {
	if m != nil {
		return m.AccessHash
	}
	return 0
}

func (m *ChatRow) GetDemocracy() bool {
	if m != nil {
		return m.Democracy
	}
	return false
}

func (m *ChatRow) GetCreatorId() int32 {
	if m != nil {
		return m.CreatorId
	}
	return 0
}

func (m *ChatRow) GetPinnedMsgId() int32 {
	if m != nil {
		return m.PinnedMsgId
	}
	return 0
}

func (m *ChatRow) GetAbout() string {
	if m != nil {
		return m.About
	}
	return ""
}

func (m *ChatRow) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *ChatRow) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ChatRow) GetPhotoId() int64 {
	if m != nil {
		return m.PhotoId
	}
	return 0
}

func (m *ChatRow) GetAdminsEnabled() bool {
	if m != nil {
		return m.AdminsEnabled
	}
	return false
}

func (m *ChatRow) GetMigratedFromChatId() int32 {
	if m != nil {
		return m.MigratedFromChatId
	}
	return 0
}

func (m *ChatRow) GetMigratedFromMaxId() int32 {
	if m != nil {
		return m.MigratedFromMaxId
	}
	return 0
}

func (m *ChatRow) GetMigratedTo() int32 {
	if m != nil {
		return m.MigratedTo
	}
	return 0
}

func (m *ChatRow) GetUsername() string {
	if m != nil {
		return m.Username
	}
	return ""
}

func (m *ChatRow) GetHiddenPrehistory() bool {
	if m != nil {
		return m.HiddenPrehistory
	}
	return false
}

func (m *ChatRow) GetSignatures() bool {
	if m != nil {
		return m.Signatures
	}
	return false
}

func (m *ChatRow) GetDeactivated() bool {
	if m != nil {
		return m.Deactivated
	}
	return false
}

func (m *ChatRow) GetVerified() bool {
	if m != nil {
		return m.Verified
	}
	return false
}

func (m *ChatRow) GetRightsMask() int32 {
	if m != nil {
		return m.RightsMask
	}
	return 0
}

func (m *ChatRow) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *ChatRow) GetStickerSetId() int64 {
	if m != nil {
		return m.StickerSetId
	}
	return 0
}

func (m *ChatRow) GetAddTime() int32 {
	if m != nil {
		return m.AddTime
	}
	return 0
}

type ChatRows struct {
	Rows []*ChatRow `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *ChatRows) Reset()         { *m = ChatRows{} }
func (m *ChatRows) String() string { return proto.CompactTextString(m) }
func (*ChatRows) ProtoMessage()    {}
func (*ChatRows) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{33}
}
func (m *ChatRows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ChatRows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ChatRows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ChatRows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ChatRows.Merge(m, src)
}
func (m *ChatRows) XXX_Size() int {
	return m.Size()
}
func (m *ChatRows) XXX_DiscardUnknown() {
	xxx_messageInfo_ChatRows.DiscardUnknown(m)
}

var xxx_messageInfo_ChatRows proto.InternalMessageInfo

func (m *ChatRows) GetRows() []*ChatRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

type ParticipantItem struct {
	ChatId int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
}

func (m *ParticipantItem) Reset()         { *m = ParticipantItem{} }
func (m *ParticipantItem) String() string { return proto.CompactTextString(m) }
func (*ParticipantItem) ProtoMessage()    {}
func (*ParticipantItem) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{34}
}
func (m *ParticipantItem) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParticipantItem) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParticipantItem.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParticipantItem) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParticipantItem.Merge(m, src)
}
func (m *ParticipantItem) XXX_Size() int {
	return m.Size()
}
func (m *ParticipantItem) XXX_DiscardUnknown() {
	xxx_messageInfo_ParticipantItem.DiscardUnknown(m)
}

var xxx_messageInfo_ParticipantItem proto.InternalMessageInfo

func (m *ParticipantItem) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ParticipantItem) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

type ParticipantItem2 struct {
	ChatId int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	IsDel  bool  `protobuf:"varint,3,opt,name=is_del,json=isDel,proto3" json:"is_del,omitempty"`
}

func (m *ParticipantItem2) Reset()         { *m = ParticipantItem2{} }
func (m *ParticipantItem2) String() string { return proto.CompactTextString(m) }
func (*ParticipantItem2) ProtoMessage()    {}
func (*ParticipantItem2) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{35}
}
func (m *ParticipantItem2) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParticipantItem2) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParticipantItem2.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParticipantItem2) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParticipantItem2.Merge(m, src)
}
func (m *ParticipantItem2) XXX_Size() int {
	return m.Size()
}
func (m *ParticipantItem2) XXX_DiscardUnknown() {
	xxx_messageInfo_ParticipantItem2.DiscardUnknown(m)
}

var xxx_messageInfo_ParticipantItem2 proto.InternalMessageInfo

func (m *ParticipantItem2) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ParticipantItem2) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ParticipantItem2) GetIsDel() bool {
	if m != nil {
		return m.IsDel
	}
	return false
}

type ParticipantRow struct {
	ChatId         int32 `protobuf:"varint,1,opt,name=chat_id,json=chatId,proto3" json:"chat_id,omitempty"`
	UserId         int32 `protobuf:"varint,2,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	Type           int32 `protobuf:"varint,3,opt,name=type,proto3" json:"type,omitempty"`
	Bot            bool  `protobuf:"varint,4,opt,name=bot,proto3" json:"bot,omitempty"`
	InviterId      int32 `protobuf:"varint,5,opt,name=inviter_id,json=inviterId,proto3" json:"inviter_id,omitempty"`
	RightsMask     int32 `protobuf:"varint,6,opt,name=rights_mask,json=rightsMask,proto3" json:"rights_mask,omitempty"`
	UntilDate      int32 `protobuf:"varint,7,opt,name=until_date,json=untilDate,proto3" json:"until_date,omitempty"`
	Kicked         bool  `protobuf:"varint,8,opt,name=kicked,proto3" json:"kicked,omitempty"`
	AvailableMinId int32 `protobuf:"varint,9,opt,name=available_min_id,json=availableMinId,proto3" json:"available_min_id,omitempty"`
	PromotedBy     int32 `protobuf:"varint,10,opt,name=promoted_by,json=promotedBy,proto3" json:"promoted_by,omitempty"`
	AddTime        int32 `protobuf:"varint,11,opt,name=add_time,json=addTime,proto3" json:"add_time,omitempty"`
	UpdateTime     int32 `protobuf:"varint,12,opt,name=update_time,json=updateTime,proto3" json:"update_time,omitempty"`
}

func (m *ParticipantRow) Reset()         { *m = ParticipantRow{} }
func (m *ParticipantRow) String() string { return proto.CompactTextString(m) }
func (*ParticipantRow) ProtoMessage()    {}
func (*ParticipantRow) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{36}
}
func (m *ParticipantRow) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParticipantRow) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParticipantRow.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParticipantRow) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParticipantRow.Merge(m, src)
}
func (m *ParticipantRow) XXX_Size() int {
	return m.Size()
}
func (m *ParticipantRow) XXX_DiscardUnknown() {
	xxx_messageInfo_ParticipantRow.DiscardUnknown(m)
}

var xxx_messageInfo_ParticipantRow proto.InternalMessageInfo

func (m *ParticipantRow) GetChatId() int32 {
	if m != nil {
		return m.ChatId
	}
	return 0
}

func (m *ParticipantRow) GetUserId() int32 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *ParticipantRow) GetType() int32 {
	if m != nil {
		return m.Type
	}
	return 0
}

func (m *ParticipantRow) GetBot() bool {
	if m != nil {
		return m.Bot
	}
	return false
}

func (m *ParticipantRow) GetInviterId() int32 {
	if m != nil {
		return m.InviterId
	}
	return 0
}

func (m *ParticipantRow) GetRightsMask() int32 {
	if m != nil {
		return m.RightsMask
	}
	return 0
}

func (m *ParticipantRow) GetUntilDate() int32 {
	if m != nil {
		return m.UntilDate
	}
	return 0
}

func (m *ParticipantRow) GetKicked() bool {
	if m != nil {
		return m.Kicked
	}
	return false
}

func (m *ParticipantRow) GetAvailableMinId() int32 {
	if m != nil {
		return m.AvailableMinId
	}
	return 0
}

func (m *ParticipantRow) GetPromotedBy() int32 {
	if m != nil {
		return m.PromotedBy
	}
	return 0
}

func (m *ParticipantRow) GetAddTime() int32 {
	if m != nil {
		return m.AddTime
	}
	return 0
}

func (m *ParticipantRow) GetUpdateTime() int32 {
	if m != nil {
		return m.UpdateTime
	}
	return 0
}

type ParticipantRows struct {
	Rows []*ParticipantRow `protobuf:"bytes,1,rep,name=rows,proto3" json:"rows,omitempty"`
}

func (m *ParticipantRows) Reset()         { *m = ParticipantRows{} }
func (m *ParticipantRows) String() string { return proto.CompactTextString(m) }
func (*ParticipantRows) ProtoMessage()    {}
func (*ParticipantRows) Descriptor() ([]byte, []int) {
	return fileDescriptor_cd22456f3fa912cc, []int{37}
}
func (m *ParticipantRows) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ParticipantRows) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ParticipantRows.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ParticipantRows) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ParticipantRows.Merge(m, src)
}
func (m *ParticipantRows) XXX_Size() int {
	return m.Size()
}
func (m *ParticipantRows) XXX_DiscardUnknown() {
	xxx_messageInfo_ParticipantRows.DiscardUnknown(m)
}

var xxx_messageInfo_ParticipantRows proto.InternalMessageInfo

func (m *ParticipantRows) GetRows() []*ParticipantRow {
	if m != nil {
		return m.Rows
	}
	return nil
}

func init() {
	proto.RegisterType((*AuthKeyInfo)(nil), "mtproto.AuthKeyInfo")
	proto.RegisterType((*ChangeAuthKey)(nil), "mtproto.ChangeAuthKey")
	proto.RegisterType((*UserPresence)(nil), "mtproto.UserPresence")
	proto.RegisterType((*UserState)(nil), "mtproto.UserState")
	proto.RegisterType((*UserUnreadCount)(nil), "mtproto.UserUnreadCount")
	proto.RegisterType((*UserUnreadCountList)(nil), "mtproto.UserUnreadCountList")
	proto.RegisterType((*UserDialog)(nil), "mtproto.UserDialog")
	proto.RegisterType((*DialogRowPeer)(nil), "mtproto.DialogRowPeer")
	proto.RegisterType((*ReadHistory)(nil), "mtproto.ReadHistory")
	proto.RegisterType((*ChannelReadHistory)(nil), "mtproto.ChannelReadHistory")
	proto.RegisterType((*LastSeenAt)(nil), "mtproto.LastSeenAt")
	proto.RegisterType((*Int32)(nil), "mtproto.Int32")
	proto.RegisterType((*Int64)(nil), "mtproto.Int64")
	proto.RegisterType((*Result)(nil), "mtproto.Result")
	proto.RegisterType((*Int32List)(nil), "mtproto.Int32List")
	proto.RegisterType((*PhotoFileUnit)(nil), "mtproto.PhotoFileUnit")
	proto.RegisterType((*DocumentFileUnit)(nil), "mtproto.DocumentFileUnit")
	proto.RegisterType((*PhotoSizeList)(nil), "mtproto.PhotoSizeList")
	proto.RegisterType((*SaltUntilReq)(nil), "mtproto.SaltUntilReq")
	proto.RegisterType((*SaltsReq)(nil), "mtproto.SaltsReq")
	proto.RegisterType((*SaltItem)(nil), "mtproto.SaltItem")
	proto.RegisterType((*SeqRequest)(nil), "mtproto.SeqRequest")
	proto.RegisterType((*DialogState)(nil), "mtproto.DialogState")
	proto.RegisterType((*ReceiveItem)(nil), "mtproto.ReceiveItem")
	proto.RegisterType((*ChatPtsItem)(nil), "mtproto.ChatPtsItem")
	proto.RegisterType((*MigrateToMegagroupItem)(nil), "mtproto.MigrateToMegagroupItem")
	proto.RegisterType((*UserConnectItem)(nil), "mtproto.UserConnectItem")
	proto.RegisterType((*UserConns)(nil), "mtproto.UserConns")
	proto.RegisterType((*UserConnsList)(nil), "mtproto.UserConnsList")
	proto.RegisterType((*UsersRequest)(nil), "mtproto.UsersRequest")
	proto.RegisterType((*MtprotoUsers)(nil), "mtproto.MtprotoUsers")
	proto.RegisterType((*UserPrivacyItem)(nil), "mtproto.UserPrivacyItem")
	proto.RegisterType((*ChatRow)(nil), "mtproto.ChatRow")
	proto.RegisterType((*ChatRows)(nil), "mtproto.ChatRows")
	proto.RegisterType((*ParticipantItem)(nil), "mtproto.ParticipantItem")
	proto.RegisterType((*ParticipantItem2)(nil), "mtproto.ParticipantItem2")
	proto.RegisterType((*ParticipantRow)(nil), "mtproto.ParticipantRow")
	proto.RegisterType((*ParticipantRows)(nil), "mtproto.ParticipantRows")
}

func init() { proto.RegisterFile("cache_service.proto", fileDescriptor_cd22456f3fa912cc) }

var fileDescriptor_cd22456f3fa912cc = []byte{
	// 2724 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x18, 0xdb, 0x6e, 0x1b, 0xc7,
	0x95, 0x14, 0xcd, 0xdb, 0x21, 0x45, 0x49, 0x23, 0x59, 0xa2, 0xe4, 0x44, 0x56, 0x37, 0x29, 0xa0,
	0x36, 0xad, 0xe3, 0x28, 0x6e, 0x1a, 0xc7, 0x4e, 0x1a, 0x4b, 0x8a, 0x65, 0x22, 0x51, 0xa3, 0xae,
	0xac, 0x3e, 0xa4, 0x40, 0x16, 0xab, 0xdd, 0x11, 0x39, 0xd5, 0x72, 0x97, 0xda, 0x99, 0x95, 0xcd,
	0xa0, 0x40, 0xbf, 0xa0, 0x40, 0x81, 0xa2, 0x6f, 0xfd, 0x8e, 0x02, 0xfd, 0x80, 0x02, 0x7d, 0xcc,
	0x63, 0x1f, 0x0b, 0x07, 0xe8, 0x6b, 0x7f, 0xa1, 0x98, 0x33, 0xb3, 0x37, 0x72, 0xa9, 0xc8, 0x42,
	0xde, 0x76, 0xce, 0x6d, 0xce, 0x99, 0x73, 0xdd, 0x03, 0xcb, 0x8e, 0xed, 0x0c, 0xa8, 0xc5, 0x69,
	0x78, 0xc9, 0x1c, 0x7a, 0x6f, 0x14, 0x06, 0x22, 0x20, 0xf5, 0xa1, 0xc0, 0x8f, 0x8d, 0x15, 0xee,
	0x0c, 0xe8, 0xd0, 0xbe, 0x27, 0xbc, 0x7b, 0x7c, 0xec, 0x3b, 0x0a, 0xbd, 0xf1, 0x46, 0x1e, 0x9a,
	0x67, 0xde, 0x58, 0x4f, 0xb1, 0x22, 0xb4, 0x7d, 0x3e, 0x0a, 0x42, 0xa1, 0x50, 0xc6, 0x57, 0xd0,
	0x7a, 0x12, 0x89, 0xc1, 0xe7, 0x74, 0xdc, 0xf3, 0xcf, 0x02, 0xb2, 0x06, 0xf5, 0x88, 0xd3, 0xd0,
	0x62, 0x6e, 0xb7, 0xbc, 0x55, 0xde, 0xae, 0x9a, 0x35, 0x79, 0xec, 0xb9, 0x12, 0x61, 0x47, 0x62,
	0x20, 0x11, 0x73, 0x5b, 0xe5, 0xed, 0x8a, 0x59, 0x93, 0xc7, 0x9e, 0x4b, 0xd6, 0xa1, 0x81, 0x88,
	0x73, 0x3a, 0xee, 0x56, 0xb6, 0xca, 0xdb, 0x6d, 0x13, 0x09, 0x3f, 0xa7, 0x63, 0xe3, 0x2b, 0x98,
	0xdf, 0x1b, 0xd8, 0x7e, 0x9f, 0xea, 0x1b, 0x6e, 0x20, 0x7d, 0x0d, 0xea, 0x81, 0xe7, 0x5a, 0x11,
	0x73, 0x51, 0x78, 0xd5, 0xac, 0x05, 0x9e, 0x7b, 0xc2, 0x5c, 0xe3, 0x0f, 0xd0, 0x3e, 0xe1, 0x34,
	0x3c, 0x0a, 0x29, 0xa7, 0xbe, 0x43, 0x6f, 0x20, 0xba, 0x0b, 0xf5, 0xe0, 0xec, 0xcc, 0x63, 0x3e,
	0x45, 0xd1, 0x0d, 0x33, 0x3e, 0x92, 0x2d, 0x68, 0x7b, 0x36, 0x17, 0x16, 0xa7, 0xd4, 0xb7, 0xd8,
	0xa8, 0x7b, 0x6b, 0xab, 0xbc, 0xdd, 0x34, 0x41, 0xc2, 0x8e, 0x29, 0xf5, 0x7b, 0x23, 0xe3, 0x6b,
	0x68, 0xca, 0xdb, 0x8f, 0x85, 0x2d, 0xae, 0xb8, 0x7a, 0x11, 0x2a, 0x23, 0xc1, 0xf1, 0xda, 0xaa,
	0x29, 0x3f, 0x25, 0xe4, 0x42, 0x70, 0x6d, 0x8a, 0xfc, 0x24, 0x2b, 0x50, 0xbd, 0x88, 0x68, 0x44,
	0xf1, 0x92, 0xaa, 0xa9, 0x0e, 0xc6, 0x19, 0x2c, 0x48, 0xf9, 0x27, 0x7e, 0x48, 0x6d, 0x77, 0x2f,
	0x88, 0x7c, 0x71, 0x03, 0x03, 0x7f, 0x04, 0xed, 0x08, 0x05, 0x58, 0x8e, 0x94, 0xa0, 0x6f, 0x6d,
	0x45, 0xa9, 0x50, 0xe3, 0x08, 0x96, 0x27, 0xee, 0xf9, 0x82, 0x71, 0x41, 0x1e, 0x82, 0xa6, 0xb2,
	0x3c, 0xc6, 0x45, 0xb7, 0xbc, 0x55, 0xd9, 0x6e, 0xed, 0x74, 0xef, 0xe9, 0x10, 0xbc, 0x37, 0xc1,
	0x62, 0x82, 0x22, 0x96, 0xac, 0xc6, 0x5f, 0x6f, 0x01, 0x48, 0xfc, 0x3e, 0xb3, 0xbd, 0xa0, 0x3f,
	0x5b, 0xeb, 0x3b, 0xd0, 0x1c, 0x51, 0x1a, 0x5a, 0x62, 0x3c, 0xa2, 0xfa, 0x85, 0x1a, 0x12, 0xf0,
	0x7c, 0x3c, 0xc2, 0x17, 0x45, 0x64, 0xea, 0x75, 0x79, 0xec, 0xb9, 0xe4, 0x2e, 0xb4, 0x44, 0x30,
	0xb2, 0x86, 0x94, 0x73, 0xbb, 0x1f, 0xbf, 0x19, 0x88, 0x60, 0x74, 0xa8, 0x20, 0x64, 0x07, 0x56,
	0x99, 0xef, 0x84, 0x16, 0x2a, 0xcf, 0xfc, 0xd3, 0xe0, 0xa5, 0x35, 0xb4, 0x5f, 0x4a, 0x41, 0x55,
	0xa4, 0x25, 0x12, 0x6b, 0x52, 0xdb, 0xed, 0x49, 0xdc, 0xa1, 0xfd, 0xb2, 0xe7, 0x92, 0x9f, 0xc2,
	0x12, 0xf2, 0xe4, 0x1e, 0xab, 0x86, 0xe4, 0x0b, 0x12, 0x91, 0xf5, 0xc2, 0x23, 0xd8, 0xc8, 0xd2,
	0x0e, 0xa9, 0x2f, 0x58, 0xe0, 0x73, 0xcd, 0x54, 0x47, 0xa6, 0xb5, 0x94, 0xe9, 0x50, 0xe3, 0x15,
	0xf3, 0x5b, 0x30, 0xef, 0x86, 0xf6, 0x99, 0x48, 0xf4, 0x6f, 0x60, 0xbe, 0xb4, 0x11, 0x18, 0x5b,
	0x70, 0x07, 0x9a, 0x8c, 0x5b, 0x2e, 0xf5, 0xa8, 0xa0, 0xdd, 0x26, 0x06, 0x66, 0x83, 0xf1, 0x7d,
	0x3c, 0x4b, 0xfb, 0x1d, 0x8f, 0xda, 0xa1, 0x85, 0x2c, 0x5d, 0x40, 0x34, 0x20, 0x68, 0x5f, 0x42,
	0xd0, 0xe7, 0x23, 0xd7, 0x16, 0x54, 0x53, 0xb4, 0x90, 0xa2, 0xa5, 0x60, 0x8a, 0x24, 0x91, 0xa1,
	0x74, 0x6e, 0x67, 0x64, 0x28, 0x35, 0x7f, 0x0c, 0x1d, 0x2d, 0x43, 0x9b, 0xd7, 0x9d, 0x47, 0x9a,
	0x79, 0x05, 0xd5, 0x36, 0x91, 0x9f, 0x01, 0xd1, 0x64, 0x59, 0x97, 0x74, 0x90, 0x74, 0x51, 0x61,
	0x9e, 0x27, 0x8e, 0x31, 0xbe, 0x86, 0x79, 0x15, 0x12, 0x66, 0xf0, 0xe2, 0x88, 0xd2, 0xf0, 0x07,
	0x8e, 0x0c, 0xe3, 0x1f, 0x65, 0x68, 0x49, 0xbf, 0x3e, 0x63, 0x5c, 0x04, 0xe1, 0xf8, 0x87, 0x0e,
	0xbc, 0xdb, 0x50, 0xd3, 0x71, 0xa4, 0xf3, 0x74, 0x88, 0xa1, 0xb3, 0x0e, 0x0d, 0xc6, 0x55, 0x9c,
	0x61, 0x80, 0x35, 0xcc, 0x3a, 0xe3, 0x18, 0x5a, 0xd9, 0xb4, 0xac, 0xe5, 0xd2, 0x52, 0x57, 0x85,
	0x7a, 0x52, 0x15, 0x8c, 0xbf, 0x94, 0x81, 0xc8, 0x42, 0xe9, 0x53, 0xef, 0x5a, 0x26, 0xac, 0x41,
	0xfd, 0x2c, 0x0c, 0x86, 0x71, 0xc6, 0x57, 0xcd, 0x9a, 0x3c, 0x4e, 0xda, 0x56, 0x99, 0x6d, 0xdb,
	0xad, 0x19, 0xb6, 0x55, 0x33, 0xb6, 0x19, 0x07, 0x00, 0x5f, 0xe8, 0x8a, 0xf7, 0xe4, 0x8a, 0xf2,
	0x93, 0x2b, 0x96, 0xb6, 0xd0, 0x1a, 0x25, 0xc5, 0xf2, 0x89, 0x30, 0xd6, 0xa0, 0xda, 0xf3, 0xc5,
	0xfb, 0x3b, 0xa4, 0x03, 0x73, 0x09, 0xfb, 0x1c, 0x73, 0x35, 0xe2, 0x83, 0x07, 0x19, 0x44, 0x05,
	0x11, 0x5d, 0xa8, 0x99, 0x94, 0x47, 0x9e, 0x90, 0x98, 0xe0, 0x1c, 0x31, 0x0d, 0x73, 0x2e, 0x38,
	0x37, 0xee, 0x40, 0x13, 0x65, 0x61, 0x99, 0x8a, 0xd9, 0x2a, 0x5a, 0xde, 0x9f, 0xca, 0x30, 0x7f,
	0x34, 0x08, 0x44, 0xf0, 0x94, 0x79, 0xf4, 0xc4, 0x67, 0x42, 0x3e, 0xc8, 0x65, 0xe0, 0x45, 0x43,
	0x6a, 0x25, 0xf2, 0x1b, 0x0a, 0xa0, 0x9c, 0xe7, 0x05, 0x8e, 0xed, 0xa5, 0xef, 0x58, 0xc7, 0x73,
	0xcf, 0x25, 0xab, 0x50, 0xe3, 0xd4, 0x09, 0xa9, 0x2a, 0x9a, 0x15, 0x53, 0x9f, 0x24, 0x3c, 0x38,
	0x3b, 0xe3, 0x54, 0xc4, 0x4f, 0xa8, 0x4e, 0xb2, 0x8a, 0x7b, 0x6c, 0xc8, 0x44, 0xfc, 0x82, 0x78,
	0x30, 0xfe, 0x56, 0x86, 0xc5, 0xfd, 0xc0, 0x89, 0x64, 0x1a, 0x25, 0x2a, 0xdd, 0x85, 0x96, 0xab,
	0x61, 0xa9, 0x52, 0x10, 0x83, 0x54, 0x8d, 0xb3, 0x1d, 0x87, 0x72, 0x6e, 0x0d, 0x6c, 0x3e, 0xd0,
	0x35, 0x1d, 0x14, 0xe8, 0x99, 0xcd, 0x07, 0xb2, 0x71, 0x5d, 0xd2, 0x90, 0xcb, 0xc4, 0x54, 0x3e,
	0x8e, 0x8f, 0xaf, 0xa9, 0xde, 0x43, 0xfd, 0x5a, 0xc7, 0xec, 0x1b, 0x8a, 0xef, 0xb9, 0x0d, 0x55,
	0xce, 0xbe, 0xa1, 0x5c, 0x17, 0x7c, 0x92, 0x14, 0xfc, 0x84, 0xcc, 0x54, 0x04, 0xc6, 0x23, 0x68,
	0x1f, 0xdb, 0x9e, 0x38, 0xf1, 0x05, 0xf3, 0x4c, 0x7a, 0x91, 0x0d, 0xf6, 0x72, 0x2e, 0xd8, 0x09,
	0xdc, 0xe2, 0xb6, 0x27, 0xb4, 0x15, 0xf8, 0x6d, 0x7c, 0x01, 0x0d, 0xc9, 0xcc, 0x25, 0xa3, 0x8c,
	0x3d, 0xde, 0x4f, 0xf9, 0xaa, 0x43, 0xde, 0xbf, 0xaa, 0xa7, 0x2d, 0x42, 0xc5, 0x8f, 0x86, 0x71,
	0x03, 0xf5, 0xa3, 0xa1, 0xf1, 0x40, 0x49, 0xeb, 0x09, 0x3a, 0x4c, 0x6e, 0x2b, 0xa7, 0xb7, 0x49,
	0xdb, 0x23, 0xa9, 0xa6, 0x76, 0xb1, 0x3a, 0x18, 0x17, 0x00, 0xc7, 0xf4, 0xc2, 0xa4, 0x17, 0x11,
	0xe5, 0x57, 0x04, 0xf7, 0x9b, 0x00, 0x8e, 0x4a, 0xcc, 0x34, 0x48, 0x9a, 0x1a, 0x92, 0x57, 0xb3,
	0x32, 0x69, 0xf6, 0x99, 0x67, 0xf7, 0xb5, 0x1b, 0xf0, 0xdb, 0xf8, 0x5f, 0x19, 0x5a, 0xaa, 0x04,
	0xaa, 0xb1, 0x41, 0xd7, 0x81, 0x72, 0x3a, 0x1d, 0x4c, 0x36, 0xec, 0xb9, 0xa9, 0x86, 0x3d, 0xd9,
	0x00, 0x2b, 0x53, 0x0d, 0xf0, 0x27, 0xb0, 0x34, 0xdd, 0xfb, 0x94, 0x1a, 0x9d, 0x30, 0xdf, 0xf7,
	0xde, 0x01, 0x82, 0xa4, 0x41, 0x24, 0xa6, 0xfa, 0xe4, 0x82, 0xc4, 0x7c, 0x89, 0x08, 0x45, 0xbc,
	0x03, 0xb7, 0x8b, 0x7b, 0x9e, 0x6a, 0x94, 0xcb, 0xd1, 0x74, 0xbf, 0x33, 0xfe, 0x8e, 0x35, 0xd9,
	0xa1, 0xec, 0x92, 0xa2, 0x7b, 0x5e, 0x7f, 0x84, 0xc9, 0xbf, 0x7f, 0x65, 0xf2, 0xfd, 0xd1, 0x02,
	0xe7, 0xd2, 0x8a, 0xdb, 0x55, 0xd6, 0xda, 0x05, 0x89, 0x39, 0x51, 0x1d, 0x0b, 0x2d, 0x88, 0x7d,
	0x52, 0x4d, 0x7d, 0x22, 0xc3, 0x4f, 0x35, 0x5b, 0x34, 0xa3, 0x61, 0x56, 0xb1, 0xd3, 0x1a, 0xbf,
	0x87, 0xd6, 0xde, 0xc0, 0x16, 0x47, 0x82, 0xc7, 0x7a, 0x3b, 0x03, 0x5b, 0x64, 0xf4, 0x96, 0x47,
	0xa5, 0x77, 0x6c, 0xd0, 0xdc, 0x2c, 0x83, 0x2a, 0x45, 0xc5, 0xff, 0x56, 0x5a, 0xfc, 0x8f, 0x60,
	0xf5, 0x90, 0xf5, 0x43, 0xec, 0x96, 0x87, 0xb4, 0x6f, 0xf7, 0xc3, 0x20, 0x1a, 0x5d, 0x7d, 0xed,
	0xd5, 0x51, 0x69, 0xfc, 0x51, 0x0d, 0x8f, 0x7b, 0x81, 0xef, 0x53, 0x47, 0x25, 0xc6, 0x16, 0xb4,
	0xfb, 0x2f, 0xf0, 0xa7, 0x20, 0xfb, 0xfc, 0xd0, 0x7f, 0x71, 0x8c, 0xa0, 0x1b, 0x99, 0xd2, 0x85,
	0xba, 0xa3, 0xae, 0x40, 0x73, 0x1a, 0x66, 0x7c, 0x34, 0x3e, 0x52, 0xd3, 0xb1, 0x54, 0x80, 0xcf,
	0x76, 0xfa, 0x0a, 0x54, 0x25, 0x83, 0x9c, 0x8f, 0x2b, 0xdb, 0x4d, 0x53, 0x1d, 0x8c, 0x5d, 0x98,
	0x4f, 0x78, 0xb1, 0x28, 0xbd, 0x07, 0x80, 0xfc, 0x8a, 0x76, 0xb2, 0x32, 0x25, 0xb4, 0x66, 0x33,
	0x8a, 0x3f, 0x0d, 0xae, 0xfe, 0x0d, 0xf8, 0xf7, 0xa6, 0xf7, 0xcf, 0xa1, 0x11, 0x31, 0x3d, 0xe4,
	0x4a, 0xab, 0xb3, 0x92, 0x93, 0x36, 0x63, 0xd6, 0x23, 0x86, 0xb3, 0xad, 0x1e, 0xcd, 0x38, 0x1b,
	0x8e, 0xbc, 0xf8, 0x9f, 0xa1, 0xc1, 0xf8, 0x31, 0x9e, 0x8d, 0xf7, 0xa1, 0x7d, 0xa8, 0x58, 0xf1,
	0x6e, 0xf2, 0x16, 0x54, 0xe5, 0x2d, 0xb1, 0xca, 0xf3, 0x39, 0x95, 0x4d, 0x85, 0x33, 0x3e, 0x53,
	0xae, 0x3a, 0x0a, 0xd9, 0xa5, 0xed, 0x8c, 0xaf, 0x4e, 0x92, 0x75, 0x68, 0x9c, 0xd3, 0x71, 0x76,
	0x6e, 0xa9, 0x9f, 0xd3, 0xb1, 0x6c, 0xed, 0xc6, 0x3f, 0xab, 0x50, 0x97, 0x01, 0x6b, 0x06, 0x2f,
	0x26, 0x9b, 0xec, 0xf7, 0xb7, 0x93, 0x37, 0xa0, 0xe9, 0xd2, 0x61, 0xe0, 0x84, 0xb6, 0x33, 0xd6,
	0x56, 0xa5, 0x00, 0x8c, 0xb5, 0x90, 0xda, 0x22, 0xc8, 0x0c, 0x0e, 0x4d, 0x0d, 0xe9, 0xb9, 0xc4,
	0x80, 0xf9, 0x11, 0xf3, 0x7d, 0xea, 0x5a, 0xba, 0x8c, 0xab, 0xec, 0x6a, 0x29, 0xe0, 0x21, 0x16,
	0xf3, 0x15, 0xa8, 0xda, 0xa7, 0x41, 0xa4, 0x4a, 0x45, 0xd3, 0x54, 0x07, 0x09, 0x15, 0x4c, 0x78,
	0x14, 0x07, 0xa1, 0xa6, 0xa9, 0x0e, 0x32, 0x49, 0xd1, 0xc0, 0x86, 0x4a, 0x52, 0xf9, 0x2d, 0x0d,
	0x1f, 0xc9, 0x06, 0x24, 0xc5, 0x37, 0x51, 0xfd, 0x3a, 0x9e, 0x7b, 0xae, 0x1c, 0x55, 0x6d, 0x77,
	0xc8, 0x7c, 0x6e, 0x51, 0xdf, 0x3e, 0xf5, 0xa8, 0xab, 0x47, 0xe2, 0x79, 0x05, 0xfd, 0x4c, 0x01,
	0xc9, 0x7b, 0x70, 0x7b, 0xa8, 0x72, 0xcc, 0xb5, 0x70, 0x72, 0x8a, 0xf3, 0xaa, 0xa5, 0x7e, 0x0a,
	0x62, 0xe4, 0xd3, 0x30, 0x18, 0xee, 0xa9, 0x1c, 0x7b, 0x17, 0x56, 0xf2, 0x2c, 0xba, 0xb8, 0xb4,
	0x91, 0x63, 0x29, 0xcb, 0xa1, 0xca, 0xcb, 0x5d, 0x68, 0x25, 0x0c, 0x22, 0xc0, 0x91, 0xb9, 0x6a,
	0x42, 0x0c, 0x7a, 0x1e, 0x90, 0x0d, 0x68, 0x48, 0x4f, 0xfa, 0xf6, 0x50, 0x4d, 0xc9, 0x4d, 0x33,
	0x39, 0x93, 0x77, 0x60, 0x69, 0xc0, 0x5c, 0x97, 0xfa, 0xd6, 0x28, 0xa4, 0x03, 0x35, 0xff, 0x75,
	0x17, 0xd4, 0x28, 0xad, 0x10, 0x47, 0x09, 0x9c, 0x6c, 0x02, 0x70, 0xd6, 0xf7, 0x6d, 0x11, 0x85,
	0x94, 0x77, 0x17, 0xd5, 0xfc, 0x9e, 0x42, 0xc8, 0x16, 0xb4, 0x5c, 0x6a, 0x3b, 0x82, 0x5d, 0xca,
	0x9b, 0xbb, 0x4b, 0xea, 0x17, 0x20, 0x03, 0x92, 0xaa, 0x5c, 0xd2, 0x90, 0x9d, 0x31, 0xea, 0x76,
	0x89, 0x8a, 0xe3, 0xf8, 0x2c, 0xed, 0x08, 0x59, 0x7f, 0x20, 0xb8, 0x35, 0xb4, 0xf9, 0x79, 0x77,
	0x59, 0xd9, 0xa1, 0x40, 0x87, 0x36, 0x3f, 0xcf, 0x8e, 0x1f, 0x2b, 0xf9, 0xf1, 0xe3, 0x6d, 0xe8,
	0x70, 0xc1, 0x9c, 0x73, 0x1a, 0x5a, 0x9c, 0xe2, 0xfb, 0xde, 0x46, 0x77, 0xb5, 0x35, 0xf4, 0x98,
	0x0a, 0xbd, 0x30, 0x70, 0x5d, 0x4b, 0xb0, 0x21, 0xed, 0xae, 0x2a, 0x01, 0xb6, 0xeb, 0x3e, 0x67,
	0x43, 0x6a, 0xdc, 0x87, 0x86, 0x0e, 0x63, 0x4e, 0xde, 0x86, 0x5b, 0x61, 0xf0, 0x22, 0x4e, 0x9f,
	0xc5, 0x24, 0x7d, 0x34, 0x81, 0x89, 0x58, 0x63, 0x0f, 0x16, 0x8e, 0xec, 0x50, 0x30, 0x87, 0x8d,
	0x6c, 0x5f, 0xdc, 0xac, 0x5a, 0x1b, 0xbf, 0x83, 0xc5, 0x09, 0x21, 0x3b, 0x37, 0xa8, 0xf9, 0x69,
	0x2f, 0xa9, 0x64, 0x7b, 0xc9, 0x7f, 0xe7, 0xa0, 0x93, 0x91, 0x2e, 0x53, 0xf4, 0xf5, 0x65, 0xc7,
	0x69, 0x51, 0xc9, 0xa4, 0xc5, 0x22, 0x54, 0x4e, 0x83, 0xb8, 0xf6, 0xca, 0x4f, 0x99, 0xab, 0xcc,
	0xbf, 0x64, 0x42, 0x49, 0x50, 0x99, 0xd8, 0xd4, 0x90, 0xde, 0x94, 0x67, 0x6b, 0x53, 0x9e, 0x7d,
	0x13, 0x00, 0xa7, 0x23, 0x4b, 0x36, 0x4d, 0xfd, 0x83, 0xd2, 0x44, 0xc8, 0xbe, 0x1c, 0x58, 0x56,
	0xa1, 0x76, 0x2e, 0xfd, 0xe8, 0x62, 0x76, 0x36, 0x4c, 0x7d, 0x22, 0xdb, 0xb0, 0x68, 0x5f, 0xda,
	0xcc, 0x93, 0xb9, 0x66, 0x0d, 0x99, 0x1f, 0xe7, 0x69, 0xd5, 0xec, 0x24, 0xf0, 0x43, 0xe6, 0x2b,
	0x0d, 0x46, 0x61, 0x30, 0x0c, 0x64, 0x8e, 0x9c, 0x8e, 0x31, 0x57, 0xab, 0x26, 0xc4, 0xa0, 0xdd,
	0x71, 0x2e, 0x36, 0x5a, 0xb9, 0xd8, 0x90, 0xbc, 0xf1, 0xef, 0xa6, 0xc4, 0xaa, 0x3c, 0x04, 0xfd,
	0x9f, 0x29, 0x83, 0xe7, 0x93, 0x5c, 0x28, 0x60, 0x0c, 0xbd, 0x93, 0x8b, 0xa1, 0xb5, 0x74, 0x9e,
	0xcd, 0xd1, 0xa9, 0x50, 0xda, 0x79, 0xb5, 0x0e, 0x0d, 0xf3, 0x68, 0x6f, 0xcf, 0x76, 0x06, 0x94,
	0xf4, 0x60, 0xed, 0x80, 0x0a, 0xac, 0xe4, 0xbb, 0xe3, 0x63, 0xea, 0x9d, 0x3d, 0xf1, 0xdd, 0xde,
	0x3e, 0x76, 0x81, 0xdb, 0xb9, 0x4a, 0x1e, 0x37, 0x99, 0x8d, 0x14, 0x9c, 0x6d, 0x03, 0x46, 0x89,
	0x3c, 0x80, 0x05, 0x35, 0x86, 0x60, 0xaf, 0x42, 0xe9, 0x9d, 0x7c, 0x97, 0xd9, 0x58, 0x48, 0xce,
	0xea, 0xb7, 0xc7, 0x28, 0x91, 0x4f, 0x61, 0x49, 0x71, 0xe9, 0xde, 0x60, 0x46, 0x1e, 0x25, 0xf9,
	0x15, 0x4c, 0xa6, 0x6b, 0x14, 0x49, 0x78, 0x04, 0xad, 0x03, 0x2a, 0xf6, 0x02, 0x5f, 0xd8, 0x8e,
	0xe0, 0x53, 0x77, 0x6e, 0x24, 0x67, 0x47, 0x93, 0x58, 0x31, 0xad, 0x51, 0x22, 0x9f, 0x20, 0xb3,
	0x1c, 0x54, 0x23, 0x4e, 0xa7, 0x99, 0xdf, 0x4c, 0xce, 0xbf, 0xa5, 0x8e, 0xec, 0x0d, 0x9a, 0x55,
	0x31, 0xa0, 0xd1, 0x70, 0x40, 0x45, 0xbc, 0xf7, 0xcb, 0xb1, 0x7f, 0xf0, 0x60, 0x63, 0x25, 0x39,
	0x67, 0x76, 0x8f, 0x46, 0x89, 0xfc, 0x42, 0x4e, 0xe5, 0x09, 0x57, 0x21, 0x55, 0x91, 0xa5, 0x0f,
	0xa1, 0xb3, 0xcb, 0x7c, 0x57, 0x53, 0x9d, 0x30, 0xf7, 0xfa, 0xac, 0xef, 0x02, 0xec, 0x53, 0x6f,
	0x96, 0x9e, 0x05, 0x0c, 0x1f, 0xc3, 0x62, 0x6e, 0xa7, 0x29, 0x6f, 0x5b, 0xcd, 0x16, 0xa7, 0x14,
	0x55, 0xcc, 0xbe, 0x10, 0xbb, 0x55, 0x2d, 0x2e, 0xf9, 0x44, 0x3c, 0xc5, 0xf0, 0x02, 0xe6, 0xed,
	0x32, 0x79, 0x04, 0x9d, 0xa7, 0x41, 0xe8, 0x50, 0xf5, 0x1f, 0xb1, 0xb3, 0x7f, 0x9a, 0xb9, 0x3b,
	0xb7, 0x5e, 0x29, 0xba, 0xfb, 0x71, 0x1c, 0x52, 0xd9, 0x25, 0xc3, 0x4a, 0x86, 0x2e, 0x81, 0x16,
	0x71, 0xef, 0x01, 0x91, 0x14, 0x7a, 0x4f, 0x11, 0xb3, 0xdf, 0xc9, 0x99, 0x9e, 0x5f, 0x60, 0x6c,
	0x4c, 0x44, 0x0d, 0x9a, 0xbf, 0x74, 0x40, 0xc5, 0xc4, 0xfe, 0x6d, 0x96, 0x09, 0xd3, 0xec, 0x8f,
	0xa1, 0x23, 0xb3, 0x32, 0xf3, 0x3f, 0x34, 0x73, 0x29, 0x59, 0xc0, 0xfd, 0x19, 0x2c, 0xe7, 0xb9,
	0x0f, 0xe4, 0xa8, 0x3d, 0x15, 0xdb, 0x6f, 0xcc, 0x12, 0x89, 0xfb, 0xcd, 0x12, 0xf9, 0x10, 0xda,
	0xea, 0x19, 0xf5, 0x8a, 0x73, 0x39, 0x47, 0xaf, 0x80, 0xc5, 0xde, 0xdb, 0x81, 0xe6, 0x01, 0x15,
	0x9a, 0x6d, 0xf2, 0xda, 0x22, 0x31, 0x46, 0x89, 0x7c, 0x04, 0xf3, 0x07, 0x54, 0x64, 0x16, 0x31,
	0xb3, 0xf9, 0x52, 0x22, 0x79, 0xdb, 0xfd, 0x32, 0x79, 0x00, 0xed, 0x03, 0x2a, 0x7e, 0x4d, 0x5f,
	0x0a, 0x35, 0x88, 0x4d, 0xb2, 0x4e, 0x3d, 0x11, 0x72, 0xed, 0xc2, 0xe2, 0x01, 0x15, 0xc9, 0x1e,
	0x65, 0xdf, 0x16, 0x76, 0xc6, 0x45, 0xb9, 0xfd, 0x4a, 0x26, 0x91, 0xa3, 0x91, 0x17, 0xd8, 0xae,
	0x25, 0x31, 0x46, 0x89, 0x3c, 0xc3, 0xa7, 0xce, 0xee, 0x3e, 0x50, 0xcc, 0x7a, 0xea, 0xe9, 0x89,
	0xb5, 0xc8, 0x4c, 0x49, 0x8f, 0x53, 0x6d, 0x92, 0x3d, 0xc5, 0x64, 0x9a, 0xae, 0x4e, 0x2f, 0x2a,
	0xb4, 0xaf, 0x3e, 0xc6, 0x32, 0x16, 0x5f, 0x76, 0xd5, 0xfd, 0x4b, 0x53, 0x28, 0xa3, 0x44, 0x7e,
	0x89, 0x0f, 0x98, 0x6c, 0x3a, 0x32, 0xa9, 0x9a, 0xdd, 0x7e, 0x14, 0x84, 0xda, 0x7b, 0x58, 0xfe,
	0xbe, 0xf4, 0xa9, 0xa4, 0x9b, 0xd2, 0x77, 0x29, 0x27, 0x46, 0xd6, 0x6f, 0x2c, 0xd7, 0x32, 0xb6,
	0x9f, 0x46, 0x72, 0x86, 0xc3, 0xf5, 0x08, 0xc9, 0x93, 0xc9, 0x46, 0x93, 0x79, 0xa5, 0x0c, 0x21,
	0x96, 0xb1, 0x9a, 0x7c, 0x25, 0xc1, 0x33, 0xd1, 0x98, 0xee, 0x37, 0x0a, 0x14, 0x54, 0x0c, 0xbf,
	0x79, 0x5d, 0x86, 0x63, 0x7a, 0x71, 0x5d, 0x86, 0x07, 0xf8, 0xf4, 0x87, 0xbc, 0xbf, 0x1b, 0xc8,
	0x24, 0xbf, 0x26, 0xd7, 0x07, 0x18, 0xee, 0xba, 0x96, 0xbc, 0x86, 0x3d, 0x1f, 0xc2, 0x42, 0xca,
	0xa7, 0xa2, 0xfd, 0x9a, 0x9c, 0x0f, 0xa1, 0xa1, 0x3b, 0x1d, 0x2d, 0x66, 0x59, 0xcd, 0x44, 0xa6,
	0x4c, 0x7b, 0x6e, 0x21, 0x31, 0xf6, 0xe8, 0x4e, 0x92, 0xcf, 0x4a, 0xc0, 0xac, 0x52, 0xb6, 0x32,
	0x01, 0x8f, 0x25, 0x3c, 0xc4, 0x7a, 0x98, 0x1d, 0x3e, 0xdd, 0xe9, 0x66, 0x5b, 0xf0, 0x4f, 0x8a,
	0xf5, 0x78, 0x2d, 0xcf, 0x9a, 0xfe, 0x32, 0x4f, 0x0a, 0x58, 0x9d, 0xfe, 0x5d, 0xd6, 0x42, 0xee,
	0x63, 0x9c, 0x26, 0xbf, 0x8e, 0x13, 0x7c, 0x53, 0x43, 0x37, 0x3a, 0xa8, 0x95, 0x72, 0x70, 0x52,
	0xa0, 0x5b, 0x26, 0xbc, 0x63, 0x32, 0x2c, 0xbe, 0x9d, 0xbc, 0xba, 0x99, 0xd2, 0x3d, 0x31, 0x7c,
	0x6f, 0xcc, 0x1a, 0xd4, 0x8c, 0x12, 0x79, 0x8a, 0x7e, 0xce, 0x80, 0x77, 0x6e, 0x26, 0xe7, 0x53,
	0x20, 0x79, 0x39, 0x68, 0xcd, 0xe4, 0x03, 0x74, 0x67, 0x08, 0xe0, 0x58, 0x1b, 0x96, 0x27, 0xdf,
	0x5f, 0x36, 0xa4, 0xef, 0xad, 0xb1, 0xe4, 0x31, 0xcc, 0xf7, 0xf8, 0xf5, 0x1e, 0xa2, 0x70, 0x80,
	0xe8, 0x3c, 0x71, 0xdd, 0x1b, 0xb3, 0xef, 0x02, 0xd9, 0xa7, 0xde, 0xe7, 0xcc, 0x39, 0xcf, 0x8a,
	0x58, 0x9f, 0x25, 0x62, 0x67, 0xc6, 0xcc, 0xa4, 0x1a, 0xa0, 0x74, 0xef, 0x75, 0x66, 0xd9, 0x7d,
	0xb8, 0x9d, 0x32, 0xdc, 0x58, 0xf5, 0x9c, 0x14, 0xbd, 0x56, 0x74, 0x65, 0x89, 0x58, 0xc9, 0xc5,
	0x9b, 0x5e, 0xda, 0x15, 0x76, 0xe0, 0xfb, 0x65, 0xf2, 0x18, 0x48, 0x3c, 0x04, 0xa1, 0x04, 0x35,
	0x82, 0x64, 0xa7, 0xa0, 0x64, 0x5f, 0x59, 0xe0, 0xbb, 0x67, 0x40, 0xa6, 0x97, 0x75, 0xe4, 0x6e,
	0x3a, 0xfa, 0x17, 0x6e, 0xf2, 0x8a, 0xac, 0xf9, 0x15, 0x74, 0x32, 0x7f, 0x05, 0x81, 0xef, 0x4f,
	0x8c, 0x32, 0x99, 0xed, 0x5d, 0xf1, 0x30, 0xa1, 0x9a, 0x7b, 0xba, 0x67, 0x9b, 0x5d, 0x35, 0x12,
	0x1a, 0xa3, 0xb4, 0xbb, 0xf1, 0xaf, 0x57, 0x9b, 0xe5, 0x6f, 0x5f, 0x6d, 0x96, 0xff, 0xf3, 0x6a,
	0xb3, 0xfc, 0xe7, 0xef, 0x36, 0x4b, 0xdf, 0x7e, 0xb7, 0x59, 0xfa, 0xf7, 0x77, 0x9b, 0xa5, 0x67,
	0x73, 0xa7, 0x35, 0x24, 0x7f, 0xff, 0xff, 0x01, 0x00, 0x00, 0xff, 0xff, 0x43, 0xa4, 0x4d, 0x06,
	0x80, 0x20, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCCacheClient is the client API for RPCCache service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCCacheClient interface {
	GetUsersBySelfAndIDList(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*MtprotoUsers, error)
	UpdateUserCache(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Result, error)
	UpdatePrivacyRule(ctx context.Context, in *UserPrivacyItem, opts ...grpc.CallOption) (*Result, error)
	GetContacts(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Contacts_Contacts, error)
	GetStatuses(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Vector_ContactStatus, error)
	GetAuthKey(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*AuthKeyInfo, error)
	SetAuthKey(ctx context.Context, in *AuthKeyInfo, opts ...grpc.CallOption) (*Result, error)
	BindAuthKeyUid(ctx context.Context, in *AuthKeyInfo, opts ...grpc.CallOption) (*Result, error)
	DelAuthKey(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*Result, error)
	ChangeAuthKeyUid(ctx context.Context, in *ChangeAuthKey, opts ...grpc.CallOption) (*Result, error)
	UpdatePresences(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdatePresencesClient, error)
	ForceDialog2Db(ctx context.Context, in *DialogRowPeer, opts ...grpc.CallOption) (*Result, error)
	UpdateReadHistory(ctx context.Context, in *ReadHistory, opts ...grpc.CallOption) (*Result, error)
	// channel 人多时，用不用给发送者返回『已读』推送，增加个变量 2时不给发送者推已读消息
	ReadChannelHistory(ctx context.Context, in *ChannelReadHistory, opts ...grpc.CallOption) (*Int32, error)
	GetReadInboxMaxId(ctx context.Context, in *DialogRowPeer, opts ...grpc.CallOption) (*Int32, error)
	GetUnreadCount(ctx context.Context, in *UserUnreadCount, opts ...grpc.CallOption) (*Int32, error)
	GetUnreadCountGroup(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserUnreadCountList, error)
	//
	UpdateDialog(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdateDialogClient, error)
	GetDialog(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserDialog, error)
	GetLastSeenAt(ctx context.Context, opts ...grpc.CallOption) (RPCCache_GetLastSeenAtClient, error)
	GetNextMsgId(ctx context.Context, opts ...grpc.CallOption) (RPCCache_GetNextMsgIdClient, error)
	GetPhotoFileData(ctx context.Context, in *PhotoFileUnit, opts ...grpc.CallOption) (*Upload_File, error)
	GetDocumentFileData(ctx context.Context, in *DocumentFileUnit, opts ...grpc.CallOption) (*Upload_File, error)
	GetPhotoSizeList(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*PhotoSizeList, error)
	GetDocument(ctx context.Context, in *DocumentFileUnit, opts ...grpc.CallOption) (*Document, error)
	GetSaltUntil(ctx context.Context, in *SaltUntilReq, opts ...grpc.CallOption) (*Int32, error)
	GetOneSalt(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*SaltItem, error)
	GetFutureSalts(ctx context.Context, in *SaltsReq, opts ...grpc.CallOption) (*FutureSalts, error)
	GetPts(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error)
	GetQts(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error)
	GetSeq(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error)
	GetMsgBoxId(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error)
	GetChannelPts(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error)
	GetChannelMsgId(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error)
	GetState(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Updates_State, error)
	GetDialogState(ctx context.Context, in *DialogRowPeer, opts ...grpc.CallOption) (*DialogState, error)
	GetParticipantIds(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Int32List, error)
	GetParticipantConnsList(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserConnsList, error)
	GetChatRow(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*ChatRow, error)
	GetChatRows(ctx context.Context, in *Int32List, opts ...grpc.CallOption) (*ChatRows, error)
	GetParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*ParticipantRow, error)
	GetParticipant2(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*ParticipantRow, error)
	GetParticipantRows(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*ParticipantRows, error)
	GetParticipantCount(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Int32, error)
	IsParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*Result, error)
	AddParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*Result, error)
	DelKickParticipant(ctx context.Context, in *ParticipantItem2, opts ...grpc.CallOption) (*Result, error)
	UpdateChat(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Result, error)
	UpdateChatParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*Result, error)
	UpdateChatReceivedPts(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdateChatReceivedPtsClient, error)
	UpdateReceiveMaxId(ctx context.Context, in *ReceiveItem, opts ...grpc.CallOption) (*Int32, error)
	MigrateToMegagroup(ctx context.Context, in *MigrateToMegagroupItem, opts ...grpc.CallOption) (*Result, error)
	UpdateUserConn(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdateUserConnClient, error)
	GetUserConns(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserConns, error)
}

type rPCCacheClient struct {
	cc *grpc.ClientConn
}

func NewRPCCacheClient(cc *grpc.ClientConn) RPCCacheClient {
	return &rPCCacheClient{cc}
}

func (c *rPCCacheClient) GetUsersBySelfAndIDList(ctx context.Context, in *UsersRequest, opts ...grpc.CallOption) (*MtprotoUsers, error) {
	out := new(MtprotoUsers)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetUsersBySelfAndIDList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateUserCache(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/UpdateUserCache", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdatePrivacyRule(ctx context.Context, in *UserPrivacyItem, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/UpdatePrivacyRule", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetContacts(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Contacts_Contacts, error) {
	out := new(Contacts_Contacts)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetContacts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetStatuses(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Vector_ContactStatus, error) {
	out := new(Vector_ContactStatus)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetStatuses", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetAuthKey(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*AuthKeyInfo, error) {
	out := new(AuthKeyInfo)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) SetAuthKey(ctx context.Context, in *AuthKeyInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/SetAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) BindAuthKeyUid(ctx context.Context, in *AuthKeyInfo, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/BindAuthKeyUid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) DelAuthKey(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/DelAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) ChangeAuthKeyUid(ctx context.Context, in *ChangeAuthKey, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/ChangeAuthKeyUid", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdatePresences(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdatePresencesClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPCCache_serviceDesc.Streams[0], "/mtproto.RPCCache/UpdatePresences", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCCacheUpdatePresencesClient{stream}
	return x, nil
}

type RPCCache_UpdatePresencesClient interface {
	Send(*UserPresence) error
	CloseAndRecv() (*Result, error)
	grpc.ClientStream
}

type rPCCacheUpdatePresencesClient struct {
	grpc.ClientStream
}

func (x *rPCCacheUpdatePresencesClient) Send(m *UserPresence) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rPCCacheUpdatePresencesClient) CloseAndRecv() (*Result, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCCacheClient) ForceDialog2Db(ctx context.Context, in *DialogRowPeer, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/ForceDialog2Db", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateReadHistory(ctx context.Context, in *ReadHistory, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/UpdateReadHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) ReadChannelHistory(ctx context.Context, in *ChannelReadHistory, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/ReadChannelHistory", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetReadInboxMaxId(ctx context.Context, in *DialogRowPeer, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetReadInboxMaxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetUnreadCount(ctx context.Context, in *UserUnreadCount, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetUnreadCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetUnreadCountGroup(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserUnreadCountList, error) {
	out := new(UserUnreadCountList)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetUnreadCountGroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateDialog(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdateDialogClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPCCache_serviceDesc.Streams[1], "/mtproto.RPCCache/UpdateDialog", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCCacheUpdateDialogClient{stream}
	return x, nil
}

type RPCCache_UpdateDialogClient interface {
	Send(*UserDialog) error
	CloseAndRecv() (*Result, error)
	grpc.ClientStream
}

type rPCCacheUpdateDialogClient struct {
	grpc.ClientStream
}

func (x *rPCCacheUpdateDialogClient) Send(m *UserDialog) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rPCCacheUpdateDialogClient) CloseAndRecv() (*Result, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCCacheClient) GetDialog(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserDialog, error) {
	out := new(UserDialog)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetDialog", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetLastSeenAt(ctx context.Context, opts ...grpc.CallOption) (RPCCache_GetLastSeenAtClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPCCache_serviceDesc.Streams[2], "/mtproto.RPCCache/GetLastSeenAt", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCCacheGetLastSeenAtClient{stream}
	return x, nil
}

type RPCCache_GetLastSeenAtClient interface {
	Send(*Int32) error
	Recv() (*LastSeenAt, error)
	grpc.ClientStream
}

type rPCCacheGetLastSeenAtClient struct {
	grpc.ClientStream
}

func (x *rPCCacheGetLastSeenAtClient) Send(m *Int32) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rPCCacheGetLastSeenAtClient) Recv() (*LastSeenAt, error) {
	m := new(LastSeenAt)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCCacheClient) GetNextMsgId(ctx context.Context, opts ...grpc.CallOption) (RPCCache_GetNextMsgIdClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPCCache_serviceDesc.Streams[3], "/mtproto.RPCCache/GetNextMsgId", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCCacheGetNextMsgIdClient{stream}
	return x, nil
}

type RPCCache_GetNextMsgIdClient interface {
	Send(*Int32) error
	Recv() (*Int32, error)
	grpc.ClientStream
}

type rPCCacheGetNextMsgIdClient struct {
	grpc.ClientStream
}

func (x *rPCCacheGetNextMsgIdClient) Send(m *Int32) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rPCCacheGetNextMsgIdClient) Recv() (*Int32, error) {
	m := new(Int32)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCCacheClient) GetPhotoFileData(ctx context.Context, in *PhotoFileUnit, opts ...grpc.CallOption) (*Upload_File, error) {
	out := new(Upload_File)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetPhotoFileData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetDocumentFileData(ctx context.Context, in *DocumentFileUnit, opts ...grpc.CallOption) (*Upload_File, error) {
	out := new(Upload_File)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetDocumentFileData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetPhotoSizeList(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*PhotoSizeList, error) {
	out := new(PhotoSizeList)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetPhotoSizeList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetDocument(ctx context.Context, in *DocumentFileUnit, opts ...grpc.CallOption) (*Document, error) {
	out := new(Document)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetSaltUntil(ctx context.Context, in *SaltUntilReq, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetSaltUntil", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetOneSalt(ctx context.Context, in *Int64, opts ...grpc.CallOption) (*SaltItem, error) {
	out := new(SaltItem)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetOneSalt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetFutureSalts(ctx context.Context, in *SaltsReq, opts ...grpc.CallOption) (*FutureSalts, error) {
	out := new(FutureSalts)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetFutureSalts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetPts(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetPts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetQts(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetQts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetSeq(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetSeq", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetMsgBoxId(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetMsgBoxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetChannelPts(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetChannelPts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetChannelMsgId(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetChannelMsgId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetState(ctx context.Context, in *SeqRequest, opts ...grpc.CallOption) (*Updates_State, error) {
	out := new(Updates_State)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetDialogState(ctx context.Context, in *DialogRowPeer, opts ...grpc.CallOption) (*DialogState, error) {
	out := new(DialogState)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetDialogState", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetParticipantIds(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Int32List, error) {
	out := new(Int32List)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetParticipantIds", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetParticipantConnsList(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserConnsList, error) {
	out := new(UserConnsList)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetParticipantConnsList", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetChatRow(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*ChatRow, error) {
	out := new(ChatRow)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetChatRow", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetChatRows(ctx context.Context, in *Int32List, opts ...grpc.CallOption) (*ChatRows, error) {
	out := new(ChatRows)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetChatRows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*ParticipantRow, error) {
	out := new(ParticipantRow)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetParticipant2(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*ParticipantRow, error) {
	out := new(ParticipantRow)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetParticipant2", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetParticipantRows(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*ParticipantRows, error) {
	out := new(ParticipantRows)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetParticipantRows", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) GetParticipantCount(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetParticipantCount", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) IsParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/IsParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) AddParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/AddParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) DelKickParticipant(ctx context.Context, in *ParticipantItem2, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/DelKickParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateChat(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/UpdateChat", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateChatParticipant(ctx context.Context, in *ParticipantItem, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/UpdateChatParticipant", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateChatReceivedPts(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdateChatReceivedPtsClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPCCache_serviceDesc.Streams[4], "/mtproto.RPCCache/UpdateChatReceivedPts", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCCacheUpdateChatReceivedPtsClient{stream}
	return x, nil
}

type RPCCache_UpdateChatReceivedPtsClient interface {
	Send(*ChatPtsItem) error
	Recv() (*Result, error)
	grpc.ClientStream
}

type rPCCacheUpdateChatReceivedPtsClient struct {
	grpc.ClientStream
}

func (x *rPCCacheUpdateChatReceivedPtsClient) Send(m *ChatPtsItem) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rPCCacheUpdateChatReceivedPtsClient) Recv() (*Result, error) {
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCCacheClient) UpdateReceiveMaxId(ctx context.Context, in *ReceiveItem, opts ...grpc.CallOption) (*Int32, error) {
	out := new(Int32)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/UpdateReceiveMaxId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) MigrateToMegagroup(ctx context.Context, in *MigrateToMegagroupItem, opts ...grpc.CallOption) (*Result, error) {
	out := new(Result)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/MigrateToMegagroup", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCCacheClient) UpdateUserConn(ctx context.Context, opts ...grpc.CallOption) (RPCCache_UpdateUserConnClient, error) {
	stream, err := c.cc.NewStream(ctx, &_RPCCache_serviceDesc.Streams[5], "/mtproto.RPCCache/UpdateUserConn", opts...)
	if err != nil {
		return nil, err
	}
	x := &rPCCacheUpdateUserConnClient{stream}
	return x, nil
}

type RPCCache_UpdateUserConnClient interface {
	Send(*UserConnectItem) error
	CloseAndRecv() (*Result, error)
	grpc.ClientStream
}

type rPCCacheUpdateUserConnClient struct {
	grpc.ClientStream
}

func (x *rPCCacheUpdateUserConnClient) Send(m *UserConnectItem) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rPCCacheUpdateUserConnClient) CloseAndRecv() (*Result, error) {
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	m := new(Result)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *rPCCacheClient) GetUserConns(ctx context.Context, in *Int32, opts ...grpc.CallOption) (*UserConns, error) {
	out := new(UserConns)
	err := c.cc.Invoke(ctx, "/mtproto.RPCCache/GetUserConns", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCCacheServer is the server API for RPCCache service.
type RPCCacheServer interface {
	GetUsersBySelfAndIDList(context.Context, *UsersRequest) (*MtprotoUsers, error)
	UpdateUserCache(context.Context, *Int32) (*Result, error)
	UpdatePrivacyRule(context.Context, *UserPrivacyItem) (*Result, error)
	GetContacts(context.Context, *Int32) (*Contacts_Contacts, error)
	GetStatuses(context.Context, *Int32) (*Vector_ContactStatus, error)
	GetAuthKey(context.Context, *Int64) (*AuthKeyInfo, error)
	SetAuthKey(context.Context, *AuthKeyInfo) (*Result, error)
	BindAuthKeyUid(context.Context, *AuthKeyInfo) (*Result, error)
	DelAuthKey(context.Context, *Int64) (*Result, error)
	ChangeAuthKeyUid(context.Context, *ChangeAuthKey) (*Result, error)
	UpdatePresences(RPCCache_UpdatePresencesServer) error
	ForceDialog2Db(context.Context, *DialogRowPeer) (*Result, error)
	UpdateReadHistory(context.Context, *ReadHistory) (*Result, error)
	// channel 人多时，用不用给发送者返回『已读』推送，增加个变量 2时不给发送者推已读消息
	ReadChannelHistory(context.Context, *ChannelReadHistory) (*Int32, error)
	GetReadInboxMaxId(context.Context, *DialogRowPeer) (*Int32, error)
	GetUnreadCount(context.Context, *UserUnreadCount) (*Int32, error)
	GetUnreadCountGroup(context.Context, *Int32) (*UserUnreadCountList, error)
	//
	UpdateDialog(RPCCache_UpdateDialogServer) error
	GetDialog(context.Context, *Int32) (*UserDialog, error)
	GetLastSeenAt(RPCCache_GetLastSeenAtServer) error
	GetNextMsgId(RPCCache_GetNextMsgIdServer) error
	GetPhotoFileData(context.Context, *PhotoFileUnit) (*Upload_File, error)
	GetDocumentFileData(context.Context, *DocumentFileUnit) (*Upload_File, error)
	GetPhotoSizeList(context.Context, *Int64) (*PhotoSizeList, error)
	GetDocument(context.Context, *DocumentFileUnit) (*Document, error)
	GetSaltUntil(context.Context, *SaltUntilReq) (*Int32, error)
	GetOneSalt(context.Context, *Int64) (*SaltItem, error)
	GetFutureSalts(context.Context, *SaltsReq) (*FutureSalts, error)
	GetPts(context.Context, *SeqRequest) (*Int32, error)
	GetQts(context.Context, *SeqRequest) (*Int32, error)
	GetSeq(context.Context, *SeqRequest) (*Int32, error)
	GetMsgBoxId(context.Context, *SeqRequest) (*Int32, error)
	GetChannelPts(context.Context, *SeqRequest) (*Int32, error)
	GetChannelMsgId(context.Context, *SeqRequest) (*Int32, error)
	GetState(context.Context, *SeqRequest) (*Updates_State, error)
	GetDialogState(context.Context, *DialogRowPeer) (*DialogState, error)
	GetParticipantIds(context.Context, *Int32) (*Int32List, error)
	GetParticipantConnsList(context.Context, *Int32) (*UserConnsList, error)
	GetChatRow(context.Context, *Int32) (*ChatRow, error)
	GetChatRows(context.Context, *Int32List) (*ChatRows, error)
	GetParticipant(context.Context, *ParticipantItem) (*ParticipantRow, error)
	GetParticipant2(context.Context, *ParticipantItem) (*ParticipantRow, error)
	GetParticipantRows(context.Context, *Int32) (*ParticipantRows, error)
	GetParticipantCount(context.Context, *Int32) (*Int32, error)
	IsParticipant(context.Context, *ParticipantItem) (*Result, error)
	AddParticipant(context.Context, *ParticipantItem) (*Result, error)
	DelKickParticipant(context.Context, *ParticipantItem2) (*Result, error)
	UpdateChat(context.Context, *Int32) (*Result, error)
	UpdateChatParticipant(context.Context, *ParticipantItem) (*Result, error)
	UpdateChatReceivedPts(RPCCache_UpdateChatReceivedPtsServer) error
	UpdateReceiveMaxId(context.Context, *ReceiveItem) (*Int32, error)
	MigrateToMegagroup(context.Context, *MigrateToMegagroupItem) (*Result, error)
	UpdateUserConn(RPCCache_UpdateUserConnServer) error
	GetUserConns(context.Context, *Int32) (*UserConns, error)
}

// UnimplementedRPCCacheServer can be embedded to have forward compatible implementations.
type UnimplementedRPCCacheServer struct {
}

func (*UnimplementedRPCCacheServer) GetUsersBySelfAndIDList(ctx context.Context, req *UsersRequest) (*MtprotoUsers, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUsersBySelfAndIDList not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateUserCache(ctx context.Context, req *Int32) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateUserCache not implemented")
}
func (*UnimplementedRPCCacheServer) UpdatePrivacyRule(ctx context.Context, req *UserPrivacyItem) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdatePrivacyRule not implemented")
}
func (*UnimplementedRPCCacheServer) GetContacts(ctx context.Context, req *Int32) (*Contacts_Contacts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetContacts not implemented")
}
func (*UnimplementedRPCCacheServer) GetStatuses(ctx context.Context, req *Int32) (*Vector_ContactStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetStatuses not implemented")
}
func (*UnimplementedRPCCacheServer) GetAuthKey(ctx context.Context, req *Int64) (*AuthKeyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetAuthKey not implemented")
}
func (*UnimplementedRPCCacheServer) SetAuthKey(ctx context.Context, req *AuthKeyInfo) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetAuthKey not implemented")
}
func (*UnimplementedRPCCacheServer) BindAuthKeyUid(ctx context.Context, req *AuthKeyInfo) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BindAuthKeyUid not implemented")
}
func (*UnimplementedRPCCacheServer) DelAuthKey(ctx context.Context, req *Int64) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelAuthKey not implemented")
}
func (*UnimplementedRPCCacheServer) ChangeAuthKeyUid(ctx context.Context, req *ChangeAuthKey) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ChangeAuthKeyUid not implemented")
}
func (*UnimplementedRPCCacheServer) UpdatePresences(srv RPCCache_UpdatePresencesServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdatePresences not implemented")
}
func (*UnimplementedRPCCacheServer) ForceDialog2Db(ctx context.Context, req *DialogRowPeer) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ForceDialog2Db not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateReadHistory(ctx context.Context, req *ReadHistory) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReadHistory not implemented")
}
func (*UnimplementedRPCCacheServer) ReadChannelHistory(ctx context.Context, req *ChannelReadHistory) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ReadChannelHistory not implemented")
}
func (*UnimplementedRPCCacheServer) GetReadInboxMaxId(ctx context.Context, req *DialogRowPeer) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetReadInboxMaxId not implemented")
}
func (*UnimplementedRPCCacheServer) GetUnreadCount(ctx context.Context, req *UserUnreadCount) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnreadCount not implemented")
}
func (*UnimplementedRPCCacheServer) GetUnreadCountGroup(ctx context.Context, req *Int32) (*UserUnreadCountList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUnreadCountGroup not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateDialog(srv RPCCache_UpdateDialogServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateDialog not implemented")
}
func (*UnimplementedRPCCacheServer) GetDialog(ctx context.Context, req *Int32) (*UserDialog, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDialog not implemented")
}
func (*UnimplementedRPCCacheServer) GetLastSeenAt(srv RPCCache_GetLastSeenAtServer) error {
	return status.Errorf(codes.Unimplemented, "method GetLastSeenAt not implemented")
}
func (*UnimplementedRPCCacheServer) GetNextMsgId(srv RPCCache_GetNextMsgIdServer) error {
	return status.Errorf(codes.Unimplemented, "method GetNextMsgId not implemented")
}
func (*UnimplementedRPCCacheServer) GetPhotoFileData(ctx context.Context, req *PhotoFileUnit) (*Upload_File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPhotoFileData not implemented")
}
func (*UnimplementedRPCCacheServer) GetDocumentFileData(ctx context.Context, req *DocumentFileUnit) (*Upload_File, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDocumentFileData not implemented")
}
func (*UnimplementedRPCCacheServer) GetPhotoSizeList(ctx context.Context, req *Int64) (*PhotoSizeList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPhotoSizeList not implemented")
}
func (*UnimplementedRPCCacheServer) GetDocument(ctx context.Context, req *DocumentFileUnit) (*Document, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDocument not implemented")
}
func (*UnimplementedRPCCacheServer) GetSaltUntil(ctx context.Context, req *SaltUntilReq) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSaltUntil not implemented")
}
func (*UnimplementedRPCCacheServer) GetOneSalt(ctx context.Context, req *Int64) (*SaltItem, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetOneSalt not implemented")
}
func (*UnimplementedRPCCacheServer) GetFutureSalts(ctx context.Context, req *SaltsReq) (*FutureSalts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetFutureSalts not implemented")
}
func (*UnimplementedRPCCacheServer) GetPts(ctx context.Context, req *SeqRequest) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPts not implemented")
}
func (*UnimplementedRPCCacheServer) GetQts(ctx context.Context, req *SeqRequest) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetQts not implemented")
}
func (*UnimplementedRPCCacheServer) GetSeq(ctx context.Context, req *SeqRequest) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSeq not implemented")
}
func (*UnimplementedRPCCacheServer) GetMsgBoxId(ctx context.Context, req *SeqRequest) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetMsgBoxId not implemented")
}
func (*UnimplementedRPCCacheServer) GetChannelPts(ctx context.Context, req *SeqRequest) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelPts not implemented")
}
func (*UnimplementedRPCCacheServer) GetChannelMsgId(ctx context.Context, req *SeqRequest) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChannelMsgId not implemented")
}
func (*UnimplementedRPCCacheServer) GetState(ctx context.Context, req *SeqRequest) (*Updates_State, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetState not implemented")
}
func (*UnimplementedRPCCacheServer) GetDialogState(ctx context.Context, req *DialogRowPeer) (*DialogState, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetDialogState not implemented")
}
func (*UnimplementedRPCCacheServer) GetParticipantIds(ctx context.Context, req *Int32) (*Int32List, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipantIds not implemented")
}
func (*UnimplementedRPCCacheServer) GetParticipantConnsList(ctx context.Context, req *Int32) (*UserConnsList, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipantConnsList not implemented")
}
func (*UnimplementedRPCCacheServer) GetChatRow(ctx context.Context, req *Int32) (*ChatRow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChatRow not implemented")
}
func (*UnimplementedRPCCacheServer) GetChatRows(ctx context.Context, req *Int32List) (*ChatRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetChatRows not implemented")
}
func (*UnimplementedRPCCacheServer) GetParticipant(ctx context.Context, req *ParticipantItem) (*ParticipantRow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipant not implemented")
}
func (*UnimplementedRPCCacheServer) GetParticipant2(ctx context.Context, req *ParticipantItem) (*ParticipantRow, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipant2 not implemented")
}
func (*UnimplementedRPCCacheServer) GetParticipantRows(ctx context.Context, req *Int32) (*ParticipantRows, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipantRows not implemented")
}
func (*UnimplementedRPCCacheServer) GetParticipantCount(ctx context.Context, req *Int32) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetParticipantCount not implemented")
}
func (*UnimplementedRPCCacheServer) IsParticipant(ctx context.Context, req *ParticipantItem) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method IsParticipant not implemented")
}
func (*UnimplementedRPCCacheServer) AddParticipant(ctx context.Context, req *ParticipantItem) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AddParticipant not implemented")
}
func (*UnimplementedRPCCacheServer) DelKickParticipant(ctx context.Context, req *ParticipantItem2) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DelKickParticipant not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateChat(ctx context.Context, req *Int32) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChat not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateChatParticipant(ctx context.Context, req *ParticipantItem) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateChatParticipant not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateChatReceivedPts(srv RPCCache_UpdateChatReceivedPtsServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateChatReceivedPts not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateReceiveMaxId(ctx context.Context, req *ReceiveItem) (*Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method UpdateReceiveMaxId not implemented")
}
func (*UnimplementedRPCCacheServer) MigrateToMegagroup(ctx context.Context, req *MigrateToMegagroupItem) (*Result, error) {
	return nil, status.Errorf(codes.Unimplemented, "method MigrateToMegagroup not implemented")
}
func (*UnimplementedRPCCacheServer) UpdateUserConn(srv RPCCache_UpdateUserConnServer) error {
	return status.Errorf(codes.Unimplemented, "method UpdateUserConn not implemented")
}
func (*UnimplementedRPCCacheServer) GetUserConns(ctx context.Context, req *Int32) (*UserConns, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetUserConns not implemented")
}

func RegisterRPCCacheServer(s *grpc.Server, srv RPCCacheServer) {
	s.RegisterService(&_RPCCache_serviceDesc, srv)
}

func _RPCCache_GetUsersBySelfAndIDList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UsersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetUsersBySelfAndIDList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetUsersBySelfAndIDList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetUsersBySelfAndIDList(ctx, req.(*UsersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateUserCache_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).UpdateUserCache(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/UpdateUserCache",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).UpdateUserCache(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdatePrivacyRule_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserPrivacyItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).UpdatePrivacyRule(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/UpdatePrivacyRule",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).UpdatePrivacyRule(ctx, req.(*UserPrivacyItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetContacts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetContacts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetContacts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetContacts(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetStatuses_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetStatuses(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetStatuses",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetStatuses(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetAuthKey(ctx, req.(*Int64))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_SetAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthKeyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).SetAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/SetAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).SetAuthKey(ctx, req.(*AuthKeyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_BindAuthKeyUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthKeyInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).BindAuthKeyUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/BindAuthKeyUid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).BindAuthKeyUid(ctx, req.(*AuthKeyInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_DelAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).DelAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/DelAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).DelAuthKey(ctx, req.(*Int64))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_ChangeAuthKeyUid_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChangeAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).ChangeAuthKeyUid(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/ChangeAuthKeyUid",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).ChangeAuthKeyUid(ctx, req.(*ChangeAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdatePresences_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RPCCacheServer).UpdatePresences(&rPCCacheUpdatePresencesServer{stream})
}

type RPCCache_UpdatePresencesServer interface {
	SendAndClose(*Result) error
	Recv() (*UserPresence, error)
	grpc.ServerStream
}

type rPCCacheUpdatePresencesServer struct {
	grpc.ServerStream
}

func (x *rPCCacheUpdatePresencesServer) SendAndClose(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rPCCacheUpdatePresencesServer) Recv() (*UserPresence, error) {
	m := new(UserPresence)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RPCCache_ForceDialog2Db_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DialogRowPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).ForceDialog2Db(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/ForceDialog2Db",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).ForceDialog2Db(ctx, req.(*DialogRowPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateReadHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReadHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).UpdateReadHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/UpdateReadHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).UpdateReadHistory(ctx, req.(*ReadHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_ReadChannelHistory_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ChannelReadHistory)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).ReadChannelHistory(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/ReadChannelHistory",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).ReadChannelHistory(ctx, req.(*ChannelReadHistory))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetReadInboxMaxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DialogRowPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetReadInboxMaxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetReadInboxMaxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetReadInboxMaxId(ctx, req.(*DialogRowPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetUnreadCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(UserUnreadCount)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetUnreadCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetUnreadCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetUnreadCount(ctx, req.(*UserUnreadCount))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetUnreadCountGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetUnreadCountGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetUnreadCountGroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetUnreadCountGroup(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateDialog_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RPCCacheServer).UpdateDialog(&rPCCacheUpdateDialogServer{stream})
}

type RPCCache_UpdateDialogServer interface {
	SendAndClose(*Result) error
	Recv() (*UserDialog, error)
	grpc.ServerStream
}

type rPCCacheUpdateDialogServer struct {
	grpc.ServerStream
}

func (x *rPCCacheUpdateDialogServer) SendAndClose(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rPCCacheUpdateDialogServer) Recv() (*UserDialog, error) {
	m := new(UserDialog)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RPCCache_GetDialog_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetDialog(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetDialog",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetDialog(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetLastSeenAt_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RPCCacheServer).GetLastSeenAt(&rPCCacheGetLastSeenAtServer{stream})
}

type RPCCache_GetLastSeenAtServer interface {
	Send(*LastSeenAt) error
	Recv() (*Int32, error)
	grpc.ServerStream
}

type rPCCacheGetLastSeenAtServer struct {
	grpc.ServerStream
}

func (x *rPCCacheGetLastSeenAtServer) Send(m *LastSeenAt) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rPCCacheGetLastSeenAtServer) Recv() (*Int32, error) {
	m := new(Int32)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RPCCache_GetNextMsgId_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RPCCacheServer).GetNextMsgId(&rPCCacheGetNextMsgIdServer{stream})
}

type RPCCache_GetNextMsgIdServer interface {
	Send(*Int32) error
	Recv() (*Int32, error)
	grpc.ServerStream
}

type rPCCacheGetNextMsgIdServer struct {
	grpc.ServerStream
}

func (x *rPCCacheGetNextMsgIdServer) Send(m *Int32) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rPCCacheGetNextMsgIdServer) Recv() (*Int32, error) {
	m := new(Int32)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RPCCache_GetPhotoFileData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PhotoFileUnit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetPhotoFileData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetPhotoFileData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetPhotoFileData(ctx, req.(*PhotoFileUnit))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetDocumentFileData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentFileUnit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetDocumentFileData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetDocumentFileData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetDocumentFileData(ctx, req.(*DocumentFileUnit))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetPhotoSizeList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetPhotoSizeList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetPhotoSizeList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetPhotoSizeList(ctx, req.(*Int64))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentFileUnit)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetDocument(ctx, req.(*DocumentFileUnit))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetSaltUntil_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaltUntilReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetSaltUntil(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetSaltUntil",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetSaltUntil(ctx, req.(*SaltUntilReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetOneSalt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int64)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetOneSalt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetOneSalt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetOneSalt(ctx, req.(*Int64))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetFutureSalts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SaltsReq)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetFutureSalts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetFutureSalts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetFutureSalts(ctx, req.(*SaltsReq))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetPts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetPts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetPts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetPts(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetQts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetQts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetQts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetQts(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetSeq_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetSeq(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetSeq",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetSeq(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetMsgBoxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetMsgBoxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetMsgBoxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetMsgBoxId(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetChannelPts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetChannelPts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetChannelPts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetChannelPts(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetChannelMsgId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetChannelMsgId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetChannelMsgId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetChannelMsgId(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SeqRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetState(ctx, req.(*SeqRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetDialogState_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DialogRowPeer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetDialogState(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetDialogState",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetDialogState(ctx, req.(*DialogRowPeer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetParticipantIds_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetParticipantIds(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetParticipantIds",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetParticipantIds(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetParticipantConnsList_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetParticipantConnsList(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetParticipantConnsList",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetParticipantConnsList(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetChatRow_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetChatRow(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetChatRow",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetChatRow(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetChatRows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32List)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetChatRows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetChatRows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetChatRows(ctx, req.(*Int32List))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetParticipant(ctx, req.(*ParticipantItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetParticipant2_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetParticipant2(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetParticipant2",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetParticipant2(ctx, req.(*ParticipantItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetParticipantRows_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetParticipantRows(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetParticipantRows",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetParticipantRows(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_GetParticipantCount_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetParticipantCount(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetParticipantCount",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetParticipantCount(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_IsParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).IsParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/IsParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).IsParticipant(ctx, req.(*ParticipantItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_AddParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).AddParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/AddParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).AddParticipant(ctx, req.(*ParticipantItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_DelKickParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantItem2)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).DelKickParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/DelKickParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).DelKickParticipant(ctx, req.(*ParticipantItem2))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateChat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).UpdateChat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/UpdateChat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).UpdateChat(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateChatParticipant_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ParticipantItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).UpdateChatParticipant(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/UpdateChatParticipant",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).UpdateChatParticipant(ctx, req.(*ParticipantItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateChatReceivedPts_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RPCCacheServer).UpdateChatReceivedPts(&rPCCacheUpdateChatReceivedPtsServer{stream})
}

type RPCCache_UpdateChatReceivedPtsServer interface {
	Send(*Result) error
	Recv() (*ChatPtsItem, error)
	grpc.ServerStream
}

type rPCCacheUpdateChatReceivedPtsServer struct {
	grpc.ServerStream
}

func (x *rPCCacheUpdateChatReceivedPtsServer) Send(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rPCCacheUpdateChatReceivedPtsServer) Recv() (*ChatPtsItem, error) {
	m := new(ChatPtsItem)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RPCCache_UpdateReceiveMaxId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReceiveItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).UpdateReceiveMaxId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/UpdateReceiveMaxId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).UpdateReceiveMaxId(ctx, req.(*ReceiveItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_MigrateToMegagroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MigrateToMegagroupItem)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).MigrateToMegagroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/MigrateToMegagroup",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).MigrateToMegagroup(ctx, req.(*MigrateToMegagroupItem))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCCache_UpdateUserConn_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RPCCacheServer).UpdateUserConn(&rPCCacheUpdateUserConnServer{stream})
}

type RPCCache_UpdateUserConnServer interface {
	SendAndClose(*Result) error
	Recv() (*UserConnectItem, error)
	grpc.ServerStream
}

type rPCCacheUpdateUserConnServer struct {
	grpc.ServerStream
}

func (x *rPCCacheUpdateUserConnServer) SendAndClose(m *Result) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rPCCacheUpdateUserConnServer) Recv() (*UserConnectItem, error) {
	m := new(UserConnectItem)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func _RPCCache_GetUserConns_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Int32)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCCacheServer).GetUserConns(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/mtproto.RPCCache/GetUserConns",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCCacheServer).GetUserConns(ctx, req.(*Int32))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCCache_serviceDesc = grpc.ServiceDesc{
	ServiceName: "mtproto.RPCCache",
	HandlerType: (*RPCCacheServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetUsersBySelfAndIDList",
			Handler:    _RPCCache_GetUsersBySelfAndIDList_Handler,
		},
		{
			MethodName: "UpdateUserCache",
			Handler:    _RPCCache_UpdateUserCache_Handler,
		},
		{
			MethodName: "UpdatePrivacyRule",
			Handler:    _RPCCache_UpdatePrivacyRule_Handler,
		},
		{
			MethodName: "GetContacts",
			Handler:    _RPCCache_GetContacts_Handler,
		},
		{
			MethodName: "GetStatuses",
			Handler:    _RPCCache_GetStatuses_Handler,
		},
		{
			MethodName: "GetAuthKey",
			Handler:    _RPCCache_GetAuthKey_Handler,
		},
		{
			MethodName: "SetAuthKey",
			Handler:    _RPCCache_SetAuthKey_Handler,
		},
		{
			MethodName: "BindAuthKeyUid",
			Handler:    _RPCCache_BindAuthKeyUid_Handler,
		},
		{
			MethodName: "DelAuthKey",
			Handler:    _RPCCache_DelAuthKey_Handler,
		},
		{
			MethodName: "ChangeAuthKeyUid",
			Handler:    _RPCCache_ChangeAuthKeyUid_Handler,
		},
		{
			MethodName: "ForceDialog2Db",
			Handler:    _RPCCache_ForceDialog2Db_Handler,
		},
		{
			MethodName: "UpdateReadHistory",
			Handler:    _RPCCache_UpdateReadHistory_Handler,
		},
		{
			MethodName: "ReadChannelHistory",
			Handler:    _RPCCache_ReadChannelHistory_Handler,
		},
		{
			MethodName: "GetReadInboxMaxId",
			Handler:    _RPCCache_GetReadInboxMaxId_Handler,
		},
		{
			MethodName: "GetUnreadCount",
			Handler:    _RPCCache_GetUnreadCount_Handler,
		},
		{
			MethodName: "GetUnreadCountGroup",
			Handler:    _RPCCache_GetUnreadCountGroup_Handler,
		},
		{
			MethodName: "GetDialog",
			Handler:    _RPCCache_GetDialog_Handler,
		},
		{
			MethodName: "GetPhotoFileData",
			Handler:    _RPCCache_GetPhotoFileData_Handler,
		},
		{
			MethodName: "GetDocumentFileData",
			Handler:    _RPCCache_GetDocumentFileData_Handler,
		},
		{
			MethodName: "GetPhotoSizeList",
			Handler:    _RPCCache_GetPhotoSizeList_Handler,
		},
		{
			MethodName: "GetDocument",
			Handler:    _RPCCache_GetDocument_Handler,
		},
		{
			MethodName: "GetSaltUntil",
			Handler:    _RPCCache_GetSaltUntil_Handler,
		},
		{
			MethodName: "GetOneSalt",
			Handler:    _RPCCache_GetOneSalt_Handler,
		},
		{
			MethodName: "GetFutureSalts",
			Handler:    _RPCCache_GetFutureSalts_Handler,
		},
		{
			MethodName: "GetPts",
			Handler:    _RPCCache_GetPts_Handler,
		},
		{
			MethodName: "GetQts",
			Handler:    _RPCCache_GetQts_Handler,
		},
		{
			MethodName: "GetSeq",
			Handler:    _RPCCache_GetSeq_Handler,
		},
		{
			MethodName: "GetMsgBoxId",
			Handler:    _RPCCache_GetMsgBoxId_Handler,
		},
		{
			MethodName: "GetChannelPts",
			Handler:    _RPCCache_GetChannelPts_Handler,
		},
		{
			MethodName: "GetChannelMsgId",
			Handler:    _RPCCache_GetChannelMsgId_Handler,
		},
		{
			MethodName: "GetState",
			Handler:    _RPCCache_GetState_Handler,
		},
		{
			MethodName: "GetDialogState",
			Handler:    _RPCCache_GetDialogState_Handler,
		},
		{
			MethodName: "GetParticipantIds",
			Handler:    _RPCCache_GetParticipantIds_Handler,
		},
		{
			MethodName: "GetParticipantConnsList",
			Handler:    _RPCCache_GetParticipantConnsList_Handler,
		},
		{
			MethodName: "GetChatRow",
			Handler:    _RPCCache_GetChatRow_Handler,
		},
		{
			MethodName: "GetChatRows",
			Handler:    _RPCCache_GetChatRows_Handler,
		},
		{
			MethodName: "GetParticipant",
			Handler:    _RPCCache_GetParticipant_Handler,
		},
		{
			MethodName: "GetParticipant2",
			Handler:    _RPCCache_GetParticipant2_Handler,
		},
		{
			MethodName: "GetParticipantRows",
			Handler:    _RPCCache_GetParticipantRows_Handler,
		},
		{
			MethodName: "GetParticipantCount",
			Handler:    _RPCCache_GetParticipantCount_Handler,
		},
		{
			MethodName: "IsParticipant",
			Handler:    _RPCCache_IsParticipant_Handler,
		},
		{
			MethodName: "AddParticipant",
			Handler:    _RPCCache_AddParticipant_Handler,
		},
		{
			MethodName: "DelKickParticipant",
			Handler:    _RPCCache_DelKickParticipant_Handler,
		},
		{
			MethodName: "UpdateChat",
			Handler:    _RPCCache_UpdateChat_Handler,
		},
		{
			MethodName: "UpdateChatParticipant",
			Handler:    _RPCCache_UpdateChatParticipant_Handler,
		},
		{
			MethodName: "UpdateReceiveMaxId",
			Handler:    _RPCCache_UpdateReceiveMaxId_Handler,
		},
		{
			MethodName: "MigrateToMegagroup",
			Handler:    _RPCCache_MigrateToMegagroup_Handler,
		},
		{
			MethodName: "GetUserConns",
			Handler:    _RPCCache_GetUserConns_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "UpdatePresences",
			Handler:       _RPCCache_UpdatePresences_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateDialog",
			Handler:       _RPCCache_UpdateDialog_Handler,
			ClientStreams: true,
		},
		{
			StreamName:    "GetLastSeenAt",
			Handler:       _RPCCache_GetLastSeenAt_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "GetNextMsgId",
			Handler:       _RPCCache_GetNextMsgId_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateChatReceivedPts",
			Handler:       _RPCCache_UpdateChatReceivedPts_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "UpdateUserConn",
			Handler:       _RPCCache_UpdateUserConn_Handler,
			ClientStreams: true,
		},
	},
	Metadata: "cache_service.proto",
}

func (m *AuthKeyInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthKeyInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthKeyInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.AuthKey) > 0 {
		i -= len(m.AuthKey)
		copy(dAtA[i:], m.AuthKey)
		i = encodeVarintCacheService(dAtA, i, uint64(len(m.AuthKey)))
		i--
		dAtA[i] = 0x1a
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChangeAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChangeAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChangeAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.OldUid != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.OldUid))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserPresence) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPresence) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPresence) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.LastSeenIp) > 0 {
		i -= len(m.LastSeenIp)
		copy(dAtA[i:], m.LastSeenIp)
		i = encodeVarintCacheService(dAtA, i, uint64(len(m.LastSeenIp)))
		i--
		dAtA[i] = 0x22
	}
	if m.Offline {
		i--
		if m.Offline {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Queue != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Queue))
		i--
		dAtA[i] = 0x20
	}
	if m.Qts != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Qts))
		i--
		dAtA[i] = 0x18
	}
	if m.Pts != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Pts))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserUnreadCount) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserUnreadCount) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserUnreadCount) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnreadCount != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UnreadCount))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserUnreadCountList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserUnreadCountList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserUnreadCountList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UnreadList) > 0 {
		for iNdEx := len(m.UnreadList) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UnreadList[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCacheService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserDialog) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserDialog) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserDialog) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateTopMessage {
		i--
		if m.UpdateTopMessage {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x70
	}
	if m.UpdateMention {
		i--
		if m.UpdateMention {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x68
	}
	if m.ClearCount {
		i--
		if m.ClearCount {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.UpdateDraft {
		i--
		if m.UpdateDraft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if m.ClearDraft {
		i--
		if m.ClearDraft {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.IsDelete {
		i--
		if m.IsDelete {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x48
	}
	if len(m.DraftMessage) > 0 {
		i -= len(m.DraftMessage)
		copy(dAtA[i:], m.DraftMessage)
		i = encodeVarintCacheService(dAtA, i, uint64(len(m.DraftMessage)))
		i--
		dAtA[i] = 0x42
	}
	if m.IncrUnreadMentionsCount != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.IncrUnreadMentionsCount))
		i--
		dAtA[i] = 0x38
	}
	if m.IncrUnreadCount != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.IncrUnreadCount))
		i--
		dAtA[i] = 0x30
	}
	if m.IncrReadInboxMaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.IncrReadInboxMaxId))
		i--
		dAtA[i] = 0x28
	}
	if m.TopMessage != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.TopMessage))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerType != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DialogRowPeer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DialogRowPeer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DialogRowPeer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.PeerId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerType != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReadHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReadHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReadHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pts != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Pts))
		i--
		dAtA[i] = 0x38
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x30
	}
	if m.IsInbox {
		i--
		if m.IsInbox {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x28
	}
	if m.MaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x18
	}
	if m.PeerType != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChannelReadHistory) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChannelReadHistory) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChannelReadHistory) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.MaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.MaxId))
		i--
		dAtA[i] = 0x28
	}
	if m.PeerId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerId))
		i--
		dAtA[i] = 0x20
	}
	if m.PeerType != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PeerType))
		i--
		dAtA[i] = 0x18
	}
	if m.FromId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.FromId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *LastSeenAt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *LastSeenAt) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *LastSeenAt) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.LastSeenAt != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.LastSeenAt))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Int32) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int32) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Int64) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int64) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int64) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Id != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Result) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Result) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Result) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Ok {
		i--
		if m.Ok {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Int32List) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Int32List) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Int32List) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Id) > 0 {
		dAtA2 := make([]byte, len(m.Id)*10)
		var j1 int
		for _, num1 := range m.Id {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA2[j1] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j1++
			}
			dAtA2[j1] = uint8(num)
			j1++
		}
		i -= j1
		copy(dAtA[i:], dAtA2[:j1])
		i = encodeVarintCacheService(dAtA, i, uint64(j1))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *PhotoFileUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoFileUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhotoFileUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Secret != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Secret))
		i--
		dAtA[i] = 0x18
	}
	if m.LocalId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.LocalId))
		i--
		dAtA[i] = 0x10
	}
	if m.VolumeId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.VolumeId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DocumentFileUnit) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DocumentFileUnit) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DocumentFileUnit) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Limit != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Limit))
		i--
		dAtA[i] = 0x28
	}
	if m.Offset != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Offset))
		i--
		dAtA[i] = 0x20
	}
	if m.Version != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x18
	}
	if m.AccessHash != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.DocumentId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.DocumentId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *PhotoSizeList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *PhotoSizeList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *PhotoSizeList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		for iNdEx := len(m.Sizes) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Sizes[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCacheService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *SaltUntilReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaltUntilReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SaltUntilReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Salt != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x10
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SaltsReq) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaltsReq) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SaltsReq) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Num != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.MsgId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.MsgId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SaltItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SaltItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SaltItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Until != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Until))
		i--
		dAtA[i] = 0x10
	}
	if m.Salt != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Salt))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *SeqRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SeqRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SeqRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Flag != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x18
	}
	if m.ChannelId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *DialogState) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DialogState) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DialogState) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UnreadMentionsCount != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UnreadMentionsCount))
		i--
		dAtA[i] = 0x30
	}
	if m.ReadOutboxMaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ReadOutboxMaxId))
		i--
		dAtA[i] = 0x28
	}
	if m.ReadInboxMaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ReadInboxMaxId))
		i--
		dAtA[i] = 0x20
	}
	if m.TopMessage != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.TopMessage))
		i--
		dAtA[i] = 0x18
	}
	if m.UnreadCount != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UnreadCount))
		i--
		dAtA[i] = 0x10
	}
	if m.Pts != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Pts))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ReceiveItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ReceiveItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ReceiveItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsDel {
		i--
		if m.IsDel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x30
	}
	if m.Flag != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Flag))
		i--
		dAtA[i] = 0x28
	}
	if m.RecvUpdateMaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.RecvUpdateMaxId))
		i--
		dAtA[i] = 0x20
	}
	if m.ChannelId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x18
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatPtsItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatPtsItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatPtsItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Pts != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Pts))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MigrateToMegagroupItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MigrateToMegagroupItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MigrateToMegagroupItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ChannelId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChannelId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserConnectItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserConnectItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserConnectItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Connect {
		i--
		if m.Connect {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.AuthId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AuthId))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.GwServerId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.GwServerId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserConns) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserConns) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserConns) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Conns) > 0 {
		for iNdEx := len(m.Conns) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.Conns[iNdEx])
			copy(dAtA[i:], m.Conns[iNdEx])
			i = encodeVarintCacheService(dAtA, i, uint64(len(m.Conns[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *UserConnsList) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserConnsList) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserConnsList) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.UserConns) > 0 {
		for iNdEx := len(m.UserConns) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.UserConns[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCacheService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UsersRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UsersRequest) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UsersRequest) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsSimple {
		i--
		if m.IsSimple {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UidList != nil {
		{
			size, err := m.UidList.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintCacheService(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *MtprotoUsers) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MtprotoUsers) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MtprotoUsers) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Users) > 0 {
		for iNdEx := len(m.Users) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Users[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCacheService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *UserPrivacyItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *UserPrivacyItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *UserPrivacyItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.KeyType != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.KeyType))
		i--
		dAtA[i] = 0x10
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.AddTime != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AddTime))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xb0
	}
	if m.StickerSetId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.StickerSetId))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa8
	}
	if m.Version != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Version))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0xa0
	}
	if m.RightsMask != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.RightsMask))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x98
	}
	if m.Verified {
		i--
		if m.Verified {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x90
	}
	if m.Deactivated {
		i--
		if m.Deactivated {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x88
	}
	if m.Signatures {
		i--
		if m.Signatures {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x80
	}
	if m.HiddenPrehistory {
		i--
		if m.HiddenPrehistory {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x78
	}
	if len(m.Username) > 0 {
		i -= len(m.Username)
		copy(dAtA[i:], m.Username)
		i = encodeVarintCacheService(dAtA, i, uint64(len(m.Username)))
		i--
		dAtA[i] = 0x72
	}
	if m.MigratedTo != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.MigratedTo))
		i--
		dAtA[i] = 0x68
	}
	if m.MigratedFromMaxId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.MigratedFromMaxId))
		i--
		dAtA[i] = 0x60
	}
	if m.MigratedFromChatId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.MigratedFromChatId))
		i--
		dAtA[i] = 0x58
	}
	if m.AdminsEnabled {
		i--
		if m.AdminsEnabled {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x50
	}
	if m.PhotoId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PhotoId))
		i--
		dAtA[i] = 0x48
	}
	if m.Type != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x40
	}
	if len(m.Title) > 0 {
		i -= len(m.Title)
		copy(dAtA[i:], m.Title)
		i = encodeVarintCacheService(dAtA, i, uint64(len(m.Title)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.About) > 0 {
		i -= len(m.About)
		copy(dAtA[i:], m.About)
		i = encodeVarintCacheService(dAtA, i, uint64(len(m.About)))
		i--
		dAtA[i] = 0x32
	}
	if m.PinnedMsgId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PinnedMsgId))
		i--
		dAtA[i] = 0x28
	}
	if m.CreatorId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.CreatorId))
		i--
		dAtA[i] = 0x20
	}
	if m.Democracy {
		i--
		if m.Democracy {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.AccessHash != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AccessHash))
		i--
		dAtA[i] = 0x10
	}
	if m.Id != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Id))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ChatRows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ChatRows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ChatRows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCacheService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func (m *ParticipantItem) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticipantItem) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParticipantItem) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParticipantItem2) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticipantItem2) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParticipantItem2) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.IsDel {
		i--
		if m.IsDel {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParticipantRow) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticipantRow) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParticipantRow) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.UpdateTime != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UpdateTime))
		i--
		dAtA[i] = 0x60
	}
	if m.AddTime != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AddTime))
		i--
		dAtA[i] = 0x58
	}
	if m.PromotedBy != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.PromotedBy))
		i--
		dAtA[i] = 0x50
	}
	if m.AvailableMinId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.AvailableMinId))
		i--
		dAtA[i] = 0x48
	}
	if m.Kicked {
		i--
		if m.Kicked {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x40
	}
	if m.UntilDate != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UntilDate))
		i--
		dAtA[i] = 0x38
	}
	if m.RightsMask != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.RightsMask))
		i--
		dAtA[i] = 0x30
	}
	if m.InviterId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.InviterId))
		i--
		dAtA[i] = 0x28
	}
	if m.Bot {
		i--
		if m.Bot {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x20
	}
	if m.Type != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.Type))
		i--
		dAtA[i] = 0x18
	}
	if m.UserId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x10
	}
	if m.ChatId != 0 {
		i = encodeVarintCacheService(dAtA, i, uint64(m.ChatId))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *ParticipantRows) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ParticipantRows) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ParticipantRows) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for iNdEx := len(m.Rows) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Rows[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintCacheService(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintCacheService(dAtA []byte, offset int, v uint64) int {
	offset -= sovCacheService(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *AuthKeyInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	l = len(m.AuthKey)
	if l > 0 {
		n += 1 + l + sovCacheService(uint64(l))
	}
	return n
}

func (m *ChangeAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.OldUid != 0 {
		n += 1 + sovCacheService(uint64(m.OldUid))
	}
	return n
}

func (m *UserPresence) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Offline {
		n += 2
	}
	l = len(m.LastSeenIp)
	if l > 0 {
		n += 1 + l + sovCacheService(uint64(l))
	}
	return n
}

func (m *UserState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.Pts != 0 {
		n += 1 + sovCacheService(uint64(m.Pts))
	}
	if m.Qts != 0 {
		n += 1 + sovCacheService(uint64(m.Qts))
	}
	if m.Queue != 0 {
		n += 1 + sovCacheService(uint64(m.Queue))
	}
	return n
}

func (m *UserUnreadCount) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.UnreadCount != 0 {
		n += 1 + sovCacheService(uint64(m.UnreadCount))
	}
	return n
}

func (m *UserUnreadCountList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UnreadList) > 0 {
		for _, e := range m.UnreadList {
			l = e.Size()
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func (m *UserDialog) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.PeerType != 0 {
		n += 1 + sovCacheService(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovCacheService(uint64(m.PeerId))
	}
	if m.TopMessage != 0 {
		n += 1 + sovCacheService(uint64(m.TopMessage))
	}
	if m.IncrReadInboxMaxId != 0 {
		n += 1 + sovCacheService(uint64(m.IncrReadInboxMaxId))
	}
	if m.IncrUnreadCount != 0 {
		n += 1 + sovCacheService(uint64(m.IncrUnreadCount))
	}
	if m.IncrUnreadMentionsCount != 0 {
		n += 1 + sovCacheService(uint64(m.IncrUnreadMentionsCount))
	}
	l = len(m.DraftMessage)
	if l > 0 {
		n += 1 + l + sovCacheService(uint64(l))
	}
	if m.IsDelete {
		n += 2
	}
	if m.ClearDraft {
		n += 2
	}
	if m.UpdateDraft {
		n += 2
	}
	if m.ClearCount {
		n += 2
	}
	if m.UpdateMention {
		n += 2
	}
	if m.UpdateTopMessage {
		n += 2
	}
	return n
}

func (m *DialogRowPeer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.PeerType != 0 {
		n += 1 + sovCacheService(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovCacheService(uint64(m.PeerId))
	}
	return n
}

func (m *ReadHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.PeerType != 0 {
		n += 1 + sovCacheService(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovCacheService(uint64(m.PeerId))
	}
	if m.MaxId != 0 {
		n += 1 + sovCacheService(uint64(m.MaxId))
	}
	if m.IsInbox {
		n += 2
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Pts != 0 {
		n += 1 + sovCacheService(uint64(m.Pts))
	}
	return n
}

func (m *ChannelReadHistory) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.FromId != 0 {
		n += 1 + sovCacheService(uint64(m.FromId))
	}
	if m.PeerType != 0 {
		n += 1 + sovCacheService(uint64(m.PeerType))
	}
	if m.PeerId != 0 {
		n += 1 + sovCacheService(uint64(m.PeerId))
	}
	if m.MaxId != 0 {
		n += 1 + sovCacheService(uint64(m.MaxId))
	}
	return n
}

func (m *LastSeenAt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.LastSeenAt != 0 {
		n += 1 + sovCacheService(uint64(m.LastSeenAt))
	}
	return n
}

func (m *Int32) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCacheService(uint64(m.Id))
	}
	return n
}

func (m *Int64) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCacheService(uint64(m.Id))
	}
	return n
}

func (m *Result) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Ok {
		n += 2
	}
	return n
}

func (m *Int32List) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Id) > 0 {
		l = 0
		for _, e := range m.Id {
			l += sovCacheService(uint64(e))
		}
		n += 1 + sovCacheService(uint64(l)) + l
	}
	return n
}

func (m *PhotoFileUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.VolumeId != 0 {
		n += 1 + sovCacheService(uint64(m.VolumeId))
	}
	if m.LocalId != 0 {
		n += 1 + sovCacheService(uint64(m.LocalId))
	}
	if m.Secret != 0 {
		n += 1 + sovCacheService(uint64(m.Secret))
	}
	if m.Offset != 0 {
		n += 1 + sovCacheService(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovCacheService(uint64(m.Limit))
	}
	return n
}

func (m *DocumentFileUnit) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.DocumentId != 0 {
		n += 1 + sovCacheService(uint64(m.DocumentId))
	}
	if m.AccessHash != 0 {
		n += 1 + sovCacheService(uint64(m.AccessHash))
	}
	if m.Version != 0 {
		n += 1 + sovCacheService(uint64(m.Version))
	}
	if m.Offset != 0 {
		n += 1 + sovCacheService(uint64(m.Offset))
	}
	if m.Limit != 0 {
		n += 1 + sovCacheService(uint64(m.Limit))
	}
	return n
}

func (m *PhotoSizeList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Sizes) > 0 {
		for _, e := range m.Sizes {
			l = e.Size()
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func (m *SaltUntilReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Salt != 0 {
		n += 1 + sovCacheService(uint64(m.Salt))
	}
	return n
}

func (m *SaltsReq) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.MsgId != 0 {
		n += 1 + sovCacheService(uint64(m.MsgId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Num != 0 {
		n += 1 + sovCacheService(uint64(m.Num))
	}
	return n
}

func (m *SaltItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Salt != 0 {
		n += 1 + sovCacheService(uint64(m.Salt))
	}
	if m.Until != 0 {
		n += 1 + sovCacheService(uint64(m.Until))
	}
	return n
}

func (m *SeqRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovCacheService(uint64(m.ChannelId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Flag != 0 {
		n += 1 + sovCacheService(uint64(m.Flag))
	}
	return n
}

func (m *DialogState) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Pts != 0 {
		n += 1 + sovCacheService(uint64(m.Pts))
	}
	if m.UnreadCount != 0 {
		n += 1 + sovCacheService(uint64(m.UnreadCount))
	}
	if m.TopMessage != 0 {
		n += 1 + sovCacheService(uint64(m.TopMessage))
	}
	if m.ReadInboxMaxId != 0 {
		n += 1 + sovCacheService(uint64(m.ReadInboxMaxId))
	}
	if m.ReadOutboxMaxId != 0 {
		n += 1 + sovCacheService(uint64(m.ReadOutboxMaxId))
	}
	if m.UnreadMentionsCount != 0 {
		n += 1 + sovCacheService(uint64(m.UnreadMentionsCount))
	}
	return n
}

func (m *ReceiveItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovCacheService(uint64(m.ChannelId))
	}
	if m.RecvUpdateMaxId != 0 {
		n += 1 + sovCacheService(uint64(m.RecvUpdateMaxId))
	}
	if m.Flag != 0 {
		n += 1 + sovCacheService(uint64(m.Flag))
	}
	if m.IsDel {
		n += 2
	}
	return n
}

func (m *ChatPtsItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovCacheService(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Pts != 0 {
		n += 1 + sovCacheService(uint64(m.Pts))
	}
	return n
}

func (m *MigrateToMegagroupItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovCacheService(uint64(m.ChatId))
	}
	if m.ChannelId != 0 {
		n += 1 + sovCacheService(uint64(m.ChannelId))
	}
	return n
}

func (m *UserConnectItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.GwServerId != 0 {
		n += 1 + sovCacheService(uint64(m.GwServerId))
	}
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.AuthId != 0 {
		n += 1 + sovCacheService(uint64(m.AuthId))
	}
	if m.Connect {
		n += 2
	}
	return n
}

func (m *UserConns) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if len(m.Conns) > 0 {
		for _, s := range m.Conns {
			l = len(s)
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func (m *UserConnsList) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.UserConns) > 0 {
		for _, e := range m.UserConns {
			l = e.Size()
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func (m *UsersRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.UidList != nil {
		l = m.UidList.Size()
		n += 1 + l + sovCacheService(uint64(l))
	}
	if m.IsSimple {
		n += 2
	}
	return n
}

func (m *MtprotoUsers) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Users) > 0 {
		for _, e := range m.Users {
			l = e.Size()
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func (m *UserPrivacyItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.KeyType != 0 {
		n += 1 + sovCacheService(uint64(m.KeyType))
	}
	return n
}

func (m *ChatRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Id != 0 {
		n += 1 + sovCacheService(uint64(m.Id))
	}
	if m.AccessHash != 0 {
		n += 1 + sovCacheService(uint64(m.AccessHash))
	}
	if m.Democracy {
		n += 2
	}
	if m.CreatorId != 0 {
		n += 1 + sovCacheService(uint64(m.CreatorId))
	}
	if m.PinnedMsgId != 0 {
		n += 1 + sovCacheService(uint64(m.PinnedMsgId))
	}
	l = len(m.About)
	if l > 0 {
		n += 1 + l + sovCacheService(uint64(l))
	}
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovCacheService(uint64(l))
	}
	if m.Type != 0 {
		n += 1 + sovCacheService(uint64(m.Type))
	}
	if m.PhotoId != 0 {
		n += 1 + sovCacheService(uint64(m.PhotoId))
	}
	if m.AdminsEnabled {
		n += 2
	}
	if m.MigratedFromChatId != 0 {
		n += 1 + sovCacheService(uint64(m.MigratedFromChatId))
	}
	if m.MigratedFromMaxId != 0 {
		n += 1 + sovCacheService(uint64(m.MigratedFromMaxId))
	}
	if m.MigratedTo != 0 {
		n += 1 + sovCacheService(uint64(m.MigratedTo))
	}
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovCacheService(uint64(l))
	}
	if m.HiddenPrehistory {
		n += 2
	}
	if m.Signatures {
		n += 3
	}
	if m.Deactivated {
		n += 3
	}
	if m.Verified {
		n += 3
	}
	if m.RightsMask != 0 {
		n += 2 + sovCacheService(uint64(m.RightsMask))
	}
	if m.Version != 0 {
		n += 2 + sovCacheService(uint64(m.Version))
	}
	if m.StickerSetId != 0 {
		n += 2 + sovCacheService(uint64(m.StickerSetId))
	}
	if m.AddTime != 0 {
		n += 2 + sovCacheService(uint64(m.AddTime))
	}
	return n
}

func (m *ChatRows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func (m *ParticipantItem) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovCacheService(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	return n
}

func (m *ParticipantItem2) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovCacheService(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.IsDel {
		n += 2
	}
	return n
}

func (m *ParticipantRow) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.ChatId != 0 {
		n += 1 + sovCacheService(uint64(m.ChatId))
	}
	if m.UserId != 0 {
		n += 1 + sovCacheService(uint64(m.UserId))
	}
	if m.Type != 0 {
		n += 1 + sovCacheService(uint64(m.Type))
	}
	if m.Bot {
		n += 2
	}
	if m.InviterId != 0 {
		n += 1 + sovCacheService(uint64(m.InviterId))
	}
	if m.RightsMask != 0 {
		n += 1 + sovCacheService(uint64(m.RightsMask))
	}
	if m.UntilDate != 0 {
		n += 1 + sovCacheService(uint64(m.UntilDate))
	}
	if m.Kicked {
		n += 2
	}
	if m.AvailableMinId != 0 {
		n += 1 + sovCacheService(uint64(m.AvailableMinId))
	}
	if m.PromotedBy != 0 {
		n += 1 + sovCacheService(uint64(m.PromotedBy))
	}
	if m.AddTime != 0 {
		n += 1 + sovCacheService(uint64(m.AddTime))
	}
	if m.UpdateTime != 0 {
		n += 1 + sovCacheService(uint64(m.UpdateTime))
	}
	return n
}

func (m *ParticipantRows) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Rows) > 0 {
		for _, e := range m.Rows {
			l = e.Size()
			n += 1 + l + sovCacheService(uint64(l))
		}
	}
	return n
}

func sovCacheService(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozCacheService(x uint64) (n int) {
	return sovCacheService(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AuthKeyInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthKeyInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthKeyInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthKey = append(m.AuthKey[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthKey == nil {
				m.AuthKey = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChangeAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChangeAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChangeAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OldUid", wireType)
			}
			m.OldUid = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OldUid |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPresence) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPresence: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPresence: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offline", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Offline = bool(v != 0)
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeenIp", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastSeenIp = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Qts", wireType)
			}
			m.Qts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Qts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			m.Queue = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Queue |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserUnreadCount) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserUnreadCount: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserUnreadCount: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserUnreadCountList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserUnreadCountList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserUnreadCountList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UnreadList = append(m.UnreadList, &UserUnreadCount{})
			if err := m.UnreadList[len(m.UnreadList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserDialog) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserDialog: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserDialog: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMessage", wireType)
			}
			m.TopMessage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMessage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrReadInboxMaxId", wireType)
			}
			m.IncrReadInboxMaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncrReadInboxMaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrUnreadCount", wireType)
			}
			m.IncrUnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncrUnreadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncrUnreadMentionsCount", wireType)
			}
			m.IncrUnreadMentionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.IncrUnreadMentionsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DraftMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DraftMessage = append(m.DraftMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.DraftMessage == nil {
				m.DraftMessage = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDelete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDelete = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearDraft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearDraft = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateDraft", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateDraft = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClearCount", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.ClearCount = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateMention", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateMention = bool(v != 0)
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTopMessage", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.UpdateTopMessage = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DialogRowPeer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DialogRowPeer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DialogRowPeer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsInbox", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsInbox = bool(v != 0)
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChannelReadHistory) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChannelReadHistory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChannelReadHistory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FromId", wireType)
			}
			m.FromId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FromId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerType", wireType)
			}
			m.PeerType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PeerId", wireType)
			}
			m.PeerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PeerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxId", wireType)
			}
			m.MaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *LastSeenAt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: LastSeenAt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: LastSeenAt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastSeenAt", wireType)
			}
			m.LastSeenAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LastSeenAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int64) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int64: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int64: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Result) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Result: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Result: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ok", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Ok = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Int32List) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Int32List: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Int32List: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int32
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCacheService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int32(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Id = append(m.Id, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowCacheService
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthCacheService
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthCacheService
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Id) == 0 {
					m.Id = make([]int32, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int32
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowCacheService
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int32(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Id = append(m.Id, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoFileUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoFileUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoFileUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field VolumeId", wireType)
			}
			m.VolumeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.VolumeId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LocalId", wireType)
			}
			m.LocalId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LocalId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Secret", wireType)
			}
			m.Secret = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Secret |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentFileUnit) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentFileUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentFileUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentId", wireType)
			}
			m.DocumentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DocumentId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Offset |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Limit", wireType)
			}
			m.Limit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Limit |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PhotoSizeList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PhotoSizeList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PhotoSizeList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Sizes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Sizes = append(m.Sizes, &PhotoSize{})
			if err := m.Sizes[len(m.Sizes)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaltUntilReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaltUntilReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaltUntilReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaltsReq) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaltsReq: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaltsReq: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MsgId", wireType)
			}
			m.MsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MsgId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SaltItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SaltItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SaltItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Salt", wireType)
			}
			m.Salt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Salt |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Until", wireType)
			}
			m.Until = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Until |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SeqRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SeqRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SeqRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DialogState) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DialogState: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DialogState: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadCount", wireType)
			}
			m.UnreadCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TopMessage", wireType)
			}
			m.TopMessage = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TopMessage |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadInboxMaxId", wireType)
			}
			m.ReadInboxMaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadInboxMaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReadOutboxMaxId", wireType)
			}
			m.ReadOutboxMaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ReadOutboxMaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreadMentionsCount", wireType)
			}
			m.UnreadMentionsCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreadMentionsCount |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReceiveItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReceiveItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReceiveItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RecvUpdateMaxId", wireType)
			}
			m.RecvUpdateMaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RecvUpdateMaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Flag", wireType)
			}
			m.Flag = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Flag |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDel = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatPtsItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatPtsItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatPtsItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pts", wireType)
			}
			m.Pts = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Pts |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MigrateToMegagroupItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MigrateToMegagroupItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MigrateToMegagroupItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChannelId", wireType)
			}
			m.ChannelId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChannelId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserConnectItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserConnectItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserConnectItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GwServerId", wireType)
			}
			m.GwServerId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.GwServerId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthId", wireType)
			}
			m.AuthId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Connect", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Connect = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserConns) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserConns: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserConns: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Conns", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Conns = append(m.Conns, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserConnsList) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserConnsList: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserConnsList: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserConns", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.UserConns = append(m.UserConns, &UserConns{})
			if err := m.UserConns[len(m.UserConns)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UsersRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UsersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UsersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field UidList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.UidList == nil {
				m.UidList = &Int32List{}
			}
			if err := m.UidList.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsSimple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsSimple = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MtprotoUsers) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MtprotoUsers: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MtprotoUsers: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Users", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Users = append(m.Users, &User{})
			if err := m.Users[len(m.Users)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *UserPrivacyItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: UserPrivacyItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: UserPrivacyItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyType", wireType)
			}
			m.KeyType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Id", wireType)
			}
			m.Id = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Id |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccessHash", wireType)
			}
			m.AccessHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AccessHash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Democracy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Democracy = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreatorId", wireType)
			}
			m.CreatorId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CreatorId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PinnedMsgId", wireType)
			}
			m.PinnedMsgId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PinnedMsgId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field About", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.About = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PhotoId", wireType)
			}
			m.PhotoId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PhotoId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AdminsEnabled", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AdminsEnabled = bool(v != 0)
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedFromChatId", wireType)
			}
			m.MigratedFromChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigratedFromChatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedFromMaxId", wireType)
			}
			m.MigratedFromMaxId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigratedFromMaxId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MigratedTo", wireType)
			}
			m.MigratedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MigratedTo |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HiddenPrehistory", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HiddenPrehistory = bool(v != 0)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signatures", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Signatures = bool(v != 0)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Deactivated", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Deactivated = bool(v != 0)
		case 18:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Verified", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Verified = bool(v != 0)
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightsMask", wireType)
			}
			m.RightsMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightsMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 21:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StickerSetId", wireType)
			}
			m.StickerSetId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StickerSetId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 22:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTime", wireType)
			}
			m.AddTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ChatRows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ChatRows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ChatRows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &ChatRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticipantItem) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticipantItem: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticipantItem: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticipantItem2) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticipantItem2: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticipantItem2: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsDel", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsDel = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticipantRow) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticipantRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticipantRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChatId", wireType)
			}
			m.ChatId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChatId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Bot", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Bot = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field InviterId", wireType)
			}
			m.InviterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.InviterId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RightsMask", wireType)
			}
			m.RightsMask = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RightsMask |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UntilDate", wireType)
			}
			m.UntilDate = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UntilDate |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kicked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Kicked = bool(v != 0)
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvailableMinId", wireType)
			}
			m.AvailableMinId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AvailableMinId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PromotedBy", wireType)
			}
			m.PromotedBy = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PromotedBy |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AddTime", wireType)
			}
			m.AddTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AddTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UpdateTime", wireType)
			}
			m.UpdateTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UpdateTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ParticipantRows) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ParticipantRows: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ParticipantRows: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Rows", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthCacheService
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthCacheService
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Rows = append(m.Rows, &ParticipantRow{})
			if err := m.Rows[len(m.Rows)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipCacheService(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthCacheService
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipCacheService(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowCacheService
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowCacheService
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthCacheService
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupCacheService
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthCacheService
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthCacheService        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowCacheService          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupCacheService = fmt.Errorf("proto: unexpected end of group")
)
