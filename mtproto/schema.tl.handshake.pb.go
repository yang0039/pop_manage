// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: schema.tl.handshake.proto

package mtproto

import (
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

///////////////////////////////////////////////////////////////////////////////
// Server_DH_Params <--
//  + TL_server_DH_params_fail
//  + TL_server_DH_params_ok
//
type Server_DH_Params_Data struct {
	Nonce           []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ServerNonce     []byte `protobuf:"bytes,2,opt,name=server_nonce,json=serverNonce,proto3" json:"server_nonce,omitempty"`
	NewNonceHash    []byte `protobuf:"bytes,3,opt,name=new_nonce_hash,json=newNonceHash,proto3" json:"new_nonce_hash,omitempty"`
	EncryptedAnswer string `protobuf:"bytes,4,opt,name=encrypted_answer,json=encryptedAnswer,proto3" json:"encrypted_answer,omitempty"`
}

func (m *Server_DH_Params_Data) Reset()         { *m = Server_DH_Params_Data{} }
func (m *Server_DH_Params_Data) String() string { return proto.CompactTextString(m) }
func (*Server_DH_Params_Data) ProtoMessage()    {}
func (*Server_DH_Params_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{0}
}
func (m *Server_DH_Params_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Server_DH_Params_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Server_DH_Params_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Server_DH_Params_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Server_DH_Params_Data.Merge(m, src)
}
func (m *Server_DH_Params_Data) XXX_Size() int {
	return m.Size()
}
func (m *Server_DH_Params_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Server_DH_Params_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Server_DH_Params_Data proto.InternalMessageInfo

func (m *Server_DH_Params_Data) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Server_DH_Params_Data) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

func (m *Server_DH_Params_Data) GetNewNonceHash() []byte {
	if m != nil {
		return m.NewNonceHash
	}
	return nil
}

func (m *Server_DH_Params_Data) GetEncryptedAnswer() string {
	if m != nil {
		return m.EncryptedAnswer
	}
	return ""
}

type Server_DH_Params struct {
	Constructor TLConstructor          `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *Server_DH_Params_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *Server_DH_Params) Reset()         { *m = Server_DH_Params{} }
func (m *Server_DH_Params) String() string { return proto.CompactTextString(m) }
func (*Server_DH_Params) ProtoMessage()    {}
func (*Server_DH_Params) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{1}
}
func (m *Server_DH_Params) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Server_DH_Params) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Server_DH_Params.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Server_DH_Params) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Server_DH_Params.Merge(m, src)
}
func (m *Server_DH_Params) XXX_Size() int {
	return m.Size()
}
func (m *Server_DH_Params) XXX_DiscardUnknown() {
	xxx_messageInfo_Server_DH_Params.DiscardUnknown(m)
}

var xxx_messageInfo_Server_DH_Params proto.InternalMessageInfo

func (m *Server_DH_Params) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *Server_DH_Params) GetData2() *Server_DH_Params_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// server_DH_params_fail#79cb045d nonce:int128 server_nonce:int128 new_nonce_hash:int128 = Server_DH_Params;
type TLServer_DHParamsFail struct {
	Data2 *Server_DH_Params_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLServer_DHParamsFail) Reset()         { *m = TLServer_DHParamsFail{} }
func (m *TLServer_DHParamsFail) String() string { return proto.CompactTextString(m) }
func (*TLServer_DHParamsFail) ProtoMessage()    {}
func (*TLServer_DHParamsFail) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{2}
}
func (m *TLServer_DHParamsFail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLServer_DHParamsFail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLServer_DHParamsFail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLServer_DHParamsFail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLServer_DHParamsFail.Merge(m, src)
}
func (m *TLServer_DHParamsFail) XXX_Size() int {
	return m.Size()
}
func (m *TLServer_DHParamsFail) XXX_DiscardUnknown() {
	xxx_messageInfo_TLServer_DHParamsFail.DiscardUnknown(m)
}

var xxx_messageInfo_TLServer_DHParamsFail proto.InternalMessageInfo

func (m *TLServer_DHParamsFail) GetData2() *Server_DH_Params_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// server_DH_params_ok#d0e8075c nonce:int128 server_nonce:int128 encrypted_answer:string = Server_DH_Params;
type TLServer_DHParamsOk struct {
	Data2 *Server_DH_Params_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLServer_DHParamsOk) Reset()         { *m = TLServer_DHParamsOk{} }
func (m *TLServer_DHParamsOk) String() string { return proto.CompactTextString(m) }
func (*TLServer_DHParamsOk) ProtoMessage()    {}
func (*TLServer_DHParamsOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{3}
}
func (m *TLServer_DHParamsOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLServer_DHParamsOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLServer_DHParamsOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLServer_DHParamsOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLServer_DHParamsOk.Merge(m, src)
}
func (m *TLServer_DHParamsOk) XXX_Size() int {
	return m.Size()
}
func (m *TLServer_DHParamsOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TLServer_DHParamsOk.DiscardUnknown(m)
}

var xxx_messageInfo_TLServer_DHParamsOk proto.InternalMessageInfo

func (m *TLServer_DHParamsOk) GetData2() *Server_DH_Params_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// Server_DH_inner_data <--
//  + TL_server_DH_inner_data
//
type Server_DHInnerData_Data struct {
	Nonce       []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ServerNonce []byte `protobuf:"bytes,2,opt,name=server_nonce,json=serverNonce,proto3" json:"server_nonce,omitempty"`
	G           int32  `protobuf:"varint,3,opt,name=g,proto3" json:"g,omitempty"`
	DhPrime     string `protobuf:"bytes,4,opt,name=dh_prime,json=dhPrime,proto3" json:"dh_prime,omitempty"`
	GA          string `protobuf:"bytes,5,opt,name=g_a,json=gA,proto3" json:"g_a,omitempty"`
	ServerTime  int32  `protobuf:"varint,6,opt,name=server_time,json=serverTime,proto3" json:"server_time,omitempty"`
}

func (m *Server_DHInnerData_Data) Reset()         { *m = Server_DHInnerData_Data{} }
func (m *Server_DHInnerData_Data) String() string { return proto.CompactTextString(m) }
func (*Server_DHInnerData_Data) ProtoMessage()    {}
func (*Server_DHInnerData_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{4}
}
func (m *Server_DHInnerData_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Server_DHInnerData_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Server_DHInnerData_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Server_DHInnerData_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Server_DHInnerData_Data.Merge(m, src)
}
func (m *Server_DHInnerData_Data) XXX_Size() int {
	return m.Size()
}
func (m *Server_DHInnerData_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Server_DHInnerData_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Server_DHInnerData_Data proto.InternalMessageInfo

func (m *Server_DHInnerData_Data) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Server_DHInnerData_Data) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

func (m *Server_DHInnerData_Data) GetG() int32 {
	if m != nil {
		return m.G
	}
	return 0
}

func (m *Server_DHInnerData_Data) GetDhPrime() string {
	if m != nil {
		return m.DhPrime
	}
	return ""
}

func (m *Server_DHInnerData_Data) GetGA() string {
	if m != nil {
		return m.GA
	}
	return ""
}

func (m *Server_DHInnerData_Data) GetServerTime() int32 {
	if m != nil {
		return m.ServerTime
	}
	return 0
}

type Server_DHInnerData struct {
	Constructor TLConstructor            `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *Server_DHInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *Server_DHInnerData) Reset()         { *m = Server_DHInnerData{} }
func (m *Server_DHInnerData) String() string { return proto.CompactTextString(m) }
func (*Server_DHInnerData) ProtoMessage()    {}
func (*Server_DHInnerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{5}
}
func (m *Server_DHInnerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Server_DHInnerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Server_DHInnerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Server_DHInnerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Server_DHInnerData.Merge(m, src)
}
func (m *Server_DHInnerData) XXX_Size() int {
	return m.Size()
}
func (m *Server_DHInnerData) XXX_DiscardUnknown() {
	xxx_messageInfo_Server_DHInnerData.DiscardUnknown(m)
}

var xxx_messageInfo_Server_DHInnerData proto.InternalMessageInfo

func (m *Server_DHInnerData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *Server_DHInnerData) GetData2() *Server_DHInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// server_DH_inner_data#b5890dba nonce:int128 server_nonce:int128 g:int dh_prime:string g_a:string server_time:int = Server_DH_inner_data;
type TLServer_DHInnerData struct {
	Data2 *Server_DHInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLServer_DHInnerData) Reset()         { *m = TLServer_DHInnerData{} }
func (m *TLServer_DHInnerData) String() string { return proto.CompactTextString(m) }
func (*TLServer_DHInnerData) ProtoMessage()    {}
func (*TLServer_DHInnerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{6}
}
func (m *TLServer_DHInnerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLServer_DHInnerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLServer_DHInnerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLServer_DHInnerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLServer_DHInnerData.Merge(m, src)
}
func (m *TLServer_DHInnerData) XXX_Size() int {
	return m.Size()
}
func (m *TLServer_DHInnerData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLServer_DHInnerData.DiscardUnknown(m)
}

var xxx_messageInfo_TLServer_DHInnerData proto.InternalMessageInfo

func (m *TLServer_DHInnerData) GetData2() *Server_DHInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// Client_DH_Inner_Data <--
//  + TL_client_DH_inner_data
//
type Client_DH_Inner_Data_Data struct {
	Nonce       []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ServerNonce []byte `protobuf:"bytes,2,opt,name=server_nonce,json=serverNonce,proto3" json:"server_nonce,omitempty"`
	RetryId     int64  `protobuf:"varint,3,opt,name=retry_id,json=retryId,proto3" json:"retry_id,omitempty"`
	GB          string `protobuf:"bytes,4,opt,name=g_b,json=gB,proto3" json:"g_b,omitempty"`
}

func (m *Client_DH_Inner_Data_Data) Reset()         { *m = Client_DH_Inner_Data_Data{} }
func (m *Client_DH_Inner_Data_Data) String() string { return proto.CompactTextString(m) }
func (*Client_DH_Inner_Data_Data) ProtoMessage()    {}
func (*Client_DH_Inner_Data_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{7}
}
func (m *Client_DH_Inner_Data_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Client_DH_Inner_Data_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Client_DH_Inner_Data_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Client_DH_Inner_Data_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Client_DH_Inner_Data_Data.Merge(m, src)
}
func (m *Client_DH_Inner_Data_Data) XXX_Size() int {
	return m.Size()
}
func (m *Client_DH_Inner_Data_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Client_DH_Inner_Data_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Client_DH_Inner_Data_Data proto.InternalMessageInfo

func (m *Client_DH_Inner_Data_Data) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *Client_DH_Inner_Data_Data) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

func (m *Client_DH_Inner_Data_Data) GetRetryId() int64 {
	if m != nil {
		return m.RetryId
	}
	return 0
}

func (m *Client_DH_Inner_Data_Data) GetGB() string {
	if m != nil {
		return m.GB
	}
	return ""
}

type Client_DH_Inner_Data struct {
	Constructor TLConstructor              `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *Client_DH_Inner_Data_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *Client_DH_Inner_Data) Reset()         { *m = Client_DH_Inner_Data{} }
func (m *Client_DH_Inner_Data) String() string { return proto.CompactTextString(m) }
func (*Client_DH_Inner_Data) ProtoMessage()    {}
func (*Client_DH_Inner_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{8}
}
func (m *Client_DH_Inner_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Client_DH_Inner_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Client_DH_Inner_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Client_DH_Inner_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Client_DH_Inner_Data.Merge(m, src)
}
func (m *Client_DH_Inner_Data) XXX_Size() int {
	return m.Size()
}
func (m *Client_DH_Inner_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_Client_DH_Inner_Data.DiscardUnknown(m)
}

var xxx_messageInfo_Client_DH_Inner_Data proto.InternalMessageInfo

func (m *Client_DH_Inner_Data) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *Client_DH_Inner_Data) GetData2() *Client_DH_Inner_Data_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// client_DH_inner_data#6643b654 nonce:int128 server_nonce:int128 retry_id:long g_b:string = Client_DH_Inner_Data;
type TLClient_DHInnerData struct {
	Data2 *Client_DH_Inner_Data_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLClient_DHInnerData) Reset()         { *m = TLClient_DHInnerData{} }
func (m *TLClient_DHInnerData) String() string { return proto.CompactTextString(m) }
func (*TLClient_DHInnerData) ProtoMessage()    {}
func (*TLClient_DHInnerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{9}
}
func (m *TLClient_DHInnerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLClient_DHInnerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLClient_DHInnerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLClient_DHInnerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLClient_DHInnerData.Merge(m, src)
}
func (m *TLClient_DHInnerData) XXX_Size() int {
	return m.Size()
}
func (m *TLClient_DHInnerData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLClient_DHInnerData.DiscardUnknown(m)
}

var xxx_messageInfo_TLClient_DHInnerData proto.InternalMessageInfo

func (m *TLClient_DHInnerData) GetData2() *Client_DH_Inner_Data_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// Set_client_DH_params_answer <--
//  + TL_dh_gen_ok
//  + TL_dh_gen_retry
//  + TL_dh_gen_fail
//
type SetClient_DHParamsAnswer_Data struct {
	Nonce         []byte `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ServerNonce   []byte `protobuf:"bytes,2,opt,name=server_nonce,json=serverNonce,proto3" json:"server_nonce,omitempty"`
	NewNonceHash1 []byte `protobuf:"bytes,3,opt,name=new_nonce_hash1,json=newNonceHash1,proto3" json:"new_nonce_hash1,omitempty"`
	NewNonceHash2 []byte `protobuf:"bytes,4,opt,name=new_nonce_hash2,json=newNonceHash2,proto3" json:"new_nonce_hash2,omitempty"`
	NewNonceHash3 []byte `protobuf:"bytes,5,opt,name=new_nonce_hash3,json=newNonceHash3,proto3" json:"new_nonce_hash3,omitempty"`
}

func (m *SetClient_DHParamsAnswer_Data) Reset()         { *m = SetClient_DHParamsAnswer_Data{} }
func (m *SetClient_DHParamsAnswer_Data) String() string { return proto.CompactTextString(m) }
func (*SetClient_DHParamsAnswer_Data) ProtoMessage()    {}
func (*SetClient_DHParamsAnswer_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{10}
}
func (m *SetClient_DHParamsAnswer_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetClient_DHParamsAnswer_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetClient_DHParamsAnswer_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetClient_DHParamsAnswer_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetClient_DHParamsAnswer_Data.Merge(m, src)
}
func (m *SetClient_DHParamsAnswer_Data) XXX_Size() int {
	return m.Size()
}
func (m *SetClient_DHParamsAnswer_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_SetClient_DHParamsAnswer_Data.DiscardUnknown(m)
}

var xxx_messageInfo_SetClient_DHParamsAnswer_Data proto.InternalMessageInfo

func (m *SetClient_DHParamsAnswer_Data) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *SetClient_DHParamsAnswer_Data) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

func (m *SetClient_DHParamsAnswer_Data) GetNewNonceHash1() []byte {
	if m != nil {
		return m.NewNonceHash1
	}
	return nil
}

func (m *SetClient_DHParamsAnswer_Data) GetNewNonceHash2() []byte {
	if m != nil {
		return m.NewNonceHash2
	}
	return nil
}

func (m *SetClient_DHParamsAnswer_Data) GetNewNonceHash3() []byte {
	if m != nil {
		return m.NewNonceHash3
	}
	return nil
}

type SetClient_DHParamsAnswer struct {
	Constructor TLConstructor                  `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *SetClient_DHParamsAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *SetClient_DHParamsAnswer) Reset()         { *m = SetClient_DHParamsAnswer{} }
func (m *SetClient_DHParamsAnswer) String() string { return proto.CompactTextString(m) }
func (*SetClient_DHParamsAnswer) ProtoMessage()    {}
func (*SetClient_DHParamsAnswer) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{11}
}
func (m *SetClient_DHParamsAnswer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SetClient_DHParamsAnswer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SetClient_DHParamsAnswer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SetClient_DHParamsAnswer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SetClient_DHParamsAnswer.Merge(m, src)
}
func (m *SetClient_DHParamsAnswer) XXX_Size() int {
	return m.Size()
}
func (m *SetClient_DHParamsAnswer) XXX_DiscardUnknown() {
	xxx_messageInfo_SetClient_DHParamsAnswer.DiscardUnknown(m)
}

var xxx_messageInfo_SetClient_DHParamsAnswer proto.InternalMessageInfo

func (m *SetClient_DHParamsAnswer) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *SetClient_DHParamsAnswer) GetData2() *SetClient_DHParamsAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// dh_gen_ok#3bcbf734 nonce:int128 server_nonce:int128 new_nonce_hash1:int128 = Set_client_DH_params_answer;
type TLDhGenOk struct {
	Data2 *SetClient_DHParamsAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDhGenOk) Reset()         { *m = TLDhGenOk{} }
func (m *TLDhGenOk) String() string { return proto.CompactTextString(m) }
func (*TLDhGenOk) ProtoMessage()    {}
func (*TLDhGenOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{12}
}
func (m *TLDhGenOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDhGenOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDhGenOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDhGenOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDhGenOk.Merge(m, src)
}
func (m *TLDhGenOk) XXX_Size() int {
	return m.Size()
}
func (m *TLDhGenOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDhGenOk.DiscardUnknown(m)
}

var xxx_messageInfo_TLDhGenOk proto.InternalMessageInfo

func (m *TLDhGenOk) GetData2() *SetClient_DHParamsAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// dh_gen_retry#46dc1fb9 nonce:int128 server_nonce:int128 new_nonce_hash2:int128 = Set_client_DH_params_answer;
type TLDhGenRetry struct {
	Data2 *SetClient_DHParamsAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDhGenRetry) Reset()         { *m = TLDhGenRetry{} }
func (m *TLDhGenRetry) String() string { return proto.CompactTextString(m) }
func (*TLDhGenRetry) ProtoMessage()    {}
func (*TLDhGenRetry) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{13}
}
func (m *TLDhGenRetry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDhGenRetry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDhGenRetry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDhGenRetry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDhGenRetry.Merge(m, src)
}
func (m *TLDhGenRetry) XXX_Size() int {
	return m.Size()
}
func (m *TLDhGenRetry) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDhGenRetry.DiscardUnknown(m)
}

var xxx_messageInfo_TLDhGenRetry proto.InternalMessageInfo

func (m *TLDhGenRetry) GetData2() *SetClient_DHParamsAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// dh_gen_fail#a69dae02 nonce:int128 server_nonce:int128 new_nonce_hash3:int128 = Set_client_DH_params_answer;
type TLDhGenFail struct {
	Data2 *SetClient_DHParamsAnswer_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDhGenFail) Reset()         { *m = TLDhGenFail{} }
func (m *TLDhGenFail) String() string { return proto.CompactTextString(m) }
func (*TLDhGenFail) ProtoMessage()    {}
func (*TLDhGenFail) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{14}
}
func (m *TLDhGenFail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDhGenFail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDhGenFail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDhGenFail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDhGenFail.Merge(m, src)
}
func (m *TLDhGenFail) XXX_Size() int {
	return m.Size()
}
func (m *TLDhGenFail) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDhGenFail.DiscardUnknown(m)
}

var xxx_messageInfo_TLDhGenFail proto.InternalMessageInfo

func (m *TLDhGenFail) GetData2() *SetClient_DHParamsAnswer_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// DestroyAuthKeyRes <--
//  + TL_destroy_auth_key_ok
//  + TL_destroy_auth_key_none
//  + TL_destroy_auth_key_fail
//
type DestroyAuthKeyRes_Data struct {
}

func (m *DestroyAuthKeyRes_Data) Reset()         { *m = DestroyAuthKeyRes_Data{} }
func (m *DestroyAuthKeyRes_Data) String() string { return proto.CompactTextString(m) }
func (*DestroyAuthKeyRes_Data) ProtoMessage()    {}
func (*DestroyAuthKeyRes_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{15}
}
func (m *DestroyAuthKeyRes_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestroyAuthKeyRes_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DestroyAuthKeyRes_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DestroyAuthKeyRes_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestroyAuthKeyRes_Data.Merge(m, src)
}
func (m *DestroyAuthKeyRes_Data) XXX_Size() int {
	return m.Size()
}
func (m *DestroyAuthKeyRes_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_DestroyAuthKeyRes_Data.DiscardUnknown(m)
}

var xxx_messageInfo_DestroyAuthKeyRes_Data proto.InternalMessageInfo

type DestroyAuthKeyRes struct {
	Constructor TLConstructor           `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *DestroyAuthKeyRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *DestroyAuthKeyRes) Reset()         { *m = DestroyAuthKeyRes{} }
func (m *DestroyAuthKeyRes) String() string { return proto.CompactTextString(m) }
func (*DestroyAuthKeyRes) ProtoMessage()    {}
func (*DestroyAuthKeyRes) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{16}
}
func (m *DestroyAuthKeyRes) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DestroyAuthKeyRes) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DestroyAuthKeyRes.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DestroyAuthKeyRes) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DestroyAuthKeyRes.Merge(m, src)
}
func (m *DestroyAuthKeyRes) XXX_Size() int {
	return m.Size()
}
func (m *DestroyAuthKeyRes) XXX_DiscardUnknown() {
	xxx_messageInfo_DestroyAuthKeyRes.DiscardUnknown(m)
}

var xxx_messageInfo_DestroyAuthKeyRes proto.InternalMessageInfo

func (m *DestroyAuthKeyRes) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *DestroyAuthKeyRes) GetData2() *DestroyAuthKeyRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// destroy_auth_key_ok#f660e1d4 = DestroyAuthKeyRes;
type TLDestroyAuthKeyOk struct {
	Data2 *DestroyAuthKeyRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDestroyAuthKeyOk) Reset()         { *m = TLDestroyAuthKeyOk{} }
func (m *TLDestroyAuthKeyOk) String() string { return proto.CompactTextString(m) }
func (*TLDestroyAuthKeyOk) ProtoMessage()    {}
func (*TLDestroyAuthKeyOk) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{17}
}
func (m *TLDestroyAuthKeyOk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroyAuthKeyOk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroyAuthKeyOk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroyAuthKeyOk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroyAuthKeyOk.Merge(m, src)
}
func (m *TLDestroyAuthKeyOk) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroyAuthKeyOk) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroyAuthKeyOk.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroyAuthKeyOk proto.InternalMessageInfo

func (m *TLDestroyAuthKeyOk) GetData2() *DestroyAuthKeyRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// destroy_auth_key_none#0a9f2259 = DestroyAuthKeyRes;
type TLDestroyAuthKeyNone struct {
	Data2 *DestroyAuthKeyRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDestroyAuthKeyNone) Reset()         { *m = TLDestroyAuthKeyNone{} }
func (m *TLDestroyAuthKeyNone) String() string { return proto.CompactTextString(m) }
func (*TLDestroyAuthKeyNone) ProtoMessage()    {}
func (*TLDestroyAuthKeyNone) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{18}
}
func (m *TLDestroyAuthKeyNone) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroyAuthKeyNone) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroyAuthKeyNone.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroyAuthKeyNone) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroyAuthKeyNone.Merge(m, src)
}
func (m *TLDestroyAuthKeyNone) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroyAuthKeyNone) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroyAuthKeyNone.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroyAuthKeyNone proto.InternalMessageInfo

func (m *TLDestroyAuthKeyNone) GetData2() *DestroyAuthKeyRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// destroy_auth_key_fail#ea109b13 = DestroyAuthKeyRes;
type TLDestroyAuthKeyFail struct {
	Data2 *DestroyAuthKeyRes_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLDestroyAuthKeyFail) Reset()         { *m = TLDestroyAuthKeyFail{} }
func (m *TLDestroyAuthKeyFail) String() string { return proto.CompactTextString(m) }
func (*TLDestroyAuthKeyFail) ProtoMessage()    {}
func (*TLDestroyAuthKeyFail) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{19}
}
func (m *TLDestroyAuthKeyFail) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLDestroyAuthKeyFail) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLDestroyAuthKeyFail.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLDestroyAuthKeyFail) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLDestroyAuthKeyFail.Merge(m, src)
}
func (m *TLDestroyAuthKeyFail) XXX_Size() int {
	return m.Size()
}
func (m *TLDestroyAuthKeyFail) XXX_DiscardUnknown() {
	xxx_messageInfo_TLDestroyAuthKeyFail.DiscardUnknown(m)
}

var xxx_messageInfo_TLDestroyAuthKeyFail proto.InternalMessageInfo

func (m *TLDestroyAuthKeyFail) GetData2() *DestroyAuthKeyRes_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// ResPQ <--
//  + TL_resPQ
//
type ResPQ_Data struct {
	Nonce                       []byte  `protobuf:"bytes,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ServerNonce                 []byte  `protobuf:"bytes,2,opt,name=server_nonce,json=serverNonce,proto3" json:"server_nonce,omitempty"`
	Pq                          string  `protobuf:"bytes,3,opt,name=pq,proto3" json:"pq,omitempty"`
	ServerPublicKeyFingerprints []int64 `protobuf:"varint,4,rep,packed,name=server_public_key_fingerprints,json=serverPublicKeyFingerprints,proto3" json:"server_public_key_fingerprints,omitempty"`
}

func (m *ResPQ_Data) Reset()         { *m = ResPQ_Data{} }
func (m *ResPQ_Data) String() string { return proto.CompactTextString(m) }
func (*ResPQ_Data) ProtoMessage()    {}
func (*ResPQ_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{20}
}
func (m *ResPQ_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResPQ_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResPQ_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResPQ_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResPQ_Data.Merge(m, src)
}
func (m *ResPQ_Data) XXX_Size() int {
	return m.Size()
}
func (m *ResPQ_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_ResPQ_Data.DiscardUnknown(m)
}

var xxx_messageInfo_ResPQ_Data proto.InternalMessageInfo

func (m *ResPQ_Data) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *ResPQ_Data) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

func (m *ResPQ_Data) GetPq() string {
	if m != nil {
		return m.Pq
	}
	return ""
}

func (m *ResPQ_Data) GetServerPublicKeyFingerprints() []int64 {
	if m != nil {
		return m.ServerPublicKeyFingerprints
	}
	return nil
}

type ResPQ struct {
	Constructor TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *ResPQ_Data   `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *ResPQ) Reset()         { *m = ResPQ{} }
func (m *ResPQ) String() string { return proto.CompactTextString(m) }
func (*ResPQ) ProtoMessage()    {}
func (*ResPQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{21}
}
func (m *ResPQ) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ResPQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ResPQ.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ResPQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ResPQ.Merge(m, src)
}
func (m *ResPQ) XXX_Size() int {
	return m.Size()
}
func (m *ResPQ) XXX_DiscardUnknown() {
	xxx_messageInfo_ResPQ.DiscardUnknown(m)
}

var xxx_messageInfo_ResPQ proto.InternalMessageInfo

func (m *ResPQ) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *ResPQ) GetData2() *ResPQ_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// resPQ#05162463 nonce:int128 server_nonce:int128 pq:string server_public_key_fingerprints:Vector<long> = ResPQ;
type TLResPQ struct {
	Data2 *ResPQ_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLResPQ) Reset()         { *m = TLResPQ{} }
func (m *TLResPQ) String() string { return proto.CompactTextString(m) }
func (*TLResPQ) ProtoMessage()    {}
func (*TLResPQ) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{22}
}
func (m *TLResPQ) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLResPQ) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLResPQ.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLResPQ) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLResPQ.Merge(m, src)
}
func (m *TLResPQ) XXX_Size() int {
	return m.Size()
}
func (m *TLResPQ) XXX_DiscardUnknown() {
	xxx_messageInfo_TLResPQ.DiscardUnknown(m)
}

var xxx_messageInfo_TLResPQ proto.InternalMessageInfo

func (m *TLResPQ) GetData2() *ResPQ_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// P_Q_inner_data <--
//  + TL_p_q_inner_data
//  + TL_p_q_inner_data_dc
//  + TL_p_q_inner_data_temp
//  + TL_p_q_inner_data_temp_dc
//
type P_QInnerData_Data struct {
	Pq          string `protobuf:"bytes,1,opt,name=pq,proto3" json:"pq,omitempty"`
	P           string `protobuf:"bytes,2,opt,name=p,proto3" json:"p,omitempty"`
	Q           string `protobuf:"bytes,3,opt,name=q,proto3" json:"q,omitempty"`
	Nonce       []byte `protobuf:"bytes,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ServerNonce []byte `protobuf:"bytes,5,opt,name=server_nonce,json=serverNonce,proto3" json:"server_nonce,omitempty"`
	NewNonce    []byte `protobuf:"bytes,6,opt,name=new_nonce,json=newNonce,proto3" json:"new_nonce,omitempty"`
	Dc          int32  `protobuf:"varint,7,opt,name=dc,proto3" json:"dc,omitempty"`
	ExpiresIn   int32  `protobuf:"varint,8,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
}

func (m *P_QInnerData_Data) Reset()         { *m = P_QInnerData_Data{} }
func (m *P_QInnerData_Data) String() string { return proto.CompactTextString(m) }
func (*P_QInnerData_Data) ProtoMessage()    {}
func (*P_QInnerData_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{23}
}
func (m *P_QInnerData_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P_QInnerData_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P_QInnerData_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P_QInnerData_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P_QInnerData_Data.Merge(m, src)
}
func (m *P_QInnerData_Data) XXX_Size() int {
	return m.Size()
}
func (m *P_QInnerData_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_P_QInnerData_Data.DiscardUnknown(m)
}

var xxx_messageInfo_P_QInnerData_Data proto.InternalMessageInfo

func (m *P_QInnerData_Data) GetPq() string {
	if m != nil {
		return m.Pq
	}
	return ""
}

func (m *P_QInnerData_Data) GetP() string {
	if m != nil {
		return m.P
	}
	return ""
}

func (m *P_QInnerData_Data) GetQ() string {
	if m != nil {
		return m.Q
	}
	return ""
}

func (m *P_QInnerData_Data) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *P_QInnerData_Data) GetServerNonce() []byte {
	if m != nil {
		return m.ServerNonce
	}
	return nil
}

func (m *P_QInnerData_Data) GetNewNonce() []byte {
	if m != nil {
		return m.NewNonce
	}
	return nil
}

func (m *P_QInnerData_Data) GetDc() int32 {
	if m != nil {
		return m.Dc
	}
	return 0
}

func (m *P_QInnerData_Data) GetExpiresIn() int32 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

type P_QInnerData struct {
	Constructor TLConstructor      `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *P_QInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *P_QInnerData) Reset()         { *m = P_QInnerData{} }
func (m *P_QInnerData) String() string { return proto.CompactTextString(m) }
func (*P_QInnerData) ProtoMessage()    {}
func (*P_QInnerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{24}
}
func (m *P_QInnerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *P_QInnerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_P_QInnerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *P_QInnerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_P_QInnerData.Merge(m, src)
}
func (m *P_QInnerData) XXX_Size() int {
	return m.Size()
}
func (m *P_QInnerData) XXX_DiscardUnknown() {
	xxx_messageInfo_P_QInnerData.DiscardUnknown(m)
}

var xxx_messageInfo_P_QInnerData proto.InternalMessageInfo

func (m *P_QInnerData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *P_QInnerData) GetData2() *P_QInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// p_q_inner_data#83c95aec pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 = P_Q_inner_data;
type TLPQInnerData struct {
	Data2 *P_QInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLPQInnerData) Reset()         { *m = TLPQInnerData{} }
func (m *TLPQInnerData) String() string { return proto.CompactTextString(m) }
func (*TLPQInnerData) ProtoMessage()    {}
func (*TLPQInnerData) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{25}
}
func (m *TLPQInnerData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPQInnerData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPQInnerData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPQInnerData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPQInnerData.Merge(m, src)
}
func (m *TLPQInnerData) XXX_Size() int {
	return m.Size()
}
func (m *TLPQInnerData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPQInnerData.DiscardUnknown(m)
}

var xxx_messageInfo_TLPQInnerData proto.InternalMessageInfo

func (m *TLPQInnerData) GetData2() *P_QInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// p_q_inner_data_dc#a9f55f95 pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 dc:int = P_Q_inner_data;
type TLPQInnerDataDc struct {
	Data2 *P_QInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLPQInnerDataDc) Reset()         { *m = TLPQInnerDataDc{} }
func (m *TLPQInnerDataDc) String() string { return proto.CompactTextString(m) }
func (*TLPQInnerDataDc) ProtoMessage()    {}
func (*TLPQInnerDataDc) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{26}
}
func (m *TLPQInnerDataDc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPQInnerDataDc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPQInnerDataDc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPQInnerDataDc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPQInnerDataDc.Merge(m, src)
}
func (m *TLPQInnerDataDc) XXX_Size() int {
	return m.Size()
}
func (m *TLPQInnerDataDc) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPQInnerDataDc.DiscardUnknown(m)
}

var xxx_messageInfo_TLPQInnerDataDc proto.InternalMessageInfo

func (m *TLPQInnerDataDc) GetData2() *P_QInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// p_q_inner_data_temp#3c6a84d4 pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 expires_in:int = P_Q_inner_data;
type TLPQInnerDataTemp struct {
	Data2 *P_QInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLPQInnerDataTemp) Reset()         { *m = TLPQInnerDataTemp{} }
func (m *TLPQInnerDataTemp) String() string { return proto.CompactTextString(m) }
func (*TLPQInnerDataTemp) ProtoMessage()    {}
func (*TLPQInnerDataTemp) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{27}
}
func (m *TLPQInnerDataTemp) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPQInnerDataTemp) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPQInnerDataTemp.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPQInnerDataTemp) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPQInnerDataTemp.Merge(m, src)
}
func (m *TLPQInnerDataTemp) XXX_Size() int {
	return m.Size()
}
func (m *TLPQInnerDataTemp) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPQInnerDataTemp.DiscardUnknown(m)
}

var xxx_messageInfo_TLPQInnerDataTemp proto.InternalMessageInfo

func (m *TLPQInnerDataTemp) GetData2() *P_QInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// p_q_inner_data_temp_dc#56fddf88 pq:string p:string q:string nonce:int128 server_nonce:int128 new_nonce:int256 dc:int expires_in:int = P_Q_inner_data;
type TLPQInnerDataTempDc struct {
	Data2 *P_QInnerData_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLPQInnerDataTempDc) Reset()         { *m = TLPQInnerDataTempDc{} }
func (m *TLPQInnerDataTempDc) String() string { return proto.CompactTextString(m) }
func (*TLPQInnerDataTempDc) ProtoMessage()    {}
func (*TLPQInnerDataTempDc) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{28}
}
func (m *TLPQInnerDataTempDc) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLPQInnerDataTempDc) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLPQInnerDataTempDc.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLPQInnerDataTempDc) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLPQInnerDataTempDc.Merge(m, src)
}
func (m *TLPQInnerDataTempDc) XXX_Size() int {
	return m.Size()
}
func (m *TLPQInnerDataTempDc) XXX_DiscardUnknown() {
	xxx_messageInfo_TLPQInnerDataTempDc.DiscardUnknown(m)
}

var xxx_messageInfo_TLPQInnerDataTempDc proto.InternalMessageInfo

func (m *TLPQInnerDataTempDc) GetData2() *P_QInnerData_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

///////////////////////////////////////////////////////////////////////////////
// BindAuthKeyInner <--
//  + TL_bind_auth_key_inner
//
type BindAuthKeyInner_Data struct {
	Nonce         int64 `protobuf:"varint,1,opt,name=nonce,proto3" json:"nonce,omitempty"`
	TempAuthKeyId int64 `protobuf:"varint,2,opt,name=temp_auth_key_id,json=tempAuthKeyId,proto3" json:"temp_auth_key_id,omitempty"`
	PermAuthKeyId int64 `protobuf:"varint,3,opt,name=perm_auth_key_id,json=permAuthKeyId,proto3" json:"perm_auth_key_id,omitempty"`
	TempSessionId int64 `protobuf:"varint,4,opt,name=temp_session_id,json=tempSessionId,proto3" json:"temp_session_id,omitempty"`
	ExpiresAt     int32 `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
}

func (m *BindAuthKeyInner_Data) Reset()         { *m = BindAuthKeyInner_Data{} }
func (m *BindAuthKeyInner_Data) String() string { return proto.CompactTextString(m) }
func (*BindAuthKeyInner_Data) ProtoMessage()    {}
func (*BindAuthKeyInner_Data) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{29}
}
func (m *BindAuthKeyInner_Data) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BindAuthKeyInner_Data) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BindAuthKeyInner_Data.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BindAuthKeyInner_Data) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindAuthKeyInner_Data.Merge(m, src)
}
func (m *BindAuthKeyInner_Data) XXX_Size() int {
	return m.Size()
}
func (m *BindAuthKeyInner_Data) XXX_DiscardUnknown() {
	xxx_messageInfo_BindAuthKeyInner_Data.DiscardUnknown(m)
}

var xxx_messageInfo_BindAuthKeyInner_Data proto.InternalMessageInfo

func (m *BindAuthKeyInner_Data) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *BindAuthKeyInner_Data) GetTempAuthKeyId() int64 {
	if m != nil {
		return m.TempAuthKeyId
	}
	return 0
}

func (m *BindAuthKeyInner_Data) GetPermAuthKeyId() int64 {
	if m != nil {
		return m.PermAuthKeyId
	}
	return 0
}

func (m *BindAuthKeyInner_Data) GetTempSessionId() int64 {
	if m != nil {
		return m.TempSessionId
	}
	return 0
}

func (m *BindAuthKeyInner_Data) GetExpiresAt() int32 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

type BindAuthKeyInner struct {
	Constructor TLConstructor          `protobuf:"varint,1,opt,name=constructor,proto3,enum=mtproto.TLConstructor" json:"constructor,omitempty"`
	Data2       *BindAuthKeyInner_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *BindAuthKeyInner) Reset()         { *m = BindAuthKeyInner{} }
func (m *BindAuthKeyInner) String() string { return proto.CompactTextString(m) }
func (*BindAuthKeyInner) ProtoMessage()    {}
func (*BindAuthKeyInner) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{30}
}
func (m *BindAuthKeyInner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BindAuthKeyInner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BindAuthKeyInner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BindAuthKeyInner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BindAuthKeyInner.Merge(m, src)
}
func (m *BindAuthKeyInner) XXX_Size() int {
	return m.Size()
}
func (m *BindAuthKeyInner) XXX_DiscardUnknown() {
	xxx_messageInfo_BindAuthKeyInner.DiscardUnknown(m)
}

var xxx_messageInfo_BindAuthKeyInner proto.InternalMessageInfo

func (m *BindAuthKeyInner) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return TLConstructor_CRC32_UNKNOWN
}

func (m *BindAuthKeyInner) GetData2() *BindAuthKeyInner_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

// bind_auth_key_inner#75a3f765 nonce:long temp_auth_key_id:long perm_auth_key_id:long temp_session_id:long expires_at:int = BindAuthKeyInner;
type TLBindAuthKeyInner struct {
	Data2 *BindAuthKeyInner_Data `protobuf:"bytes,2,opt,name=data2,proto3" json:"data2,omitempty"`
}

func (m *TLBindAuthKeyInner) Reset()         { *m = TLBindAuthKeyInner{} }
func (m *TLBindAuthKeyInner) String() string { return proto.CompactTextString(m) }
func (*TLBindAuthKeyInner) ProtoMessage()    {}
func (*TLBindAuthKeyInner) Descriptor() ([]byte, []int) {
	return fileDescriptor_eacd2ccb4d844da1, []int{31}
}
func (m *TLBindAuthKeyInner) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLBindAuthKeyInner) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLBindAuthKeyInner.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLBindAuthKeyInner) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLBindAuthKeyInner.Merge(m, src)
}
func (m *TLBindAuthKeyInner) XXX_Size() int {
	return m.Size()
}
func (m *TLBindAuthKeyInner) XXX_DiscardUnknown() {
	xxx_messageInfo_TLBindAuthKeyInner.DiscardUnknown(m)
}

var xxx_messageInfo_TLBindAuthKeyInner proto.InternalMessageInfo

func (m *TLBindAuthKeyInner) GetData2() *BindAuthKeyInner_Data {
	if m != nil {
		return m.Data2
	}
	return nil
}

func init() {
	proto.RegisterType((*Server_DH_Params_Data)(nil), "mtproto.Server_DH_Params_Data")
	proto.RegisterType((*Server_DH_Params)(nil), "mtproto.Server_DH_Params")
	proto.RegisterType((*TLServer_DHParamsFail)(nil), "mtproto.TL_server_DH_params_fail")
	proto.RegisterType((*TLServer_DHParamsOk)(nil), "mtproto.TL_server_DH_params_ok")
	proto.RegisterType((*Server_DHInnerData_Data)(nil), "mtproto.Server_DH_inner_data_Data")
	proto.RegisterType((*Server_DHInnerData)(nil), "mtproto.Server_DH_inner_data")
	proto.RegisterType((*TLServer_DHInnerData)(nil), "mtproto.TL_server_DH_inner_data")
	proto.RegisterType((*Client_DH_Inner_Data_Data)(nil), "mtproto.Client_DH_Inner_Data_Data")
	proto.RegisterType((*Client_DH_Inner_Data)(nil), "mtproto.Client_DH_Inner_Data")
	proto.RegisterType((*TLClient_DHInnerData)(nil), "mtproto.TL_client_DH_inner_data")
	proto.RegisterType((*SetClient_DHParamsAnswer_Data)(nil), "mtproto.Set_client_DH_params_answer_Data")
	proto.RegisterType((*SetClient_DHParamsAnswer)(nil), "mtproto.Set_client_DH_params_answer")
	proto.RegisterType((*TLDhGenOk)(nil), "mtproto.TL_dh_gen_ok")
	proto.RegisterType((*TLDhGenRetry)(nil), "mtproto.TL_dh_gen_retry")
	proto.RegisterType((*TLDhGenFail)(nil), "mtproto.TL_dh_gen_fail")
	proto.RegisterType((*DestroyAuthKeyRes_Data)(nil), "mtproto.DestroyAuthKeyRes_Data")
	proto.RegisterType((*DestroyAuthKeyRes)(nil), "mtproto.DestroyAuthKeyRes")
	proto.RegisterType((*TLDestroyAuthKeyOk)(nil), "mtproto.TL_destroy_auth_key_ok")
	proto.RegisterType((*TLDestroyAuthKeyNone)(nil), "mtproto.TL_destroy_auth_key_none")
	proto.RegisterType((*TLDestroyAuthKeyFail)(nil), "mtproto.TL_destroy_auth_key_fail")
	proto.RegisterType((*ResPQ_Data)(nil), "mtproto.ResPQ_Data")
	proto.RegisterType((*ResPQ)(nil), "mtproto.ResPQ")
	proto.RegisterType((*TLResPQ)(nil), "mtproto.TL_resPQ")
	proto.RegisterType((*P_QInnerData_Data)(nil), "mtproto.P_Q_inner_data_Data")
	proto.RegisterType((*P_QInnerData)(nil), "mtproto.P_Q_inner_data")
	proto.RegisterType((*TLPQInnerData)(nil), "mtproto.TL_p_q_inner_data")
	proto.RegisterType((*TLPQInnerDataDc)(nil), "mtproto.TL_p_q_inner_data_dc")
	proto.RegisterType((*TLPQInnerDataTemp)(nil), "mtproto.TL_p_q_inner_data_temp")
	proto.RegisterType((*TLPQInnerDataTempDc)(nil), "mtproto.TL_p_q_inner_data_temp_dc")
	proto.RegisterType((*BindAuthKeyInner_Data)(nil), "mtproto.BindAuthKeyInner_Data")
	proto.RegisterType((*BindAuthKeyInner)(nil), "mtproto.BindAuthKeyInner")
	proto.RegisterType((*TLBindAuthKeyInner)(nil), "mtproto.TL_bind_auth_key_inner")
}

func init() { proto.RegisterFile("schema.tl.handshake.proto", fileDescriptor_eacd2ccb4d844da1) }

var fileDescriptor_eacd2ccb4d844da1 = []byte{
	// 973 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0xcf, 0x6f, 0xe3, 0x44,
	0x14, 0xee, 0x24, 0xcd, 0x36, 0x79, 0x4d, 0x93, 0xae, 0xb7, 0x2d, 0xc9, 0x16, 0xb2, 0x25, 0x42,
	0x4b, 0x7b, 0x89, 0xb4, 0x29, 0x2b, 0xed, 0x0d, 0xf5, 0x87, 0xa0, 0x65, 0xa3, 0xdd, 0xd4, 0xcd,
	0x7d, 0xe4, 0xda, 0x43, 0x6c, 0x35, 0x99, 0xb8, 0xe3, 0x29, 0x25, 0x17, 0x84, 0x10, 0x27, 0x4e,
	0x1c, 0x11, 0x37, 0xfe, 0x02, 0xfe, 0x8b, 0x15, 0xc7, 0x95, 0xb8, 0x70, 0x44, 0xed, 0x3f, 0x82,
	0xfc, 0xc6, 0xf1, 0x8f, 0xc4, 0x14, 0xb0, 0xd9, 0x5b, 0xe6, 0xcd, 0x37, 0xdf, 0xbc, 0xf9, 0xbe,
	0x37, 0x2f, 0x63, 0x68, 0x7a, 0xa6, 0xcd, 0xc6, 0x46, 0x47, 0x8e, 0x3a, 0xb6, 0xc1, 0x2d, 0xcf,
	0x36, 0x2e, 0x59, 0xc7, 0x15, 0x13, 0x39, 0xd1, 0x56, 0xc6, 0x12, 0x7f, 0x3c, 0xde, 0x8c, 0x30,
	0xa6, 0x30, 0xf7, 0xbb, 0x6a, 0xbe, 0xfd, 0x0b, 0x81, 0xcd, 0x73, 0x26, 0xbe, 0x62, 0x82, 0x1e,
	0x9f, 0xd0, 0xbe, 0x21, 0x8c, 0xb1, 0x47, 0x8f, 0x0d, 0x69, 0x68, 0x1b, 0x50, 0xe2, 0x13, 0x6e,
	0xb2, 0x06, 0xd9, 0x21, 0xbb, 0x55, 0x5d, 0x0d, 0xb4, 0x0f, 0xa1, 0xea, 0x29, 0xb8, 0x9a, 0x2c,
	0xe0, 0xe4, 0xaa, 0x8a, 0xbd, 0x42, 0xc8, 0x47, 0x50, 0xe3, 0xec, 0x46, 0xcd, 0x53, 0xdb, 0xf0,
	0xec, 0x46, 0x11, 0x41, 0x55, 0xce, 0x6e, 0x10, 0x71, 0x62, 0x78, 0xb6, 0xb6, 0x07, 0xeb, 0x8c,
	0x9b, 0x62, 0xea, 0x4a, 0x66, 0x51, 0x83, 0x7b, 0x37, 0x4c, 0x34, 0x96, 0x77, 0xc8, 0x6e, 0x45,
	0xaf, 0x87, 0xf1, 0x03, 0x0c, 0xb7, 0xbf, 0x23, 0xb0, 0x3e, 0x9f, 0xa3, 0xf6, 0x02, 0x56, 0xcd,
	0x09, 0xf7, 0xa4, 0xb8, 0x36, 0xe5, 0x44, 0x60, 0x92, 0xb5, 0xee, 0x56, 0x27, 0x38, 0x6e, 0x67,
	0xd0, 0x3b, 0x8a, 0x66, 0xf5, 0x38, 0x54, 0xfb, 0x04, 0x4a, 0x96, 0x21, 0x8d, 0x2e, 0xe6, 0xbe,
	0xda, 0x6d, 0x85, 0x6b, 0x52, 0x75, 0xd0, 0x15, 0xb8, 0xdd, 0x87, 0xc6, 0xa0, 0x47, 0xbd, 0x10,
	0xe2, 0x2a, 0xc8, 0x97, 0x86, 0x33, 0xca, 0xc8, 0xf8, 0x0a, 0xb6, 0xd2, 0x18, 0x27, 0x97, 0x19,
	0xf9, 0x7e, 0x25, 0xd0, 0x8c, 0x00, 0x0e, 0xe7, 0x4c, 0x50, 0x7f, 0x26, 0xa7, 0x9d, 0x55, 0x20,
	0x43, 0x74, 0xb0, 0xa4, 0x93, 0xa1, 0xd6, 0x84, 0xb2, 0x65, 0x53, 0x57, 0x38, 0x63, 0x16, 0xd8,
	0xb5, 0x62, 0xd9, 0x7d, 0x7f, 0xa8, 0xd5, 0xa1, 0x38, 0xa4, 0x46, 0xa3, 0x84, 0xd1, 0xc2, 0xf0,
	0x40, 0x7b, 0x02, 0x01, 0x11, 0x95, 0x3e, 0xfc, 0x01, 0x72, 0x80, 0x0a, 0x0d, 0x9c, 0x31, 0x6b,
	0xff, 0x40, 0x60, 0x23, 0x2d, 0xe3, 0x1c, 0xe6, 0xbe, 0x48, 0x4a, 0xd7, 0x4e, 0x91, 0x6e, 0x4e,
	0x99, 0x99, 0x7c, 0xe7, 0xf0, 0x5e, 0xc2, 0x8e, 0x44, 0x3a, 0x59, 0x49, 0xbf, 0x25, 0xd0, 0x3c,
	0x1a, 0x39, 0x8c, 0x4b, 0x1f, 0x74, 0x8a, 0xa0, 0xe3, 0xfc, 0x9e, 0x34, 0xa1, 0x2c, 0x98, 0x14,
	0x53, 0xea, 0x58, 0x68, 0x4d, 0x51, 0x5f, 0xc1, 0xf1, 0xa9, 0xa5, 0x5c, 0xb8, 0x08, 0xbc, 0x29,
	0x0c, 0x0f, 0x51, 0xe4, 0xb4, 0x14, 0xde, 0x85, 0xc8, 0x7f, 0x7b, 0xd4, 0xa4, 0xc8, 0x66, 0x08,
	0xfb, 0x37, 0x22, 0xff, 0x23, 0xe9, 0xef, 0x04, 0x76, 0xce, 0x99, 0x8c, 0xd1, 0x06, 0x57, 0x49,
	0xb5, 0x95, 0x9c, 0x5a, 0x3f, 0x85, 0x7a, 0xb2, 0x9d, 0x3d, 0x0b, 0xfa, 0xd9, 0x5a, 0xbc, 0x9f,
	0x3d, 0x5b, 0xc4, 0x75, 0xd1, 0x84, 0x39, 0x5c, 0x77, 0x11, 0xb7, 0x8f, 0x57, 0x66, 0x0e, 0xb7,
	0xdf, 0xfe, 0x89, 0xc0, 0xf6, 0x3d, 0xa7, 0xca, 0x61, 0xdf, 0xa7, 0x49, 0xa5, 0xf7, 0x62, 0xe5,
	0x7c, 0xbf, 0x88, 0x33, 0xc1, 0x5f, 0x43, 0x75, 0xd0, 0xa3, 0x96, 0x4d, 0x87, 0x8c, 0xfb, 0xfd,
	0x2a, 0x37, 0xa1, 0x0e, 0xf5, 0x88, 0x10, 0x2b, 0x39, 0x3f, 0xe7, 0x19, 0xd4, 0x22, 0x4e, 0x6c,
	0xd3, 0xb9, 0x29, 0x1b, 0xb0, 0x75, 0xcc, 0x3c, 0x29, 0x26, 0xd3, 0x83, 0x6b, 0x69, 0xbf, 0x64,
	0x53, 0x9d, 0xa9, 0x16, 0xdc, 0xfe, 0x9e, 0xc0, 0xc3, 0x85, 0xa9, 0x1c, 0x16, 0x3d, 0x4f, 0xa6,
	0xfa, 0x24, 0x5c, 0x93, 0xbe, 0x7f, 0x64, 0x8c, 0xff, 0x97, 0x62, 0x29, 0x0c, 0x35, 0xae, 0xa5,
	0x4d, 0x2f, 0xd9, 0xd4, 0xb7, 0x28, 0x23, 0xe1, 0x19, 0xfe, 0xeb, 0x2d, 0x10, 0xf2, 0x09, 0x67,
	0xff, 0x33, 0x25, 0x3a, 0x94, 0x91, 0xf2, 0x67, 0x02, 0xa0, 0x33, 0xaf, 0x7f, 0x96, 0xf3, 0xaa,
	0xd7, 0xa0, 0xe0, 0x5e, 0xe1, 0xed, 0xae, 0xe8, 0x05, 0xf7, 0x4a, 0x3b, 0x82, 0x56, 0xb0, 0xc4,
	0xbd, 0xbe, 0x18, 0x39, 0xa6, 0x4a, 0xd4, 0xe1, 0x43, 0x26, 0x5c, 0xe1, 0x70, 0xe9, 0x35, 0x96,
	0x77, 0x8a, 0xbb, 0x45, 0x7d, 0x5b, 0xa1, 0xfa, 0x08, 0x7a, 0xc9, 0xa6, 0x9f, 0xc5, 0x20, 0xed,
	0x11, 0x94, 0x30, 0xb7, 0x1c, 0xd5, 0xb0, 0x97, 0x94, 0xe5, 0x51, 0xb8, 0x26, 0x3a, 0xf4, 0x4c,
	0x8a, 0xe7, 0x50, 0x1e, 0xf4, 0xa8, 0xc0, 0x0d, 0xff, 0xc3, 0xb2, 0x37, 0x04, 0x1e, 0xf5, 0xe9,
	0xd9, 0xc2, 0xab, 0x41, 0x29, 0x42, 0x42, 0x45, 0xaa, 0x40, 0x5c, 0xa4, 0xab, 0xe8, 0xc4, 0xf5,
	0x47, 0x33, 0xb9, 0xc8, 0x55, 0x24, 0xfb, 0xf2, 0x7d, 0xb2, 0x97, 0x16, 0x65, 0xdf, 0x86, 0x4a,
	0xd8, 0x11, 0xf1, 0x95, 0x50, 0xd5, 0xcb, 0xb3, 0x5e, 0xe8, 0x67, 0x60, 0x99, 0x8d, 0x15, 0x7c,
	0x3b, 0x14, 0x2c, 0x53, 0xfb, 0x00, 0x80, 0x7d, 0xed, 0x3a, 0x82, 0x79, 0xd4, 0xe1, 0x8d, 0x32,
	0xc6, 0x2b, 0x41, 0xe4, 0x94, 0xb7, 0xbf, 0x81, 0x5a, 0xf2, 0x1c, 0x39, 0x64, 0xef, 0x26, 0xf5,
	0x7b, 0x3f, 0x5c, 0x93, 0xa2, 0xd4, 0x4c, 0xc8, 0xcf, 0xe1, 0xe1, 0xa0, 0x47, 0x5d, 0x7a, 0x15,
	0x4f, 0x21, 0x0b, 0xd1, 0x17, 0xb0, 0xb1, 0x40, 0x44, 0x2d, 0x33, 0x13, 0x57, 0x0f, 0xdb, 0xc2,
	0x1c, 0x97, 0x64, 0x63, 0x37, 0x13, 0xdb, 0x6b, 0x68, 0xa6, 0xb3, 0x65, 0x4d, 0xef, 0x0d, 0x81,
	0xcd, 0x43, 0x87, 0x5b, 0xc1, 0xed, 0x8e, 0x3d, 0x51, 0x12, 0x37, 0xb9, 0x38, 0x2b, 0xa9, 0x8f,
	0x61, 0x1d, 0xb7, 0x0b, 0x7b, 0x87, 0x63, 0xe1, 0x76, 0x45, 0x7d, 0xcd, 0x8f, 0xcf, 0x68, 0x2c,
	0x1f, 0xe8, 0x32, 0x31, 0x4e, 0x00, 0xd5, 0x73, 0x69, 0xcd, 0x8f, 0x47, 0xc0, 0xa7, 0x50, 0x47,
	0x46, 0x8f, 0x79, 0x9e, 0x33, 0xe1, 0x3e, 0x6e, 0x39, 0x22, 0x3c, 0x57, 0xd1, 0x53, 0x2b, 0x5e,
	0x7c, 0x86, 0xc4, 0x52, 0x8e, 0x8a, 0xef, 0x40, 0xe2, 0x87, 0xca, 0xfc, 0x41, 0xde, 0xc5, 0x87,
	0x4a, 0xaa, 0x58, 0xc9, 0xcf, 0x8a, 0x0b, 0x87, 0x5b, 0xb1, 0x73, 0x63, 0x26, 0x99, 0xf8, 0x0e,
	0x1f, 0xff, 0x76, 0xdb, 0x22, 0x6f, 0x6f, 0x5b, 0xe4, 0xcf, 0xdb, 0x16, 0xf9, 0xf1, 0xae, 0xb5,
	0xf4, 0xf6, 0xae, 0xb5, 0xf4, 0xc7, 0x5d, 0x6b, 0xe9, 0xa4, 0x70, 0xf1, 0x00, 0xd7, 0xef, 0xff,
	0x15, 0x00, 0x00, 0xff, 0xff, 0xed, 0x08, 0x78, 0x7d, 0x81, 0x0e, 0x00, 0x00,
}

func (m *Server_DH_Params_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server_DH_Params_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Server_DH_Params_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EncryptedAnswer) > 0 {
		i -= len(m.EncryptedAnswer)
		copy(dAtA[i:], m.EncryptedAnswer)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.EncryptedAnswer)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NewNonceHash) > 0 {
		i -= len(m.NewNonceHash)
		copy(dAtA[i:], m.NewNonceHash)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.NewNonceHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServerNonce) > 0 {
		i -= len(m.ServerNonce)
		copy(dAtA[i:], m.ServerNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.ServerNonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Server_DH_Params) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server_DH_Params) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Server_DH_Params) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLServer_DHParamsFail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLServer_DHParamsFail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLServer_DHParamsFail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLServer_DHParamsOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLServer_DHParamsOk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLServer_DHParamsOk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Server_DHInnerData_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server_DHInnerData_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Server_DHInnerData_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ServerTime != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.ServerTime))
		i--
		dAtA[i] = 0x30
	}
	if len(m.GA) > 0 {
		i -= len(m.GA)
		copy(dAtA[i:], m.GA)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.GA)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.DhPrime) > 0 {
		i -= len(m.DhPrime)
		copy(dAtA[i:], m.DhPrime)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.DhPrime)))
		i--
		dAtA[i] = 0x22
	}
	if m.G != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.G))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServerNonce) > 0 {
		i -= len(m.ServerNonce)
		copy(dAtA[i:], m.ServerNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.ServerNonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Server_DHInnerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Server_DHInnerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Server_DHInnerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLServer_DHInnerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLServer_DHInnerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLServer_DHInnerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *Client_DH_Inner_Data_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Client_DH_Inner_Data_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Client_DH_Inner_Data_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.GB) > 0 {
		i -= len(m.GB)
		copy(dAtA[i:], m.GB)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.GB)))
		i--
		dAtA[i] = 0x22
	}
	if m.RetryId != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.RetryId))
		i--
		dAtA[i] = 0x18
	}
	if len(m.ServerNonce) > 0 {
		i -= len(m.ServerNonce)
		copy(dAtA[i:], m.ServerNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.ServerNonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *Client_DH_Inner_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Client_DH_Inner_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Client_DH_Inner_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLClient_DHInnerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLClient_DHInnerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLClient_DHInnerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *SetClient_DHParamsAnswer_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetClient_DHParamsAnswer_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetClient_DHParamsAnswer_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.NewNonceHash3) > 0 {
		i -= len(m.NewNonceHash3)
		copy(dAtA[i:], m.NewNonceHash3)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.NewNonceHash3)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.NewNonceHash2) > 0 {
		i -= len(m.NewNonceHash2)
		copy(dAtA[i:], m.NewNonceHash2)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.NewNonceHash2)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.NewNonceHash1) > 0 {
		i -= len(m.NewNonceHash1)
		copy(dAtA[i:], m.NewNonceHash1)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.NewNonceHash1)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServerNonce) > 0 {
		i -= len(m.ServerNonce)
		copy(dAtA[i:], m.ServerNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.ServerNonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *SetClient_DHParamsAnswer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SetClient_DHParamsAnswer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *SetClient_DHParamsAnswer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDhGenOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDhGenOk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDhGenOk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLDhGenRetry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDhGenRetry) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDhGenRetry) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLDhGenFail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDhGenFail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDhGenFail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *DestroyAuthKeyRes_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroyAuthKeyRes_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestroyAuthKeyRes_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	return len(dAtA) - i, nil
}

func (m *DestroyAuthKeyRes) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DestroyAuthKeyRes) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *DestroyAuthKeyRes) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroyAuthKeyOk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroyAuthKeyOk) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroyAuthKeyOk) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroyAuthKeyNone) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroyAuthKeyNone) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroyAuthKeyNone) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLDestroyAuthKeyFail) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLDestroyAuthKeyFail) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLDestroyAuthKeyFail) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *ResPQ_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResPQ_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResPQ_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ServerPublicKeyFingerprints) > 0 {
		dAtA17 := make([]byte, len(m.ServerPublicKeyFingerprints)*10)
		var j16 int
		for _, num1 := range m.ServerPublicKeyFingerprints {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA17[j16] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j16++
			}
			dAtA17[j16] = uint8(num)
			j16++
		}
		i -= j16
		copy(dAtA[i:], dAtA17[:j16])
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(j16))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Pq) > 0 {
		i -= len(m.Pq)
		copy(dAtA[i:], m.Pq)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Pq)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ServerNonce) > 0 {
		i -= len(m.ServerNonce)
		copy(dAtA[i:], m.ServerNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.ServerNonce)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *ResPQ) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ResPQ) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ResPQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLResPQ) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLResPQ) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLResPQ) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *P_QInnerData_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P_QInnerData_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P_QInnerData_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresIn != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.ExpiresIn))
		i--
		dAtA[i] = 0x40
	}
	if m.Dc != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Dc))
		i--
		dAtA[i] = 0x38
	}
	if len(m.NewNonce) > 0 {
		i -= len(m.NewNonce)
		copy(dAtA[i:], m.NewNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.NewNonce)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.ServerNonce) > 0 {
		i -= len(m.ServerNonce)
		copy(dAtA[i:], m.ServerNonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.ServerNonce)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.Nonce) > 0 {
		i -= len(m.Nonce)
		copy(dAtA[i:], m.Nonce)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Nonce)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Q) > 0 {
		i -= len(m.Q)
		copy(dAtA[i:], m.Q)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Q)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.P) > 0 {
		i -= len(m.P)
		copy(dAtA[i:], m.P)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.P)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.Pq) > 0 {
		i -= len(m.Pq)
		copy(dAtA[i:], m.Pq)
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(len(m.Pq)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *P_QInnerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *P_QInnerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *P_QInnerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLPQInnerData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPQInnerData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPQInnerData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLPQInnerDataDc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPQInnerDataDc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPQInnerDataDc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLPQInnerDataTemp) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPQInnerDataTemp) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPQInnerDataTemp) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *TLPQInnerDataTempDc) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLPQInnerDataTempDc) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLPQInnerDataTempDc) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func (m *BindAuthKeyInner_Data) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindAuthKeyInner_Data) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BindAuthKeyInner_Data) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.ExpiresAt != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if m.TempSessionId != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.TempSessionId))
		i--
		dAtA[i] = 0x20
	}
	if m.PermAuthKeyId != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.PermAuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.TempAuthKeyId != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.TempAuthKeyId))
		i--
		dAtA[i] = 0x10
	}
	if m.Nonce != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *BindAuthKeyInner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BindAuthKeyInner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BindAuthKeyInner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	if m.Constructor != 0 {
		i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLBindAuthKeyInner) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLBindAuthKeyInner) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLBindAuthKeyInner) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintSchemaTlHandshake(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x12
	}
	return len(dAtA) - i, nil
}

func encodeVarintSchemaTlHandshake(dAtA []byte, offset int, v uint64) int {
	offset -= sovSchemaTlHandshake(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *Server_DH_Params_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.ServerNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.NewNonceHash)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.EncryptedAnswer)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *Server_DH_Params) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLServer_DHParamsFail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLServer_DHParamsOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *Server_DHInnerData_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.ServerNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	if m.G != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.G))
	}
	l = len(m.DhPrime)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.GA)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	if m.ServerTime != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.ServerTime))
	}
	return n
}

func (m *Server_DHInnerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLServer_DHInnerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *Client_DH_Inner_Data_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.ServerNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	if m.RetryId != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.RetryId))
	}
	l = len(m.GB)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *Client_DH_Inner_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLClient_DHInnerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *SetClient_DHParamsAnswer_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.ServerNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.NewNonceHash1)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.NewNonceHash2)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.NewNonceHash3)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *SetClient_DHParamsAnswer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLDhGenOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLDhGenRetry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLDhGenFail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *DestroyAuthKeyRes_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DestroyAuthKeyRes) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLDestroyAuthKeyOk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLDestroyAuthKeyNone) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLDestroyAuthKeyFail) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *ResPQ_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.ServerNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.Pq)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	if len(m.ServerPublicKeyFingerprints) > 0 {
		l = 0
		for _, e := range m.ServerPublicKeyFingerprints {
			l += sovSchemaTlHandshake(uint64(e))
		}
		n += 1 + sovSchemaTlHandshake(uint64(l)) + l
	}
	return n
}

func (m *ResPQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLResPQ) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *P_QInnerData_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pq)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.P)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.Q)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.Nonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.ServerNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	l = len(m.NewNonce)
	if l > 0 {
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	if m.Dc != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Dc))
	}
	if m.ExpiresIn != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.ExpiresIn))
	}
	return n
}

func (m *P_QInnerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLPQInnerData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLPQInnerDataDc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLPQInnerDataTemp) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLPQInnerDataTempDc) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *BindAuthKeyInner_Data) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Nonce != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Nonce))
	}
	if m.TempAuthKeyId != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.TempAuthKeyId))
	}
	if m.PermAuthKeyId != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.PermAuthKeyId))
	}
	if m.TempSessionId != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.TempSessionId))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.ExpiresAt))
	}
	return n
}

func (m *BindAuthKeyInner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovSchemaTlHandshake(uint64(m.Constructor))
	}
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func (m *TLBindAuthKeyInner) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovSchemaTlHandshake(uint64(l))
	}
	return n
}

func sovSchemaTlHandshake(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozSchemaTlHandshake(x uint64) (n int) {
	return sovSchemaTlHandshake(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Server_DH_Params_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server_DH_Params_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server_DH_Params_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = append(m.ServerNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerNonce == nil {
				m.ServerNonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNonceHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewNonceHash = append(m.NewNonceHash[:0], dAtA[iNdEx:postIndex]...)
			if m.NewNonceHash == nil {
				m.NewNonceHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedAnswer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedAnswer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server_DH_Params) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server_DH_Params: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server_DH_Params: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Server_DH_Params_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLServer_DHParamsFail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_server_DH_params_fail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_server_DH_params_fail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Server_DH_Params_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLServer_DHParamsOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_server_DH_params_ok: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_server_DH_params_ok: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Server_DH_Params_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server_DHInnerData_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server_DH_inner_data_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server_DH_inner_data_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = append(m.ServerNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerNonce == nil {
				m.ServerNonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field G", wireType)
			}
			m.G = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.G |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DhPrime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DhPrime = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GA", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GA = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerTime", wireType)
			}
			m.ServerTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ServerTime |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Server_DHInnerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Server_DH_inner_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Server_DH_inner_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Server_DHInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLServer_DHInnerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_server_DH_inner_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_server_DH_inner_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Server_DHInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Client_DH_Inner_Data_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Client_DH_Inner_Data_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Client_DH_Inner_Data_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = append(m.ServerNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerNonce == nil {
				m.ServerNonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RetryId", wireType)
			}
			m.RetryId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RetryId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GB", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GB = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Client_DH_Inner_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Client_DH_Inner_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Client_DH_Inner_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Client_DH_Inner_Data_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLClient_DHInnerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_client_DH_inner_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_client_DH_inner_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &Client_DH_Inner_Data_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetClient_DHParamsAnswer_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_client_DH_params_answer_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_client_DH_params_answer_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = append(m.ServerNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerNonce == nil {
				m.ServerNonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNonceHash1", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewNonceHash1 = append(m.NewNonceHash1[:0], dAtA[iNdEx:postIndex]...)
			if m.NewNonceHash1 == nil {
				m.NewNonceHash1 = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNonceHash2", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewNonceHash2 = append(m.NewNonceHash2[:0], dAtA[iNdEx:postIndex]...)
			if m.NewNonceHash2 == nil {
				m.NewNonceHash2 = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNonceHash3", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewNonceHash3 = append(m.NewNonceHash3[:0], dAtA[iNdEx:postIndex]...)
			if m.NewNonceHash3 == nil {
				m.NewNonceHash3 = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SetClient_DHParamsAnswer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Set_client_DH_params_answer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Set_client_DH_params_answer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SetClient_DHParamsAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDhGenOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dh_gen_ok: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dh_gen_ok: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SetClient_DHParamsAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDhGenRetry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dh_gen_retry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dh_gen_retry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SetClient_DHParamsAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDhGenFail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_dh_gen_fail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_dh_gen_fail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &SetClient_DHParamsAnswer_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroyAuthKeyRes_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroyAuthKeyRes_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroyAuthKeyRes_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DestroyAuthKeyRes) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DestroyAuthKeyRes: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DestroyAuthKeyRes: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroyAuthKeyRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroyAuthKeyOk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_auth_key_ok: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_auth_key_ok: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroyAuthKeyRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroyAuthKeyNone) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_auth_key_none: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_auth_key_none: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroyAuthKeyRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLDestroyAuthKeyFail) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_destroy_auth_key_fail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_destroy_auth_key_fail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &DestroyAuthKeyRes_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResPQ_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResPQ_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResPQ_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = append(m.ServerNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerNonce == nil {
				m.ServerNonce = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlHandshake
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.ServerPublicKeyFingerprints = append(m.ServerPublicKeyFingerprints, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowSchemaTlHandshake
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthSchemaTlHandshake
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthSchemaTlHandshake
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.ServerPublicKeyFingerprints) == 0 {
					m.ServerPublicKeyFingerprints = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowSchemaTlHandshake
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.ServerPublicKeyFingerprints = append(m.ServerPublicKeyFingerprints, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerPublicKeyFingerprints", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ResPQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ResPQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ResPQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &ResPQ_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLResPQ) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_resPQ: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_resPQ: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &ResPQ_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P_QInnerData_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P_Q_inner_data_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P_Q_inner_data_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pq", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pq = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field P", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.P = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Q", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Q = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Nonce = append(m.Nonce[:0], dAtA[iNdEx:postIndex]...)
			if m.Nonce == nil {
				m.Nonce = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServerNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServerNonce = append(m.ServerNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.ServerNonce == nil {
				m.ServerNonce = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NewNonce", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NewNonce = append(m.NewNonce[:0], dAtA[iNdEx:postIndex]...)
			if m.NewNonce == nil {
				m.NewNonce = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dc", wireType)
			}
			m.Dc = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Dc |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresIn", wireType)
			}
			m.ExpiresIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresIn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *P_QInnerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: P_Q_inner_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: P_Q_inner_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &P_QInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPQInnerData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_p_q_inner_data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_p_q_inner_data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &P_QInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPQInnerDataDc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_p_q_inner_data_dc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_p_q_inner_data_dc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &P_QInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPQInnerDataTemp) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_p_q_inner_data_temp: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_p_q_inner_data_temp: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &P_QInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLPQInnerDataTempDc) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_p_q_inner_data_temp_dc: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_p_q_inner_data_temp_dc: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &P_QInnerData_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindAuthKeyInner_Data) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindAuthKeyInner_Data: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindAuthKeyInner_Data: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempAuthKeyId", wireType)
			}
			m.TempAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermAuthKeyId", wireType)
			}
			m.PermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TempSessionId", wireType)
			}
			m.TempSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TempSessionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *BindAuthKeyInner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BindAuthKeyInner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BindAuthKeyInner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BindAuthKeyInner_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLBindAuthKeyInner) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_bind_auth_key_inner: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_bind_auth_key_inner: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &BindAuthKeyInner_Data{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipSchemaTlHandshake(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthSchemaTlHandshake
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipSchemaTlHandshake(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowSchemaTlHandshake
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowSchemaTlHandshake
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthSchemaTlHandshake
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupSchemaTlHandshake
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthSchemaTlHandshake
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthSchemaTlHandshake        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowSchemaTlHandshake          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupSchemaTlHandshake = fmt.Errorf("proto: unexpected end of group")
)
